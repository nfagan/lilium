/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build/src/client.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build/playground/debug-frustum-grid.js":
/*!************************************************!*\
  !*** ./build/playground/debug-frustum-grid.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar wgl = __webpack_require__(/*! ../src/gl */ \"./build/src/gl/index.js\");\nvar frustum_grid_1 = __webpack_require__(/*! ./frustum-grid */ \"./build/playground/frustum-grid.js\");\nfunction setupDocument() {\n    var canvas = document.createElement('canvas');\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    wgl.debug.setupDocumentBody(wgl.debug.makeDebugMouseState());\n    document.body.appendChild(canvas);\n    canvas.width = canvas.getBoundingClientRect().width * window.devicePixelRatio;\n    canvas.height = canvas.getBoundingClientRect().height * window.devicePixelRatio;\n    var ctx = canvas.getContext('2d');\n    return ctx;\n}\nfunction render(ctx, frustumGrid, keyboard, posRot) {\n    var canvas = ctx.canvas;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    var mv = 10;\n    if (keyboard.isDown(wgl.Keys.left)) {\n        posRot[2] -= 0.1;\n    }\n    else if (keyboard.isDown(wgl.Keys.right)) {\n        posRot[2] += 0.1;\n    }\n    if (posRot[2] < 0)\n        posRot[2] = Math.PI * 2;\n    if (posRot[2] > Math.PI * 2)\n        posRot[2] = 0;\n    // if (keyboard.isDown(wgl.Keys.w)) frustumGrid.move([0, -mv]);\n    // if (keyboard.isDown(wgl.Keys.s)) frustumGrid.move([0, mv]);\n    // if (keyboard.isDown(wgl.Keys.a)) frustumGrid.move([-mv, 0]);\n    // if (keyboard.isDown(wgl.Keys.d)) frustumGrid.move([mv, 0]);\n    if (keyboard.isDown(wgl.Keys.w))\n        posRot[1] -= mv;\n    if (keyboard.isDown(wgl.Keys.s))\n        posRot[1] += mv;\n    if (keyboard.isDown(wgl.Keys.a))\n        posRot[0] -= mv;\n    if (keyboard.isDown(wgl.Keys.d))\n        posRot[0] += mv;\n    frustumGrid.update(posRot[0], posRot[1], posRot[2]);\n    frustumGrid.render(ctx);\n}\nfunction makeFrustumGrid() {\n    return new frustum_grid_1.FrustumGrid(20, 800, 800, 32, 0);\n}\nfunction main() {\n    var ctx = setupDocument();\n    var grid = makeFrustumGrid();\n    var kb = new wgl.Keyboard();\n    var pos = [0, 0, 0];\n    var updater = function () {\n        requestAnimationFrame(updater);\n        render(ctx, grid, kb, pos);\n    };\n    window.requestAnimationFrame(updater);\n}\nexports.main = main;\n\n\n//# sourceURL=webpack:///./build/playground/debug-frustum-grid.js?");

/***/ }),

/***/ "./build/playground/frustum-grid.js":
/*!******************************************!*\
  !*** ./build/playground/frustum-grid.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nfunction markFilledWith(a, x, z, assign) {\n    if (a[x] === undefined) {\n        a[x] = [];\n    }\n    a[x][z] = assign;\n}\nfunction getFilledWith(a, x, z) {\n    if (a[x] === undefined) {\n        return -1;\n    }\n    var res = a[x][z];\n    return res === undefined ? -1 : res;\n}\nfunction unmarkFilled(a, x, z) {\n    if (a[x] === undefined) {\n        a[x] = [];\n    }\n    a[x][z] = -1;\n}\nfunction satIntersects(cx0, cx1, cz0, cz1, nx, nz, trap0, trap1, trap2, trap3) {\n    var proj00 = cx0 * nx + cz0 * nz;\n    var proj01 = cx0 * nx + cz1 * nz;\n    var proj10 = cx1 * nx + cz0 * nz;\n    var proj11 = cx1 * nx + cz1 * nz;\n    //  Profile before removing if statements -- on safari 12.1, Math.min / max are 50% slower!\n    //  Min cell\n    var minCell = proj00;\n    if (proj01 < minCell) {\n        minCell = proj01;\n    }\n    if (proj10 < minCell) {\n        minCell = proj10;\n    }\n    if (proj11 < minCell) {\n        minCell = proj11;\n    }\n    //  Max cell\n    var maxCell = proj11;\n    if (proj00 > maxCell) {\n        maxCell = proj00;\n    }\n    if (proj01 > maxCell) {\n        maxCell = proj01;\n    }\n    if (proj10 > maxCell) {\n        maxCell = proj10;\n    }\n    //  Min trap\n    var minTrap = trap0;\n    if (trap1 < minTrap) {\n        minTrap = trap1;\n    }\n    if (trap2 < minTrap) {\n        minTrap = trap2;\n    }\n    if (trap3 < minTrap) {\n        minTrap = trap3;\n    }\n    //  Max trap\n    var maxTrap = trap0;\n    if (trap1 > maxTrap) {\n        maxTrap = trap1;\n    }\n    if (trap2 > maxTrap) {\n        maxTrap = trap2;\n    }\n    if (trap3 > maxTrap) {\n        maxTrap = trap3;\n    }\n    // const minCell = Math.min(proj00, proj01, proj10, proj11);\n    // const maxCell = Math.max(proj00, proj01, proj10, proj11);\n    // const minTrap = Math.min(trap0, trap1, trap2, trap3);\n    // const maxTrap = Math.max(trap0, trap1, trap2, trap3);\n    return !(maxCell < minTrap || minCell > maxTrap);\n}\nvar FrustumGrid = /** @class */ (function () {\n    function FrustumGrid(nearScale, farScale, zExtent, gridDim, zOffset) {\n        this.alphaRiseFactor = 0.1;\n        this.alphaDecayFactor = 0.01;\n        this.lastX = NaN;\n        this.lastZ = NaN;\n        this.lastTheta = NaN;\n        this.nearScale = nearScale;\n        this.farScale = farScale;\n        this.zExtent = zExtent;\n        this.gridDim = gridDim;\n        this.zOffset = zOffset;\n        this.n0 = gl_matrix_1.vec2.create();\n        this.n1 = gl_matrix_1.vec2.create();\n        this.f0 = gl_matrix_1.vec2.create();\n        this.f1 = gl_matrix_1.vec2.create();\n        this.f0[1] = zOffset + zExtent;\n        this.f1[0] = this.farScale;\n        this.f1[1] = zOffset + zExtent;\n        var amountOffset = (farScale - nearScale) / 2;\n        this.n0[0] = amountOffset;\n        this.n0[1] = zOffset;\n        this.n1[0] = amountOffset + nearScale;\n        this.n1[1] = zOffset;\n        this.normalX0 = gl_matrix_1.vec2.fromValues(-1, 0);\n        this.normalX1 = gl_matrix_1.vec2.fromValues(1, 0);\n        this.normalZ = gl_matrix_1.vec2.fromValues(0, 1);\n        this.gridScale = Math.max(farScale, nearScale, zExtent);\n        this.inUseSubToInd = [];\n        this.lastUsedIndices = new Set();\n        this.availableIndices = new Set();\n        this.decayingIndices = new Set();\n        var numCells = this.gridDim * this.gridDim;\n        // this.currentUsedIndices = new Int8Array(numCells);\n        // this.lastUsedIndices = new Int8Array(numCells);\n        // this.availableIndices = new Int32Array(numCells);\n        // this.decayingIndices = new Int8Array(numCells);\n        // this.currentUsedIndices.fill(-1);\n        // this.lastUsedIndices.fill(-1);\n        // this.decayingIndices.fill(-1);\n        // this.numAvailableIndices = numCells;\n        this.cellIndices = new Float32Array(numCells * 4);\n        this.makeGrid();\n    }\n    FrustumGrid.prototype.numCells = function () {\n        return this.gridDim * this.gridDim;\n    };\n    FrustumGrid.prototype.originX = function () {\n        return this.cellIndex(this.minX());\n    };\n    FrustumGrid.prototype.originZ = function () {\n        return this.cellIndex(this.minZ());\n    };\n    FrustumGrid.prototype.cellIndex = function (pos) {\n        return Math.floor(pos / this.cellSize());\n    };\n    FrustumGrid.prototype.minX = function () {\n        return Math.min(this.n0[0], this.n1[0], this.f0[0], this.f1[0]);\n    };\n    FrustumGrid.prototype.minZ = function () {\n        return Math.min(this.n0[1], this.n1[1], this.f0[1], this.f1[1]);\n    };\n    FrustumGrid.prototype.maxX = function () {\n        return Math.max(this.n0[0], this.n1[0], this.f0[0], this.f1[0]);\n    };\n    FrustumGrid.prototype.maxZ = function () {\n        return Math.max(this.n0[1], this.n1[1], this.f0[1], this.f1[1]);\n    };\n    FrustumGrid.prototype.makeGrid = function () {\n        this.cellColors = new Float32Array(this.gridDim * this.gridDim * 3);\n        var index = 0;\n        for (var i = 0; i < this.gridDim; i++) {\n            for (var j = 0; j < this.gridDim; j++) {\n                this.cellIndices[index * 4] = i;\n                this.cellIndices[index * 4 + 1] = j;\n                this.availableIndices.add(index);\n                // this.availableIndices[index] = index;\n                index++;\n            }\n        }\n    };\n    FrustumGrid.prototype.setPositionRotation = function (x, z, theta) {\n        var amountOffset = (this.farScale - this.nearScale) / 2;\n        var ct = Math.cos(theta);\n        var st = Math.sin(theta);\n        var f0x = -this.farScale / 2;\n        var f0z = this.zExtent + this.zOffset;\n        var f1x = this.farScale / 2;\n        var f1z = this.zExtent + this.zOffset;\n        var n0x = -this.farScale / 2 + amountOffset;\n        var n0z = this.zOffset;\n        var n1x = this.farScale / 2 - amountOffset;\n        var n1z = this.zOffset;\n        this.f0[0] = x + (f0x * ct - f0z * st);\n        this.f0[1] = z + (f0z * ct + f0x * st);\n        this.f1[0] = x + (f1x * ct - f1z * st);\n        this.f1[1] = z + (f1z * ct + f1x * st);\n        this.n0[0] = x + (n0x * ct - n0z * st);\n        this.n0[1] = z + (n0z * ct + n0x * st);\n        this.n1[0] = x + (n1x * ct - n1z * st);\n        this.n1[1] = z + (n1z * ct + n1x * st);\n    };\n    FrustumGrid.prototype.cellSize = function () {\n        return this.gridScale / this.gridDim;\n    };\n    FrustumGrid.prototype.makeNormal = function (v2, p1, p0) {\n        gl_matrix_1.vec2.sub(v2, p1, p0);\n        gl_matrix_1.vec2.normalize(v2, v2);\n        var tmp = v2[0];\n        v2[0] = v2[1];\n        v2[1] = -tmp;\n    };\n    FrustumGrid.prototype.updateNormals = function () {\n        this.makeNormal(this.normalX0, this.n0, this.f0);\n        this.makeNormal(this.normalX1, this.f1, this.n1);\n        this.makeNormal(this.normalZ, this.n1, this.n0);\n    };\n    FrustumGrid.prototype.update = function (xPos, zPos, theta) {\n        var _this = this;\n        this.setPositionRotation(xPos, zPos, theta);\n        var eps = 0.0001;\n        var isSameRotation = Math.abs(this.lastTheta - theta) < eps;\n        var isSamePos = Math.abs(this.lastX - xPos) < eps && Math.abs(this.lastZ - zPos) < eps;\n        this.lastX = xPos;\n        this.lastZ = zPos;\n        this.lastTheta = theta;\n        var cellSize = this.cellSize();\n        var alphaDecay = isSameRotation ? this.alphaDecayFactor : 1;\n        var alphaRise = isSameRotation ? this.alphaRiseFactor : 1;\n        var minX = this.minX();\n        var minZ = this.minZ();\n        var maxX = this.maxX();\n        var maxZ = this.maxZ();\n        var iMinX = this.cellIndex(minX);\n        var iMinZ = this.cellIndex(minZ);\n        var iMaxX = this.cellIndex(maxX);\n        var iMaxZ = this.cellIndex(maxZ);\n        var normX0 = this.normalX0;\n        var normX1 = this.normalX1;\n        var normZ = this.normalZ;\n        this.updateNormals();\n        var trap00 = this.n0[0] * normZ[0] + this.n0[1] * normZ[1];\n        var trap10 = this.n1[0] * normZ[0] + this.n1[1] * normZ[1];\n        var trap20 = this.f1[0] * normZ[0] + this.f1[1] * normZ[1];\n        var trap30 = this.f0[0] * normZ[0] + this.f0[1] * normZ[1];\n        var trap01 = this.n0[0] * -normZ[0] + this.n0[1] * -normZ[1];\n        var trap11 = this.n1[0] * -normZ[0] + this.n1[1] * -normZ[1];\n        var trap21 = this.f1[0] * -normZ[0] + this.f1[1] * -normZ[1];\n        var trap31 = this.f0[0] * -normZ[0] + this.f0[1] * -normZ[1];\n        var trap02 = this.n0[0] * normX0[0] + this.n0[1] * normX0[1];\n        var trap12 = this.n1[0] * normX0[0] + this.n1[1] * normX0[1];\n        var trap22 = this.f1[0] * normX0[0] + this.f1[1] * normX0[1];\n        var trap32 = this.f0[0] * normX0[0] + this.f0[1] * normX0[1];\n        var trap03 = this.n0[0] * normX1[0] + this.n0[1] * normX1[1];\n        var trap13 = this.n1[0] * normX1[0] + this.n1[1] * normX1[1];\n        var trap23 = this.f1[0] * normX1[0] + this.f1[1] * normX1[1];\n        var trap33 = this.f0[0] * normX1[0] + this.f0[1] * normX1[1];\n        var spanX = iMaxX - iMinX;\n        var spanZ = iMaxZ - iMinZ;\n        // const currentUsedIndices = this.currentUsedIndices;\n        // currentUsedIndices.fill(-1);\n        var currentUsedIndices = new Set();\n        var availableIndices = this.availableIndices;\n        var lastUsedIndices = this.lastUsedIndices;\n        var inUseSubToInd = this.inUseSubToInd;\n        var decayingIndices = this.decayingIndices;\n        var rawAvailableIndices = availableIndices.values();\n        for (var i = 0; i <= spanX; i++) {\n            for (var j = 0; j <= spanZ; j++) {\n                var ix0 = (iMinX + i);\n                var iz0 = (iMinZ + j);\n                var x0 = ix0 * cellSize;\n                var z0 = iz0 * cellSize;\n                var x1 = x0 + cellSize;\n                var z1 = z0 + cellSize;\n                var outOfBoundingBox = x1 < minX || z1 < minZ || x0 > maxX || z0 > maxZ;\n                var intersects = !outOfBoundingBox;\n                if (intersects) {\n                    intersects = intersects && satIntersects(x0, x1, z0, z1, normZ[0], normZ[1], trap00, trap10, trap20, trap30);\n                    intersects = intersects && satIntersects(x0, x1, z0, z1, -normZ[0], -normZ[1], trap01, trap11, trap21, trap31);\n                    intersects = intersects && satIntersects(x0, x1, z0, z1, normX0[0], normX0[1], trap02, trap12, trap22, trap32);\n                    intersects = intersects && satIntersects(x0, x1, z0, z1, normX1[0], normX1[1], trap03, trap13, trap23, trap33);\n                }\n                if (intersects) {\n                    var filledValue = getFilledWith(inUseSubToInd, ix0, iz0);\n                    if (filledValue === -1 && availableIndices.size > 0) {\n                        // if (filledValue === -1 && this.numAvailableIndices > 0) {\n                        var freeInd = rawAvailableIndices.next().value;\n                        availableIndices[\"delete\"](freeInd);\n                        currentUsedIndices.add(freeInd);\n                        decayingIndices[\"delete\"](freeInd);\n                        // const freeInd = availableIndices[--this.numAvailableIndices];\n                        // currentUsedIndices[freeInd] = 1;\n                        // decayingIndices[freeInd] = -1;\n                        markFilledWith(inUseSubToInd, ix0, iz0, freeInd);\n                        this.cellIndices[freeInd * 4] = ix0;\n                        this.cellIndices[freeInd * 4 + 1] = iz0;\n                        this.cellIndices[freeInd * 4 + 2] = 1;\n                        this.cellIndices[freeInd * 4 + 3] = 0.01;\n                        this.cellColors[freeInd * 3] = Math.random() * 127;\n                        this.cellColors[freeInd * 3 + 1] = Math.random() * 127;\n                        this.cellColors[freeInd * 3 + 2] = Math.random() * 127;\n                    }\n                    else if (filledValue !== -1) {\n                        var currAlpha = this.cellIndices[filledValue * 4 + 3];\n                        if (currAlpha < 1) {\n                            currAlpha += alphaRise;\n                        }\n                        if (currAlpha > 1) {\n                            currAlpha = 1;\n                        }\n                        this.cellIndices[filledValue * 4 + 3] = currAlpha;\n                        currentUsedIndices.add(filledValue);\n                        decayingIndices[\"delete\"](filledValue);\n                        // currentUsedIndices[filledValue] = 1;\n                        // decayingIndices[filledValue] = -1;\n                    }\n                }\n                else {\n                    var filledInd = getFilledWith(inUseSubToInd, ix0, iz0);\n                    if (filledInd !== -1) {\n                        unmarkFilled(inUseSubToInd, ix0, iz0);\n                        decayingIndices.add(filledInd);\n                        // decayingIndices[filledInd] = 1;\n                    }\n                }\n            }\n        }\n        lastUsedIndices.forEach(function (ind) {\n            if (!currentUsedIndices.has(ind)) {\n                var ix = _this.cellIndices[ind * 4];\n                var iz = _this.cellIndices[ind * 4 + 1];\n                availableIndices.add(ind);\n                decayingIndices.add(ind);\n                // this.cellIndices[ind*4+2] = 0;\n                unmarkFilled(inUseSubToInd, ix, iz);\n            }\n        });\n        decayingIndices.forEach(function (ind) {\n            var alpha = _this.cellIndices[ind * 4 + 3];\n            if (alpha > 0) {\n                alpha -= alphaDecay;\n                if (alpha < 0) {\n                    _this.cellIndices[ind * 4 + 2] = 0;\n                    alpha = 0;\n                    decayingIndices[\"delete\"](ind);\n                }\n                _this.cellIndices[ind * 4 + 3] = alpha;\n            }\n        });\n        this.lastUsedIndices = currentUsedIndices;\n        // const numCells = this.numCells();\n        // console.log(this.numAvailableIndices);\n        // for (let i = 0; i < numCells; i++) {\n        //   if (lastUsedIndices[i] > 0 && currentUsedIndices[i] < 0) {\n        //     const ix = this.cellIndices[i*4];\n        //     const iz = this.cellIndices[i*4+1];\n        //     availableIndices[this.numAvailableIndices++] = i;\n        //     decayingIndices[i] = 1;\n        //     unmarkFilled(inUseSubToInd, ix, iz);\n        //   }\n        // }\n        // for (let i = 0; i < numCells; i++) {\n        //   if (decayingIndices[i] > 0) {\n        //     let alpha = this.cellIndices[i*4+3];\n        //     if (alpha > 0) {\n        //       alpha -= alphaDecay;\n        //       if (alpha < 0) {\n        //         this.cellIndices[i*4+2] = 0;\n        //         alpha = 0;\n        //         decayingIndices[i] = -1;\n        //       }\n        //       this.cellIndices[i*4+3] = alpha;\n        //     }\n        //   }\n        // }\n        // this.lastUsedIndices.set(this.currentUsedIndices);\n    };\n    FrustumGrid.prototype.renderFrustum = function (ctx) {\n        ctx.beginPath();\n        ctx.moveTo(this.n0[0], this.n0[1]);\n        ctx.lineTo(this.n1[0], this.n1[1]);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(this.n1[0], this.n1[1]);\n        ctx.lineTo(this.f1[0], this.f1[1]);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(this.f1[0], this.f1[1]);\n        ctx.lineTo(this.f0[0], this.f0[1]);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(this.f0[0], this.f0[1]);\n        ctx.lineTo(this.n0[0], this.n0[1]);\n        ctx.stroke();\n    };\n    FrustumGrid.prototype.renderGrid = function (ctx) {\n        var cellSize = this.cellSize();\n        var numCells = this.gridDim * this.gridDim;\n        for (var i = 0; i < numCells; i++) {\n            if (this.cellIndices[i * 4 + 2] > 0) {\n                var cx = this.cellIndices[i * 4] * cellSize;\n                var cz = this.cellIndices[i * 4 + 1] * cellSize;\n                var r = this.cellColors[i * 3];\n                var g = this.cellColors[i * 3 + 2];\n                var b = this.cellColors[i * 3 + 1];\n                ctx.fillStyle = \"rgb(\" + r + \", \" + g + \", \" + b + \")\";\n                ctx.globalAlpha = this.cellIndices[i * 4 + 3];\n                ctx.fillRect(cx, cz, cellSize, cellSize);\n            }\n        }\n        ctx.globalAlpha = 1;\n    };\n    FrustumGrid.prototype.renderNormal = function (ctx, tmp, p0, p1, norm, sign, len) {\n        gl_matrix_1.vec2.add(tmp, p0, p1);\n        tmp[0] /= 2;\n        tmp[1] /= 2;\n        ctx.beginPath();\n        ctx.moveTo(tmp[0], tmp[1]);\n        ctx.lineTo(tmp[0] + norm[0] * len * sign, tmp[1] + norm[1] * len * sign);\n        ctx.stroke();\n    };\n    FrustumGrid.prototype.renderNormals = function (ctx) {\n        var tmp = gl_matrix_1.vec2.create();\n        var len = 100;\n        this.renderNormal(ctx, tmp, this.n0, this.n1, this.normalZ, 1, len);\n        this.renderNormal(ctx, tmp, this.f0, this.f1, this.normalZ, -1, len);\n        this.renderNormal(ctx, tmp, this.f1, this.n1, this.normalX1, 1, len);\n        this.renderNormal(ctx, tmp, this.f0, this.n0, this.normalX0, 1, len);\n    };\n    FrustumGrid.prototype.renderOuterBox = function (ctx) {\n        var ox = this.cellIndex(this.minX());\n        var oz = this.cellIndex(this.minZ());\n        var cellSize = this.cellSize();\n        // const maxX = this.cellIndex(this.maxX());\n        // const maxZ = this.cellIndex(this.maxZ());\n        var maxX = ox + this.gridDim;\n        var maxZ = oz + this.gridDim;\n        var spanX = maxX - ox + 1;\n        var spanZ = maxZ - oz + 1;\n        ctx.beginPath();\n        ctx.strokeRect(ox * cellSize, oz * cellSize, spanX * cellSize, spanZ * cellSize);\n    };\n    FrustumGrid.prototype.render = function (ctx) {\n        this.renderFrustum(ctx);\n        this.renderGrid(ctx);\n        this.renderNormals(ctx);\n        this.renderOuterBox(ctx);\n    };\n    return FrustumGrid;\n}());\nexports.FrustumGrid = FrustumGrid;\n\n\n//# sourceURL=webpack:///./build/playground/frustum-grid.js?");

/***/ }),

/***/ "./build/src/client.js":
/*!*****************************!*\
  !*** ./build/src/client.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// import { main } from '../playground/debug-components';\n// import { main } from '../playground/debug-sequencer';\n// import { main } from '../playground/debug-sequence-representation';\nexports.__esModule = true;\n// import { main } from '../playground/debug-synth';\n// import { main } from '../playground/debug-grass-again';\n// import { main } from '../playground/debug-terrain4';\nvar debug_frustum_grid_1 = __webpack_require__(/*! ../playground/debug-frustum-grid */ \"./build/playground/debug-frustum-grid.js\");\ndebug_frustum_grid_1.main();\n\n\n//# sourceURL=webpack:///./build/src/client.js?");

/***/ }),

/***/ "./build/src/gl/collision.js":
/*!***********************************!*\
  !*** ./build/src/gl/collision.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar math_1 = __webpack_require__(/*! ./math */ \"./build/src/gl/math.js\");\nvar gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nvar VoxelGridCollisionResult = /** @class */ (function () {\n    function VoxelGridCollisionResult() {\n        this.collided = false;\n        this.instant = 0;\n        this.face = -1;\n        this.normal = [0, 0, 0];\n        this.voxelIndex = [0, 0, 0];\n    }\n    VoxelGridCollisionResult.prototype.reset = function () {\n        for (var i = 0; i < 3; i++) {\n            this.normal[i] = 0;\n            this.voxelIndex[i] = -1;\n        }\n        this.collided = false;\n        this.instant = 0;\n        this.face = -1;\n    };\n    VoxelGridCollisionResult.prototype.isXFace = function () {\n        return isXFace(this.face);\n    };\n    VoxelGridCollisionResult.prototype.isYFace = function () {\n        return isYFace(this.face);\n    };\n    VoxelGridCollisionResult.prototype.isBottomFace = function () {\n        return isBottomFace(this.face);\n    };\n    VoxelGridCollisionResult.prototype.isTopFace = function () {\n        return isTopFace(this.face);\n    };\n    VoxelGridCollisionResult.prototype.isZFace = function () {\n        return isZFace(this.face);\n    };\n    VoxelGridCollisionResult.prototype.faceName = function () {\n        return faceName(this.face);\n    };\n    return VoxelGridCollisionResult;\n}());\nexports.VoxelGridCollisionResult = VoxelGridCollisionResult;\n;\nvar VoxelGridCollider = /** @class */ (function () {\n    function VoxelGridCollider(grid) {\n        this.grid = grid;\n        this.collisionResult = new VoxelGridCollisionResult();\n        this.intersectIdx = [0, 0, 0];\n        this.intersectAabb = new math_1.Aabb();\n    }\n    VoxelGridCollider.prototype.calculateComponentInstant = function (vel, gridMin, gridMax, testMin, testMax) {\n        if (vel > 0) {\n            return (gridMin - testMax) / vel;\n        }\n        else if (vel < 0) {\n            return (gridMax - testMin) / vel;\n        }\n        else {\n            return -Infinity;\n        }\n    };\n    VoxelGridCollider.prototype.calculateNormalComponent = function (vel) {\n        return vel === 0 ? 0 : vel > 0 ? -1 : 1;\n    };\n    VoxelGridCollider.prototype.calculateFaceIndex = function (vel, minComponent) {\n        if (vel === 0) {\n            //  no face.\n            return -1;\n        }\n        else if (vel < 0) {\n            //  +face\n            return minComponent + 1;\n        }\n        else {\n            //  -face\n            return minComponent;\n        }\n    };\n    VoxelGridCollider.prototype.collidesWithAabb3 = function (outResult, testAabb, vx, vy, vz) {\n        var grid = this.grid;\n        var intersectIdx = this.intersectIdx;\n        var intersectAabb = this.intersectAabb;\n        var pos = grid.position;\n        var cellDims = grid.cellDimensions;\n        var tMinX = Math.min(testAabb.minX, testAabb.minX + vx);\n        var tMinY = Math.min(testAabb.minY, testAabb.minY + vy);\n        var tMinZ = Math.min(testAabb.minZ, testAabb.minZ + vz);\n        //\n        var tMaxX = Math.max(testAabb.maxX, testAabb.maxX + vx);\n        var tMaxY = Math.max(testAabb.maxY, testAabb.maxY + vy);\n        var tMaxZ = Math.max(testAabb.maxZ, testAabb.maxZ + vz);\n        grid.getCellIndexOf3(intersectIdx, tMinX, tMinY, tMinZ);\n        var minIdxX = intersectIdx[0];\n        var minIdxY = intersectIdx[1];\n        var minIdxZ = intersectIdx[2];\n        grid.getCellIndexOf3(intersectIdx, tMaxX, tMaxY, tMaxZ);\n        var maxIdxX = intersectIdx[0];\n        var maxIdxY = intersectIdx[1];\n        var maxIdxZ = intersectIdx[2];\n        intersectAabb.minX = minIdxX * cellDims[0] + pos[0];\n        intersectAabb.minY = minIdxY * cellDims[1] + pos[1];\n        intersectAabb.minZ = minIdxZ * cellDims[2] + pos[2];\n        intersectAabb.maxX = Infinity;\n        intersectAabb.maxY = Infinity;\n        intersectAabb.maxZ = Infinity;\n        var numSpanningX = maxIdxX - minIdxX;\n        var numSpanningY = maxIdxY - minIdxY;\n        var numSpanningZ = maxIdxZ - minIdxZ;\n        var foundIntersection = false;\n        var minT = Infinity;\n        var normIdx = 0;\n        var normSign = 0;\n        var collidedFace = -1;\n        for (var i = 0; i <= numSpanningX; i++) {\n            for (var j = 0; j <= numSpanningY; j++) {\n                for (var k = 0; k <= numSpanningZ; k++) {\n                    var ix = minIdxX + i;\n                    var iy = minIdxY + j;\n                    var iz = minIdxZ + k;\n                    if (!grid.isFilled3(ix, iy, iz)) {\n                        continue;\n                    }\n                    var minX = ix * cellDims[0] + pos[0];\n                    var minY = iy * cellDims[1] + pos[1];\n                    var minZ = iz * cellDims[2] + pos[2];\n                    var maxX = minX + cellDims[0];\n                    var maxY = minY + cellDims[1];\n                    var maxZ = minZ + cellDims[2];\n                    var hitX = tMinX < maxX && tMaxX > minX;\n                    var hitY = tMinY < maxY && tMaxY > minY;\n                    var hitZ = tMinZ < maxZ && tMaxZ > minZ;\n                    var intersects = hitX && hitY && hitZ;\n                    if (!intersects) {\n                        continue;\n                    }\n                    foundIntersection = true;\n                    var tx = this.calculateComponentInstant(vx, minX, maxX, testAabb.minX, testAabb.maxX);\n                    var ty = this.calculateComponentInstant(vy, minY, maxY, testAabb.minY, testAabb.maxY);\n                    var tz = this.calculateComponentInstant(vz, minZ, maxZ, testAabb.minZ, testAabb.maxZ);\n                    var currentMinT = Infinity;\n                    var currentNormIdx = 0;\n                    var currentNormSign = 0;\n                    var currentCollidedFace = -1;\n                    if (tx >= 0 && tx < currentMinT) {\n                        if (vx > 0 || !grid.isFilled3(ix + 1, iy, iz)) {\n                            //  Ignore right-side collisions when there is a filled block to the right.\n                            currentMinT = tx;\n                            currentNormIdx = 2;\n                            currentNormSign = this.calculateNormalComponent(vx);\n                            currentCollidedFace = this.calculateFaceIndex(vx, 0);\n                        }\n                    }\n                    if (ty >= 0 && ty < currentMinT) {\n                        var okBot = vy > 0 || !grid.isFilled3(ix, iy + 1, iz);\n                        var okTop = vy < 0 || !grid.isFilled3(ix, iy - 1, iz);\n                        if (okBot && okTop) {\n                            //  Ignore top-side collisions when there is a filled block above,\n                            //  and bottom-side collisions when there is a filled block below.\n                            currentMinT = ty;\n                            currentNormIdx = 1;\n                            currentNormSign = this.calculateNormalComponent(vy);\n                            currentCollidedFace = this.calculateFaceIndex(vy, 2);\n                        }\n                    }\n                    if (tz >= 0 && tz < currentMinT) {\n                        currentMinT = tz;\n                        currentNormIdx = 0;\n                        currentNormSign = this.calculateNormalComponent(vz);\n                        currentCollidedFace = this.calculateFaceIndex(vz, 4);\n                    }\n                    if (currentMinT < minT) {\n                        minT = currentMinT;\n                        normIdx = currentNormIdx;\n                        normSign = currentNormSign;\n                        collidedFace = currentCollidedFace;\n                        outResult.voxelIndex[0] = ix;\n                        outResult.voxelIndex[1] = iy;\n                        outResult.voxelIndex[2] = iz;\n                    }\n                }\n            }\n        }\n        for (var i = 0; i < 3; i++) {\n            outResult.normal[i] = 0;\n        }\n        if (!foundIntersection) {\n            outResult.instant = 1;\n            outResult.collided = false;\n            outResult.face = -1;\n            return;\n        }\n        outResult.collided = true;\n        outResult.normal[normIdx] = normSign;\n        outResult.face = collidedFace;\n        if (minT === Infinity) {\n            outResult.instant = 0;\n        }\n        else {\n            outResult.instant = minT;\n        }\n    };\n    VoxelGridCollider.prototype.moveAabb = function (outCollisionResult, outAabb, inAabb, velocity) {\n        var vx = velocity[0];\n        var vy = velocity[1];\n        var vz = velocity[2];\n        outCollisionResult.reset();\n        this.collidesWithAabb3(outCollisionResult, inAabb, vx, vy, vz);\n        if (!outCollisionResult.collided) {\n            outAabb.assign(inAabb);\n            outAabb.move(velocity);\n            return;\n        }\n        var t = outCollisionResult.instant;\n        var remainingT = 1 - t;\n        outAabb.assign(inAabb);\n        outAabb.move3(vx * t, vy * t, vz * t);\n        var slideAmt = gl_matrix_1.vec3.dot(outCollisionResult.normal, velocity) * remainingT;\n        var slideVx = outCollisionResult.normal[0] * slideAmt;\n        var slideVz = outCollisionResult.normal[2] * slideAmt;\n        var ownCollisionResult = this.collisionResult;\n        ownCollisionResult.reset();\n        if (!outCollisionResult.isYFace()) {\n            var slideVy = vy * remainingT;\n            this.collidesWithAabb3(ownCollisionResult, outAabb, 0, slideVy, 0);\n            var yInstant = ownCollisionResult.instant;\n            outAabb.move3(0, slideVy * yInstant, 0);\n            ownCollisionResult.reset();\n            this.collidesWithAabb3(ownCollisionResult, outAabb, slideVx, 0, slideVz);\n            var slideT = ownCollisionResult.instant;\n            outAabb.move3(slideVx * slideT, 0, slideVz * slideT);\n        }\n        else {\n            this.collidesWithAabb3(ownCollisionResult, outAabb, slideVx, 0, slideVz);\n            var slideT = ownCollisionResult.instant;\n            outAabb.move3(slideVx * slideT, 0, slideVz * slideT);\n        }\n    };\n    return VoxelGridCollider;\n}());\nexports.VoxelGridCollider = VoxelGridCollider;\nfunction isXFace(face) {\n    return face === 0 || face === 1;\n}\nexports.isXFace = isXFace;\nfunction isLeftFace(face) {\n    return face === 0;\n}\nexports.isLeftFace = isLeftFace;\nfunction isRightFace(face) {\n    return face === 1;\n}\nexports.isRightFace = isRightFace;\nfunction isYFace(face) {\n    return face === 2 || face === 3;\n}\nexports.isYFace = isYFace;\nfunction isBottomFace(face) {\n    return face === 2;\n}\nexports.isBottomFace = isBottomFace;\nfunction isTopFace(face) {\n    return face === 3;\n}\nexports.isTopFace = isTopFace;\nfunction isBackFace(face) {\n    return face === 4;\n}\nexports.isBackFace = isBackFace;\nfunction isFrontFace(face) {\n    return face === 5;\n}\nexports.isFrontFace = isFrontFace;\nfunction isZFace(face) {\n    return face === 4 || face === 5;\n}\nexports.isZFace = isZFace;\nfunction faceName(face) {\n    switch (face) {\n        case -1:\n            return '<undefined>';\n        case 0:\n            return 'left';\n        case 1:\n            return 'right';\n        case 2:\n            return 'bottom';\n        case 3:\n            return 'top';\n        case 4:\n            return 'back';\n        case 5:\n            return 'front';\n        default:\n            return \"<unrecognized: \" + face + \">\";\n    }\n}\nexports.faceName = faceName;\n\n\n//# sourceURL=webpack:///./build/src/gl/collision.js?");

/***/ }),

/***/ "./build/src/gl/debug/debug.js":
/*!*************************************!*\
  !*** ./build/src/gl/debug/debug.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar util_1 = __webpack_require__(/*! ../../util */ \"./build/src/util/index.js\");\nvar __1 = __webpack_require__(/*! .. */ \"./build/src/gl/index.js\");\nvar gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nfunction segmentedQuadPositions(numSegments) {\n    var segmentSize = 1 / numSegments;\n    var positions = [];\n    for (var i = 0; i < numSegments; i++) {\n        var x0 = -1.0;\n        var x1 = 1.0;\n        var y0 = i * segmentSize;\n        var y1 = y0 + segmentSize;\n        var z = 0;\n        //  tri1.\n        positions.push(x0);\n        positions.push(y1);\n        positions.push(z);\n        positions.push(x0);\n        positions.push(y0);\n        positions.push(z);\n        positions.push(x1);\n        positions.push(y0);\n        positions.push(z);\n        //  tri2.\n        positions.push(x1);\n        positions.push(y0);\n        positions.push(z);\n        positions.push(x1);\n        positions.push(y1);\n        positions.push(z);\n        positions.push(x0);\n        positions.push(y1);\n        positions.push(z);\n    }\n    return new Float32Array(positions);\n}\nexports.segmentedQuadPositions = segmentedQuadPositions;\nfunction cubeNormals() {\n    return new Float32Array([\n        0, 0, -1,\n        0, 0, -1,\n        0, 0, -1,\n        0, 0, -1,\n        0, 0, 1,\n        0, 0, 1,\n        0, 0, 1,\n        0, 0, 1,\n        0, -1, 0,\n        0, -1, 0,\n        0, -1, 0,\n        0, -1, 0,\n        0, 1, 0,\n        0, 1, 0,\n        0, 1, 0,\n        0, 1, 0,\n        -1, 0, 0,\n        -1, 0, 0,\n        -1, 0, 0,\n        -1, 0, 0,\n        1, 0, 0,\n        1, 0, 0,\n        1, 0, 0,\n        1, 0, 0,\n    ]);\n}\nexports.cubeNormals = cubeNormals;\nfunction cubePositions() {\n    return new Float32Array([\n        -1.0, -1.0, 1.0,\n        1.0, -1.0, 1.0,\n        1.0, 1.0, 1.0,\n        -1.0, 1.0, 1.0,\n        -1.0, -1.0, -1.0,\n        -1.0, 1.0, -1.0,\n        1.0, 1.0, -1.0,\n        1.0, -1.0, -1.0,\n        -1.0, 1.0, -1.0,\n        -1.0, 1.0, 1.0,\n        1.0, 1.0, 1.0,\n        1.0, 1.0, -1.0,\n        -1.0, -1.0, -1.0,\n        1.0, -1.0, -1.0,\n        1.0, -1.0, 1.0,\n        -1.0, -1.0, 1.0,\n        1.0, -1.0, -1.0,\n        1.0, 1.0, -1.0,\n        1.0, 1.0, 1.0,\n        1.0, -1.0, 1.0,\n        -1.0, -1.0, -1.0,\n        -1.0, -1.0, 1.0,\n        -1.0, 1.0, 1.0,\n        -1.0, 1.0, -1.0,\n    ]);\n}\nexports.cubePositions = cubePositions;\nfunction sphereInterleavedDataAndIndices(vertexCount) {\n    if (vertexCount === void 0) { vertexCount = 64; }\n    var vertexData = [];\n    for (var i = 0; i < vertexCount; i++) {\n        for (var j = 0; j < vertexCount; j++) {\n            var xSegment = j / (vertexCount - 1);\n            var ySegment = i / (vertexCount - 1);\n            var xPos = Math.cos(xSegment * 2 * Math.PI) * Math.sin(ySegment * Math.PI);\n            var yPos = Math.cos(ySegment * Math.PI);\n            var zPos = Math.sin(xSegment * 2 * Math.PI) * Math.sin(ySegment * Math.PI);\n            vertexData.push(xPos);\n            vertexData.push(yPos);\n            vertexData.push(zPos);\n            vertexData.push(xSegment);\n            vertexData.push(ySegment);\n            vertexData.push(xPos);\n            vertexData.push(yPos);\n            vertexData.push(zPos);\n        }\n    }\n    var firstIndex = 0;\n    var nextIndex = vertexCount;\n    var indexStp = 0;\n    var shouldProceed = true;\n    var indices = [];\n    while (shouldProceed) {\n        indices.push(firstIndex);\n        indices.push(nextIndex);\n        indexStp += 2;\n        shouldProceed = nextIndex != (vertexCount * vertexCount) - 1;\n        if (indexStp > 0 && (nextIndex + 1) % vertexCount == 0 && shouldProceed) {\n            indices.push(nextIndex);\n            indices.push(firstIndex + 1);\n            indexStp += 2;\n        }\n        firstIndex++;\n        nextIndex++;\n    }\n    return {\n        vertexData: new Float32Array(vertexData),\n        indices: new Uint16Array(indices)\n    };\n}\nexports.sphereInterleavedDataAndIndices = sphereInterleavedDataAndIndices;\nfunction cubeInterleavedPositionsNormals() {\n    return new Float32Array([\n        -1.0, -1.0, 1.0, 0, 0, 1,\n        1.0, -1.0, 1.0, 0, 0, 1,\n        1.0, 1.0, 1.0, 0, 0, 1,\n        -1.0, 1.0, 1.0, 0, 0, 1,\n        -1.0, -1.0, -1.0, 0, 0, -1,\n        -1.0, 1.0, -1.0, 0, 0, -1,\n        1.0, 1.0, -1.0, 0, 0, -1,\n        1.0, -1.0, -1.0, 0, 0, -1,\n        -1.0, 1.0, -1.0, 0, 1, 0,\n        -1.0, 1.0, 1.0, 0, 1, 0,\n        1.0, 1.0, 1.0, 0, 1, 0,\n        1.0, 1.0, -1.0, 0, 1, 0,\n        -1.0, -1.0, -1.0, 0, -1, 0,\n        1.0, -1.0, -1.0, 0, -1, 0,\n        1.0, -1.0, 1.0, 0, -1, 0,\n        -1.0, -1.0, 1.0, 0, -1, 0,\n        1.0, -1.0, -1.0, 1, 0, 0,\n        1.0, 1.0, -1.0, 1, 0, 0,\n        1.0, 1.0, 1.0, 1, 0, 0,\n        1.0, -1.0, 1.0, 1, 0, 0,\n        -1.0, -1.0, -1.0, -1, 0, 0,\n        -1.0, -1.0, 1.0, -1, 0, 0,\n        -1.0, 1.0, 1.0, -1, 0, 0,\n        -1.0, 1.0, -1.0, -1, 0, 0,\n    ]);\n}\nexports.cubeInterleavedPositionsNormals = cubeInterleavedPositionsNormals;\nfunction cubeIndices() {\n    return new Uint16Array([\n        0, 1, 2, 0, 2, 3,\n        4, 5, 6, 4, 6, 7,\n        8, 9, 10, 8, 10, 11,\n        12, 13, 14, 12, 14, 15,\n        16, 17, 18, 16, 18, 19,\n        20, 21, 22, 20, 22, 23,\n    ]);\n}\nexports.cubeIndices = cubeIndices;\nfunction quadPositions() {\n    return new Float32Array([\n        -1.0, -1.0, 1.0,\n        1.0, -1.0, 1.0,\n        1.0, 1.0, 1.0,\n        -1.0, 1.0, 1.0,\n    ]);\n}\nexports.quadPositions = quadPositions;\nfunction quadIndices() {\n    return new Uint16Array([0, 1, 2, 0, 2, 3]);\n}\nexports.quadIndices = quadIndices;\nfunction checkError(res) {\n    if (!res.isOk()) {\n        console.error(res.unwrapErr());\n        return true;\n    }\n    return false;\n}\nexports.checkError = checkError;\nfunction unwrapResult(res) {\n    if (res.isErr()) {\n        throw new Error(res.unwrapErr());\n    }\n    else {\n        return res.unwrap();\n    }\n}\nexports.unwrapResult = unwrapResult;\nfunction drawAxesPlanes(gl, prog, model, drawFunction) {\n    //  Z\n    gl_matrix_1.mat4.identity(model);\n    gl_matrix_1.mat4.scale(model, model, [0.5, 0.5, 0.5]);\n    gl_matrix_1.mat4.translate(model, model, [0, 0, -1]);\n    //\n    prog.setMat4('model', model);\n    prog.set3f('color', 1, 0, 0);\n    drawFunction(gl);\n    //  X\n    gl_matrix_1.mat4.identity(model);\n    gl_matrix_1.mat4.scale(model, model, [0.5, 0.5, 0.5]);\n    gl_matrix_1.mat4.translate(model, model, [-1, 0, 0]);\n    gl_matrix_1.mat4.rotate(model, model, gl_matrix_1.glMatrix.toRadian(90), [0, 1, 0]);\n    //\n    prog.setMat4('model', model);\n    prog.set3f('color', 0, 0, 1);\n    drawFunction(gl);\n    //  Y\n    gl_matrix_1.mat4.identity(model);\n    gl_matrix_1.mat4.scale(model, model, [0.5, 0.5, 0.5]);\n    gl_matrix_1.mat4.rotate(model, model, gl_matrix_1.glMatrix.toRadian(90), [1, 0, 0]);\n    prog.setMat4('model', model);\n    prog.set3f('color', 0, 1, 0);\n    drawFunction(gl);\n}\nexports.drawAxesPlanes = drawAxesPlanes;\nfunction drawOrigin(gl, prog, model, drawFunction) {\n    gl_matrix_1.mat4.identity(model);\n    gl_matrix_1.mat4.scale(model, model, [0.25, 0.25, 0.25]);\n    prog.setMat4('model', model);\n    prog.set3f('color', 1, 1, 1);\n    drawFunction(gl);\n}\nexports.drawOrigin = drawOrigin;\nfunction drawAabb(gl, prog, model, aabb, color, drawFunction) {\n    var w = aabb.width();\n    var h = aabb.height();\n    var d = aabb.depth();\n    var x = aabb.minX + w / 2;\n    var y = aabb.minY + h / 2;\n    var z = aabb.minZ + d / 2;\n    gl_matrix_1.mat4.identity(model);\n    gl_matrix_1.mat4.translate(model, model, [x, y, z]);\n    gl_matrix_1.mat4.scale(model, model, [w / 2, h / 2, d / 2]);\n    prog.setMat4('model', model);\n    prog.setVec3('color', color);\n    drawFunction(gl);\n}\nexports.drawAabb = drawAabb;\nfunction makeFollowCamera(gl) {\n    var camera = new __1.FollowCamera();\n    camera.followDistance = 10;\n    camera.rotate(Math.PI, Math.PI / 6);\n    camera.setAspect(gl.canvas.clientWidth / gl.canvas.clientHeight);\n    camera.setNear(0.1);\n    camera.setFar(1000);\n    camera.setFieldOfView(45 * Math.PI / 180);\n    return camera;\n}\nexports.makeFollowCamera = makeFollowCamera;\nfunction drawAt(gl, prog, model, pos, sz, color, drawFunction) {\n    gl_matrix_1.mat4.identity(model);\n    gl_matrix_1.mat4.translate(model, model, pos);\n    if (typeof sz === 'number') {\n        gl_matrix_1.mat4.scale(model, model, [sz, sz, sz]);\n    }\n    else {\n        gl_matrix_1.mat4.scale(model, model, sz);\n    }\n    prog.setMat4('model', model);\n    prog.setVec3('color', color);\n    drawFunction(gl);\n}\nexports.drawAt = drawAt;\nfunction drawGroundPlane(gl, prog, model, scale, drawable, color) {\n    gl_matrix_1.mat4.identity(model);\n    gl_matrix_1.mat4.translate(model, model, [0, scale, 0]);\n    gl_matrix_1.mat4.rotateX(model, model, Math.PI / 2);\n    gl_matrix_1.mat4.scale(model, model, [scale, scale, scale]);\n    prog.setMat4('model', model);\n    prog.setVec3('color', color);\n    drawable.drawFunction(gl);\n}\nexports.drawGroundPlane = drawGroundPlane;\nfunction beginRender(gl, camera, dpr, forceUpdate) {\n    if (forceUpdate === void 0) { forceUpdate = false; }\n    gl.enable(gl.CULL_FACE);\n    gl.enable(gl.DEPTH_TEST);\n    if (forceUpdate || gl.canvas.width !== gl.canvas.clientWidth || gl.canvas.height !== gl.canvas.clientHeight) {\n        dpr = dpr || window.devicePixelRatio || 1;\n        gl.canvas.width = gl.canvas.clientWidth * dpr;\n        gl.canvas.height = gl.canvas.clientHeight * dpr;\n        camera.setAspect(gl.canvas.clientWidth / gl.canvas.clientHeight);\n    }\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    gl.clearDepth(1.0);\n    gl.cullFace(gl.FRONT);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n}\nexports.beginRender = beginRender;\nfunction updateFollowCamera(dt, camera, target, mouseState, keyboard) {\n    var dtFactor = Math.max(dt / (1 / 60), 1);\n    if (isNaN(mouseState.x) || isNaN(mouseState.y)) {\n        mouseState.x = 0;\n        mouseState.y = 0;\n    }\n    if (keyboard.isDown(__1.Keys.leftShift) || mouseState.touchDown) {\n        camera.rotate(mouseState.x * 0.01, mouseState.y * 0.01);\n    }\n    mouseState.x *= (0.75 / dtFactor);\n    mouseState.y *= (0.75 / dtFactor);\n    if (Math.abs(mouseState.x) < __1.math.EPSILON) {\n        mouseState.x = 0;\n    }\n    if (Math.abs(mouseState.y) < __1.math.EPSILON) {\n        mouseState.y = 0;\n    }\n    camera.targetTo3(target[0], target[1], target[2]);\n}\nexports.updateFollowCamera = updateFollowCamera;\nfunction setViewProjection(prog, view, proj) {\n    prog.setMat4('view', view);\n    prog.setMat4('projection', proj);\n}\nexports.setViewProjection = setViewProjection;\nfunction makeProjectionMatrix(gl, out) {\n    var fov = 45 * Math.PI / 180;\n    var ar = gl.canvas.clientWidth / gl.canvas.clientHeight;\n    return gl_matrix_1.mat4.perspective(out, fov, ar, 0.1, 1000);\n}\nexports.makeProjectionMatrix = makeProjectionMatrix;\nfunction tryCreateProgramFromSources(gl, vsSource, fsSource) {\n    try {\n        var prog = __1.Program.fromSources(gl, vsSource, fsSource);\n        return util_1.Result.Ok(prog);\n    }\n    catch (err) {\n        return util_1.Result.Err(err.message);\n    }\n}\nexports.tryCreateProgramFromSources = tryCreateProgramFromSources;\nfunction makeDebugMouseState() {\n    return {\n        x: null,\n        y: null,\n        lastX: null,\n        lastY: null,\n        clicked: false,\n        down: false,\n        touchDown: false\n    };\n}\nexports.makeDebugMouseState = makeDebugMouseState;\nfunction createCanvasAndContext(appendTo) {\n    var canvas = document.createElement('canvas');\n    canvas.style.height = '100%';\n    canvas.style.width = '100%';\n    var gl = canvas.getContext('webgl', { antialias: true });\n    if (!gl) {\n        return util_1.Result.Err('Failed to initialize WebGL render context.');\n    }\n    appendTo.appendChild(canvas);\n    return util_1.Result.Ok(gl);\n}\nexports.createCanvasAndContext = createCanvasAndContext;\nfunction maximizeDocumentBody() {\n    ['left', 'top', 'margin', 'padding'].map(function (v) { return document.body.style[v] = '0'; });\n    document.body.style.position = 'fixed';\n    document.body.style.height = '100%';\n    document.body.style.width = '100%';\n}\nexports.maximizeDocumentBody = maximizeDocumentBody;\nfunction setupDocumentBody(mouseState) {\n    maximizeDocumentBody();\n    document.body.addEventListener('touchstart', function (e) {\n        e.preventDefault();\n        mouseState.down = true;\n        mouseState.touchDown = true;\n        if (e.touches.length > 0) {\n            mouseState.lastX = e.touches[0].clientX;\n            mouseState.lastY = e.touches[0].clientY;\n        }\n    });\n    document.body.addEventListener('touchmove', function (e) {\n        if (e.touches.length > 0) {\n            if (mouseState.lastX === null) {\n                mouseState.lastX = e.touches[0].clientX;\n                mouseState.lastY = e.touches[0].clientY;\n            }\n            mouseState.x = e.touches[0].clientX - mouseState.lastX;\n            mouseState.y = e.touches[0].clientY - mouseState.lastY;\n            mouseState.lastX = e.touches[0].clientX;\n            mouseState.lastY = e.touches[0].clientY;\n        }\n    });\n    document.body.addEventListener('touchend', function (e) {\n        mouseState.lastY = null;\n        mouseState.lastX = null;\n        mouseState.down = false;\n        mouseState.touchDown = false;\n        mouseState.x = 0;\n        mouseState.y = 0;\n    });\n    document.body.addEventListener('mousedown', function (e) { return mouseState.down = true; });\n    document.body.addEventListener('mouseup', function (e) { return mouseState.down = false; });\n    document.body.addEventListener('mousemove', function (e) {\n        mouseState.x = e.movementX;\n        mouseState.y = e.movementY;\n        mouseState.lastX = e.clientX;\n        mouseState.lastY = e.clientY;\n    });\n}\nexports.setupDocumentBody = setupDocumentBody;\nfunction styleTouchElement(el, sz, offsetX, offsetY, color, rightJustify) {\n    el.style.width = sz + \"px\";\n    el.style.height = sz + \"px\";\n    el.style.position = 'fixed';\n    el.style.bottom = offsetY * sz + \"px\";\n    el.style.backgroundColor = color;\n    el.style.opacity = '0.25';\n    if (rightJustify) {\n        el.style.left = window.innerWidth - sz + \"px\";\n    }\n    else {\n        el.style.left = \"\" + offsetX * sz;\n    }\n}\nfunction addTouchElementEventListener(element, keyboard, key) {\n    element.addEventListener('touchstart', function (e) {\n        e.preventDefault();\n        keyboard.markDown(key);\n    });\n    element.addEventListener('touchend', function (_) { return keyboard.markUp(key); });\n    element.addEventListener('touchcancel', function (_) { return keyboard.markUp(key); });\n}\nfunction createTouchControls(keyboard) {\n    var left = document.createElement('div');\n    var right = document.createElement('div');\n    var down = document.createElement('div');\n    var up = document.createElement('div');\n    var jump = document.createElement('div');\n    var toggleQuality = document.createElement('div');\n    var sz = 50;\n    styleTouchElement(left, sz, 0, 1, 'red');\n    styleTouchElement(right, sz, 1, 1, 'blue');\n    styleTouchElement(down, sz, 0.5, 0, 'green');\n    styleTouchElement(up, sz, 0.5, 2, 'yellow');\n    styleTouchElement(jump, sz, 0, 0, 'yellow', true);\n    styleTouchElement(toggleQuality, sz, 0, 1, 'red', true);\n    addTouchElementEventListener(left, keyboard, __1.Keys.a);\n    addTouchElementEventListener(right, keyboard, __1.Keys.d);\n    addTouchElementEventListener(down, keyboard, __1.Keys.s);\n    addTouchElementEventListener(up, keyboard, __1.Keys.w);\n    addTouchElementEventListener(jump, keyboard, __1.Keys.space);\n    addTouchElementEventListener(toggleQuality, keyboard, __1.Keys.k);\n    document.body.appendChild(left);\n    document.body.appendChild(right);\n    document.body.appendChild(down);\n    document.body.appendChild(up);\n    document.body.appendChild(jump);\n    document.body.appendChild(toggleQuality);\n    return { left: left, right: right, down: down, up: up, jump: jump, toggleQuality: toggleQuality };\n}\nexports.createTouchControls = createTouchControls;\n\n\n//# sourceURL=webpack:///./build/src/gl/debug/debug.js?");

/***/ }),

/***/ "./build/src/gl/debug/index.js":
/*!*************************************!*\
  !*** ./build/src/gl/debug/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nexports.__esModule = true;\n__export(__webpack_require__(/*! ./debug */ \"./build/src/gl/debug/debug.js\"));\n\n\n//# sourceURL=webpack:///./build/src/gl/debug/index.js?");

/***/ }),

/***/ "./build/src/gl/factory/index.js":
/*!***************************************!*\
  !*** ./build/src/gl/factory/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar vao = __webpack_require__(/*! ./vao */ \"./build/src/gl/factory/vao.js\");\nexports.vao = vao;\n\n\n//# sourceURL=webpack:///./build/src/gl/factory/index.js?");

/***/ }),

/***/ "./build/src/gl/factory/vao.js":
/*!*************************************!*\
  !*** ./build/src/gl/factory/vao.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar geometry = __webpack_require__(/*! ../geometry */ \"./build/src/gl/geometry.js\");\nvar vao_1 = __webpack_require__(/*! ../vao */ \"./build/src/gl/vao.js\");\nvar types = __webpack_require__(/*! ../types */ \"./build/src/gl/types.js\");\nfunction makeCubeVao(gl, prog, identifiers) {\n    var cubeIndices = geometry.cubeIndices();\n    var cubeData = geometry.cubeInterleavedPositionsNormals();\n    var attrs = [0 /* Position */, 1 /* Normal */];\n    return {\n        vao: vao_1.Vao.fromSimpleInterleavedFloatData(gl, prog, cubeData, attrs, cubeIndices, identifiers),\n        numIndices: cubeIndices.length,\n        drawMode: gl.TRIANGLES\n    };\n}\nexports.makeCubeVao = makeCubeVao;\nfunction makeQuadUvVao(gl, prog, identifiers) {\n    var quadData = geometry.quadPositionsUvs();\n    var quadIndices = geometry.quadIndices();\n    var attrs = [0 /* Position */, 2 /* Uv */];\n    return {\n        vao: vao_1.Vao.fromSimpleInterleavedFloatData(gl, prog, quadData, attrs, quadIndices, identifiers),\n        numIndices: quadIndices.length,\n        drawMode: gl.TRIANGLES\n    };\n}\nexports.makeQuadUvVao = makeQuadUvVao;\nfunction makeSphereVao(gl, prog, identifiers) {\n    var sphereData = geometry.sphereInterleavedDataAndIndices();\n    var attrs = [0 /* Position */, 2 /* Uv */, 1 /* Normal */];\n    return {\n        vao: vao_1.Vao.fromSimpleInterleavedFloatData(gl, prog, sphereData.vertexData, attrs, sphereData.indices, identifiers),\n        numIndices: sphereData.indices.length,\n        drawMode: gl.TRIANGLE_STRIP\n    };\n}\nexports.makeSphereVao = makeSphereVao;\n\n\n//# sourceURL=webpack:///./build/src/gl/factory/vao.js?");

/***/ }),

/***/ "./build/src/gl/follow-camera.js":
/*!***************************************!*\
  !*** ./build/src/gl/follow-camera.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nvar _1 = __webpack_require__(/*! . */ \"./build/src/gl/index.js\");\nvar FollowCamera = /** @class */ (function () {\n    function FollowCamera() {\n        this.aspectRatio = 1;\n        this.nearPlane = 0.1;\n        this.farPlane = 100;\n        this.fieldOfView = 45 * Math.PI / 180;\n        this.areProjectionComponentsDirty = true;\n        this.followDistance = 15;\n        this.maxPolar = Math.PI / 2;\n        this.minPolar = -Infinity;\n        this.target = gl_matrix_1.vec3.create();\n        this.position = gl_matrix_1.vec3.fromValues(0, 0, this.followDistance);\n        this.tmpVec = gl_matrix_1.vec3.create();\n        this.worldUp = gl_matrix_1.vec3.fromValues(0, 1, 0);\n        this.right = gl_matrix_1.vec3.fromValues(1, 0, 0);\n        this.up = gl_matrix_1.vec3.fromValues(0, 1, 0);\n        this.view = gl_matrix_1.mat4.create();\n        this.projection = gl_matrix_1.mat4.create();\n    }\n    FollowCamera.prototype.rotate = function (dx, dy) {\n        var tmpVec = this.tmpVec;\n        var pos = this.position;\n        var targ = this.target;\n        //  Vector from target -> position\n        gl_matrix_1.vec3.sub(tmpVec, pos, targ);\n        gl_matrix_1.vec3.normalize(tmpVec, tmpVec);\n        var theta = Math.atan2(tmpVec[0], tmpVec[2]);\n        var phi = Math.acos(tmpVec[1]);\n        var eps = 0.000001;\n        var newTheta = theta + dx;\n        var newPhi = phi - dy;\n        newPhi = Math.max(this.minPolar, Math.min(this.maxPolar, newPhi));\n        newPhi = Math.max(eps, Math.min(Math.PI - eps, newPhi));\n        var sinPhi = Math.sin(newPhi);\n        //  Spherical -> cartesian\n        tmpVec[0] = sinPhi * Math.sin(newTheta) * this.followDistance;\n        tmpVec[1] = Math.cos(newPhi) * this.followDistance;\n        tmpVec[2] = sinPhi * Math.cos(newTheta) * this.followDistance;\n        gl_matrix_1.vec3.add(pos, targ, tmpVec);\n    };\n    FollowCamera.prototype.getFieldOfView = function () {\n        return this.fieldOfView;\n    };\n    FollowCamera.prototype.getFront = function (out) {\n        _1.math.sub3(out, this.position, this.target);\n        _1.math.norm3(out, out);\n    };\n    FollowCamera.prototype.getFrontXz = function (out) {\n        this.getFront(out);\n        out[1] = 0;\n        _1.math.norm3(out, out);\n    };\n    FollowCamera.prototype.getRight = function (out) {\n        for (var i = 0; i < 3; i++) {\n            out[i] = this.right[i];\n        }\n    };\n    FollowCamera.prototype.move = function (deltas) {\n        _1.math.add3(this.position, this.position, deltas);\n        _1.math.add3(this.target, this.target, deltas);\n    };\n    FollowCamera.prototype.moveNeg = function (deltas) {\n        _1.math.sub3(this.position, this.position, deltas);\n        _1.math.sub3(this.target, this.target, deltas);\n    };\n    FollowCamera.prototype.targetTo = function (pos) {\n        _1.math.sub3(this.tmpVec, pos, this.target);\n        _1.math.add3(this.target, this.target, this.tmpVec);\n        _1.math.add3(this.position, this.position, this.tmpVec);\n    };\n    FollowCamera.prototype.targetTo3 = function (x, y, z) {\n        this.tmpVec[0] = x - this.target[0];\n        this.tmpVec[1] = y - this.target[1];\n        this.tmpVec[2] = z - this.target[2];\n        gl_matrix_1.vec3.add(this.target, this.target, this.tmpVec);\n        gl_matrix_1.vec3.add(this.position, this.position, this.tmpVec);\n    };\n    FollowCamera.prototype.setAspect = function (ratio) {\n        if (this.aspectRatio !== ratio) {\n            this.areProjectionComponentsDirty = true;\n        }\n        this.aspectRatio = ratio;\n    };\n    FollowCamera.prototype.setFieldOfView = function (fov) {\n        if (this.fieldOfView !== fov) {\n            this.areProjectionComponentsDirty = true;\n        }\n        this.fieldOfView = fov;\n    };\n    FollowCamera.prototype.setNear = function (near) {\n        if (this.nearPlane !== near) {\n            this.areProjectionComponentsDirty = true;\n        }\n        this.nearPlane = near;\n    };\n    FollowCamera.prototype.setFar = function (far) {\n        if (this.farPlane !== far) {\n            this.areProjectionComponentsDirty = true;\n        }\n        this.farPlane = far;\n    };\n    FollowCamera.prototype.makeProjectionMatrix = function () {\n        var proj = this.projection;\n        if (!this.areProjectionComponentsDirty) {\n            return proj;\n        }\n        this.areProjectionComponentsDirty = false;\n        return gl_matrix_1.mat4.perspective(proj, this.fieldOfView, this.aspectRatio, this.nearPlane, this.farPlane);\n    };\n    FollowCamera.prototype.makeViewMatrix = function () {\n        var pos = this.position;\n        var targ = this.target;\n        var tmpVec = this.tmpVec;\n        var right = this.right;\n        var up = this.up;\n        var view = this.view;\n        var front = gl_matrix_1.vec3.sub(tmpVec, pos, targ);\n        gl_matrix_1.vec3.normalize(front, front);\n        gl_matrix_1.vec3.cross(right, front, this.worldUp);\n        gl_matrix_1.vec3.normalize(right, right);\n        gl_matrix_1.vec3.cross(up, right, front);\n        gl_matrix_1.vec3.normalize(up, up);\n        //  view(0, :) = right\n        view[0] = right[0];\n        view[4] = right[1];\n        view[8] = right[2];\n        //  view(1, :) = up\n        view[1] = up[0];\n        view[5] = up[1];\n        view[9] = up[2];\n        //  view(2, :) = front\n        view[2] = front[0];\n        view[6] = front[1];\n        view[10] = front[2];\n        view[12] = -gl_matrix_1.vec3.dot(right, pos);\n        view[13] = -gl_matrix_1.vec3.dot(up, pos);\n        view[14] = -gl_matrix_1.vec3.dot(front, pos);\n        return view;\n    };\n    return FollowCamera;\n}());\nexports.FollowCamera = FollowCamera;\n\n\n//# sourceURL=webpack:///./build/src/gl/follow-camera.js?");

/***/ }),

/***/ "./build/src/gl/geometry.js":
/*!**********************************!*\
  !*** ./build/src/gl/geometry.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nfunction quadPositions() {\n    return new Float32Array([\n        -1.0, -1.0, 1.0,\n        1.0, -1.0, 1.0,\n        1.0, 1.0, 1.0,\n        -1.0, 1.0, 1.0,\n    ]);\n}\nexports.quadPositions = quadPositions;\nfunction quadPositionsUvs() {\n    return new Float32Array([\n        -1, -1, 1, 0, 0,\n        1, -1, 1, 1, 0,\n        1, 1, 1, 1, 1,\n        -1, 1, 1, 0, 1\n    ]);\n}\nexports.quadPositionsUvs = quadPositionsUvs;\nfunction quadIndices() {\n    return new Uint16Array([0, 1, 2, 0, 2, 3]);\n}\nexports.quadIndices = quadIndices;\nfunction cubeInterleavedPositionsUvs() {\n    return new Float32Array([\n        -1.0, -1.0, 1.0, 0, 0,\n        1.0, -1.0, 1.0, 1, 0,\n        1.0, 1.0, 1.0, 1, 1,\n        -1.0, 1.0, 1.0, 0, 1,\n        -1.0, -1.0, -1.0, 0, 0,\n        -1.0, 1.0, -1.0, 0, 1,\n        1.0, 1.0, -1.0, 1, 1,\n        1.0, -1.0, -1.0, 1, 0,\n        -1.0, 1.0, -1.0, 0, 0,\n        -1.0, 1.0, 1.0, 1, 0,\n        1.0, 1.0, 1.0, 1, 1,\n        1.0, 1.0, -1.0, 0, 1,\n        -1.0, -1.0, -1.0, 0, 0,\n        1.0, -1.0, -1.0, 1, 0,\n        1.0, -1.0, 1.0, 1, 1,\n        -1.0, -1.0, 1.0, 0, 1,\n        1.0, -1.0, -1.0, 0, 0,\n        1.0, 1.0, -1.0, 1, 0,\n        1.0, 1.0, 1.0, 1, 1,\n        1.0, -1.0, 1.0, 0, 1,\n        -1.0, -1.0, -1.0, 0, 0,\n        -1.0, -1.0, 1.0, 1, 0,\n        -1.0, 1.0, 1.0, 1, 1,\n        -1.0, 1.0, -1.0, 0, 1,\n    ]);\n}\nexports.cubeInterleavedPositionsUvs = cubeInterleavedPositionsUvs;\nfunction cubeInterleavedPositionsNormals() {\n    return new Float32Array([\n        -1.0, -1.0, 1.0, 0, 0, 1,\n        1.0, -1.0, 1.0, 0, 0, 1,\n        1.0, 1.0, 1.0, 0, 0, 1,\n        -1.0, 1.0, 1.0, 0, 0, 1,\n        -1.0, -1.0, -1.0, 0, 0, -1,\n        -1.0, 1.0, -1.0, 0, 0, -1,\n        1.0, 1.0, -1.0, 0, 0, -1,\n        1.0, -1.0, -1.0, 0, 0, -1,\n        -1.0, 1.0, -1.0, 0, 1, 0,\n        -1.0, 1.0, 1.0, 0, 1, 0,\n        1.0, 1.0, 1.0, 0, 1, 0,\n        1.0, 1.0, -1.0, 0, 1, 0,\n        -1.0, -1.0, -1.0, 0, -1, 0,\n        1.0, -1.0, -1.0, 0, -1, 0,\n        1.0, -1.0, 1.0, 0, -1, 0,\n        -1.0, -1.0, 1.0, 0, -1, 0,\n        1.0, -1.0, -1.0, 1, 0, 0,\n        1.0, 1.0, -1.0, 1, 0, 0,\n        1.0, 1.0, 1.0, 1, 0, 0,\n        1.0, -1.0, 1.0, 1, 0, 0,\n        -1.0, -1.0, -1.0, -1, 0, 0,\n        -1.0, -1.0, 1.0, -1, 0, 0,\n        -1.0, 1.0, 1.0, -1, 0, 0,\n        -1.0, 1.0, -1.0, -1, 0, 0,\n    ]);\n}\nexports.cubeInterleavedPositionsNormals = cubeInterleavedPositionsNormals;\nfunction cubeIndices() {\n    return new Uint16Array([\n        0, 1, 2, 0, 2, 3,\n        4, 5, 6, 4, 6, 7,\n        8, 9, 10, 8, 10, 11,\n        12, 13, 14, 12, 14, 15,\n        16, 17, 18, 16, 18, 19,\n        20, 21, 22, 20, 22, 23,\n    ]);\n}\nexports.cubeIndices = cubeIndices;\nfunction sphereInterleavedDataAndIndices(vertexCount) {\n    if (vertexCount === void 0) { vertexCount = 64; }\n    var vertexData = [];\n    for (var i = 0; i < vertexCount; i++) {\n        for (var j = 0; j < vertexCount; j++) {\n            var xSegment = j / (vertexCount - 1);\n            var ySegment = i / (vertexCount - 1);\n            var xPos = Math.cos(xSegment * 2 * Math.PI) * Math.sin(ySegment * Math.PI);\n            var yPos = Math.cos(ySegment * Math.PI);\n            var zPos = Math.sin(xSegment * 2 * Math.PI) * Math.sin(ySegment * Math.PI);\n            vertexData.push(xPos);\n            vertexData.push(yPos);\n            vertexData.push(zPos);\n            vertexData.push(xSegment);\n            vertexData.push(ySegment);\n            vertexData.push(xPos);\n            vertexData.push(yPos);\n            vertexData.push(zPos);\n        }\n    }\n    var firstIndex = 0;\n    var nextIndex = vertexCount;\n    var indexStp = 0;\n    var shouldProceed = true;\n    var indices = [];\n    while (shouldProceed) {\n        indices.push(firstIndex);\n        indices.push(nextIndex);\n        indexStp += 2;\n        shouldProceed = nextIndex != (vertexCount * vertexCount) - 1;\n        if (indexStp > 0 && (nextIndex + 1) % vertexCount == 0 && shouldProceed) {\n            indices.push(nextIndex);\n            indices.push(firstIndex + 1);\n            indexStp += 2;\n        }\n        firstIndex++;\n        nextIndex++;\n    }\n    return {\n        vertexData: new Float32Array(vertexData),\n        indices: new Uint16Array(indices)\n    };\n}\nexports.sphereInterleavedDataAndIndices = sphereInterleavedDataAndIndices;\nfunction triangleStripQuadPositions(vertexCount) {\n    if (vertexCount === void 0) { vertexCount = 64; }\n    var vertexData = new Float32Array(vertexCount * vertexCount * 3);\n    var index = 0;\n    for (var i = 0; i < vertexCount; i++) {\n        for (var j = 0; j < vertexCount; j++) {\n            var xSegment = j / (vertexCount - 1);\n            var ZSegment = i / (vertexCount - 1);\n            vertexData[index++] = xSegment;\n            vertexData[index++] = 0;\n            vertexData[index++] = ZSegment;\n        }\n    }\n    var firstIndex = 0;\n    var nextIndex = vertexCount;\n    var indexStp = 0;\n    var shouldProceed = true;\n    var indices = [];\n    while (shouldProceed) {\n        indices.push(firstIndex);\n        indices.push(nextIndex);\n        indexStp += 2;\n        shouldProceed = nextIndex != (vertexCount * vertexCount) - 1;\n        if (indexStp > 0 && (nextIndex + 1) % vertexCount == 0 && shouldProceed) {\n            indices.push(nextIndex);\n            indices.push(firstIndex + 1);\n            indexStp += 2;\n        }\n        firstIndex++;\n        nextIndex++;\n    }\n    return {\n        vertexData: vertexData,\n        indices: new Uint16Array(indices)\n    };\n}\nexports.triangleStripQuadPositions = triangleStripQuadPositions;\n\n\n//# sourceURL=webpack:///./build/src/gl/geometry.js?");

/***/ }),

/***/ "./build/src/gl/index.js":
/*!*******************************!*\
  !*** ./build/src/gl/index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nexports.__esModule = true;\nvar types = __webpack_require__(/*! ./types */ \"./build/src/gl/types.js\");\nexports.types = types;\nvar intersect = __webpack_require__(/*! ./intersections */ \"./build/src/gl/intersections.js\");\nexports.intersect = intersect;\nvar collision = __webpack_require__(/*! ./collision */ \"./build/src/gl/collision.js\");\nexports.collision = collision;\nvar math = __webpack_require__(/*! ./math */ \"./build/src/gl/math.js\");\nexports.math = math;\nvar debug = __webpack_require__(/*! ./debug */ \"./build/src/gl/debug/index.js\");\nexports.debug = debug;\nvar parse = __webpack_require__(/*! ./parsers */ \"./build/src/gl/parsers/index.js\");\nexports.parse = parse;\nvar terrain = __webpack_require__(/*! ./terrain */ \"./build/src/gl/terrain.js\");\nexports.terrain = terrain;\nvar geometry = __webpack_require__(/*! ./geometry */ \"./build/src/gl/geometry.js\");\nexports.geometry = geometry;\nvar shaderBuilder = __webpack_require__(/*! ./shader-builder */ \"./build/src/gl/shader-builder/index.js\");\nexports.shaderBuilder = shaderBuilder;\nvar factory = __webpack_require__(/*! ./factory */ \"./build/src/gl/factory/index.js\");\nexports.factory = factory;\nvar mouse_picker_1 = __webpack_require__(/*! ./mouse-picker */ \"./build/src/gl/mouse-picker.js\");\nexports.MousePicker = mouse_picker_1.MousePicker;\nvar keyboard_1 = __webpack_require__(/*! ./keyboard */ \"./build/src/gl/keyboard.js\");\nexports.Keyboard = keyboard_1.Keyboard;\nexports.Keys = keyboard_1.Keys;\n__export(__webpack_require__(/*! ./voxel-grid */ \"./build/src/gl/voxel-grid.js\"));\n__export(__webpack_require__(/*! ./shader */ \"./build/src/gl/shader.js\"));\n__export(__webpack_require__(/*! ./program */ \"./build/src/gl/program.js\"));\n__export(__webpack_require__(/*! ./follow-camera */ \"./build/src/gl/follow-camera.js\"));\n__export(__webpack_require__(/*! ./lights */ \"./build/src/gl/lights.js\"));\n__export(__webpack_require__(/*! ./material */ \"./build/src/gl/material.js\"));\n__export(__webpack_require__(/*! ./model */ \"./build/src/gl/model.js\"));\n__export(__webpack_require__(/*! ./vao */ \"./build/src/gl/vao.js\"));\n__export(__webpack_require__(/*! ./texture */ \"./build/src/gl/texture.js\"));\n__export(__webpack_require__(/*! ./render-context */ \"./build/src/gl/render-context.js\"));\n__export(__webpack_require__(/*! ./renderer */ \"./build/src/gl/renderer.js\"));\n__export(__webpack_require__(/*! ./scene */ \"./build/src/gl/scene.js\"));\n\n\n//# sourceURL=webpack:///./build/src/gl/index.js?");

/***/ }),

/***/ "./build/src/gl/intersections.js":
/*!***************************************!*\
  !*** ./build/src/gl/intersections.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nfunction makeRayPlaneIntersection(intersects, t, intersectionPoint) {\n    return { intersects: intersects, t: t, intersectionPoint: intersectionPoint };\n}\nfunction makeRayAabbIntersection(intersects, tMin, tMax) {\n    return { intersects: intersects, tMin: tMin, tMax: tMax };\n}\nfunction rayIntersectsAabb(ray, aabb) {\n    var rayOrigin = ray.origin;\n    var rayDir = ray.direction;\n    var t0x = (aabb.minX - rayOrigin[0]) / rayDir[0];\n    var t0y = (aabb.minY - rayOrigin[1]) / rayDir[1];\n    var t0z = (aabb.minZ - rayOrigin[2]) / rayDir[2];\n    var t1x = (aabb.maxX - rayOrigin[0]) / rayDir[0];\n    var t1y = (aabb.maxY - rayOrigin[1]) / rayDir[1];\n    var t1z = (aabb.maxZ - rayOrigin[2]) / rayDir[2];\n    var tmp = 0;\n    if (t1x < t0x) {\n        tmp = t1x;\n        t1x = t0x;\n        t0x = tmp;\n    }\n    if (t1y < t0y) {\n        tmp = t1y;\n        t1y = t0y;\n        t0y = tmp;\n    }\n    if (t1z < t0z) {\n        tmp = t1z;\n        t1z = t0z;\n        t0z = tmp;\n    }\n    if (t0x > t1y || t0y > t1x) {\n        return makeRayAabbIntersection(false, null, null);\n    }\n    var tMin = t0x;\n    if (t0y > tMin)\n        tMin = t0y;\n    var tMax = t1x;\n    if (t1y < tMax)\n        tMax = t1y;\n    if (t0z > tMax || t1z < tMin) {\n        return makeRayAabbIntersection(false, null, null);\n    }\n    if (t0z > tMin)\n        tMin = t0z;\n    if (t1z < tMax)\n        tMax = t1z;\n    return makeRayAabbIntersection(true, tMin, tMax);\n}\nexports.rayIntersectsAabb = rayIntersectsAabb;\nfunction rayIntersectsPlane(outPoint, rayOrigin, rayDir, planeNormal, planeOrigin) {\n    var denom = gl_matrix_1.vec3.dot(rayDir, planeNormal);\n    if (denom === 0) {\n        return makeRayPlaneIntersection(false, null, null);\n    }\n    gl_matrix_1.vec3.sub(outPoint, planeOrigin, rayOrigin);\n    var num = gl_matrix_1.vec3.dot(outPoint, planeNormal);\n    var t = num / denom;\n    if (t < 0) {\n        return makeRayPlaneIntersection(false, t, null);\n    }\n    gl_matrix_1.vec3.scale(outPoint, rayDir, t);\n    gl_matrix_1.vec3.add(outPoint, rayOrigin, outPoint);\n    return makeRayPlaneIntersection(true, t, outPoint);\n}\nexports.rayIntersectsPlane = rayIntersectsPlane;\n\n\n//# sourceURL=webpack:///./build/src/gl/intersections.js?");

/***/ }),

/***/ "./build/src/gl/keyboard.js":
/*!**********************************!*\
  !*** ./build/src/gl/keyboard.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar uuid = __webpack_require__(/*! uuid/v4 */ \"./node_modules/uuid/v4.js\");\nexports.Keys = {\n    w: 87,\n    a: 65,\n    s: 83,\n    d: 68,\n    c: 67,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    n: 78,\n    o: 79,\n    q: 81,\n    r: 82,\n    t: 84,\n    u: 85,\n    v: 86,\n    y: 89,\n    z: 90,\n    space: 32,\n    leftShift: 16,\n    left: 37,\n    right: 39,\n    up: 38,\n    down: 40\n};\nvar Keyboard = /** @class */ (function () {\n    function Keyboard() {\n        this.keyState = {};\n        this.keyPressListeners = {};\n        this.keyReleaseListeners = {};\n        this.configureListeners();\n    }\n    Keyboard.prototype.isDown = function (key) {\n        return this.keyState[key] === true;\n    };\n    Keyboard.prototype.markDown = function (key) {\n        this.keyState[key] = true;\n    };\n    Keyboard.prototype.markUp = function (key) {\n        this.keyState[key] = false;\n    };\n    Keyboard.prototype.addAnonymousListener = function (forKey, cb) {\n        this.addListener(forKey, uuid(), cb);\n    };\n    Keyboard.prototype.addAnonymousReleaseListener = function (forKey, cb) {\n        this.addReleaseListener(forKey, uuid(), cb);\n    };\n    Keyboard.prototype.addListener = function (forKey, name, cb) {\n        var listeners = this.getPressListenersMap(forKey);\n        listeners[name] = cb;\n    };\n    Keyboard.prototype.addReleaseListener = function (forKey, name, cb) {\n        var listeners = this.getReleaseListenersMap(forKey);\n        listeners[name] = cb;\n    };\n    Keyboard.prototype.triggerKeyPressListeners = function (forKey) {\n        this.triggerListeners(this.keyPressListeners, forKey);\n    };\n    Keyboard.prototype.triggerKeyReleaseListeners = function (forKey) {\n        this.triggerListeners(this.keyReleaseListeners, forKey);\n    };\n    Keyboard.prototype.triggerListeners = function (kind, forKey) {\n        var listeners = kind[forKey];\n        if (listeners === undefined) {\n            return;\n        }\n        var listenerNames = Object.keys(listeners);\n        for (var i = 0; i < listenerNames.length; i++) {\n            listeners[listenerNames[i]]();\n        }\n    };\n    Keyboard.prototype.getPressListenersMap = function (forKey) {\n        return this.getListenerMap(this.keyPressListeners, forKey);\n    };\n    Keyboard.prototype.getReleaseListenersMap = function (forKey) {\n        return this.getListenerMap(this.keyReleaseListeners, forKey);\n    };\n    Keyboard.prototype.getListenerMap = function (kind, forKey) {\n        var maybeMap = kind[forKey];\n        if (maybeMap === undefined) {\n            kind[forKey] = {};\n            return kind[forKey];\n        }\n        else {\n            return maybeMap;\n        }\n    };\n    Keyboard.prototype.configureListeners = function () {\n        var self = this;\n        window.addEventListener('keydown', function (e) {\n            self.markDown(e.which);\n            self.triggerKeyPressListeners(e.which);\n        });\n        window.addEventListener('keyup', function (e) {\n            self.markUp(e.which);\n            self.triggerKeyReleaseListeners(e.which);\n        });\n    };\n    return Keyboard;\n}());\nexports.Keyboard = Keyboard;\n\n\n//# sourceURL=webpack:///./build/src/gl/keyboard.js?");

/***/ }),

/***/ "./build/src/gl/lights.js":
/*!********************************!*\
  !*** ./build/src/gl/lights.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar types = __webpack_require__(/*! ./types */ \"./build/src/gl/types.js\");\nvar Light = /** @class */ (function () {\n    function Light(kind, uniforms) {\n        this.uniforms = uniforms;\n        this.activeUniforms = this.getActiveUniforms();\n        this.index = 0;\n        this.kind = kind;\n    }\n    Light.prototype.getActiveUniforms = function () {\n        var keys = Object.keys(this.uniforms);\n        var out = [];\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (this.uniforms.hasOwnProperty(key) && this.uniforms[key] !== undefined) {\n                out.push(key);\n            }\n        }\n        return out;\n    };\n    Light.prototype.setUniforms = function (inProg) {\n        for (var i = 0; i < this.activeUniforms.length; i++) {\n            var activeUniform = this.uniforms[this.activeUniforms[i]];\n            inProg.setArrayUniform(activeUniform, this.index);\n        }\n    };\n    Light.prototype.setUniformProperty = function (name, to) {\n        var uniform = this.uniforms[name];\n        if (uniform === undefined) {\n            console.warn(\"No such light property: \\\"\" + name + \"\\\".\");\n            return;\n        }\n        uniform.set(to);\n    };\n    Light.requireIdentifiers = function (identifiers) {\n        if (identifiers === undefined) {\n            return types.DefaultShaderIdentifiers;\n        }\n        else {\n            return identifiers;\n        }\n    };\n    Light.Point = function (identifiers) {\n        identifiers = Light.requireIdentifiers(identifiers);\n        return new Light(1 /* Point */, {\n            position: types.makeUniformFloat3Value(identifiers.uniforms.pointLightPositions, [0, 0, 0]).disallowNewType(),\n            color: types.makeUniformFloat3Value(identifiers.uniforms.pointLightColors, [1, 1, 1]).disallowNewType()\n        });\n    };\n    Light.Directional = function (identifiers) {\n        identifiers = Light.requireIdentifiers(identifiers);\n        return new Light(0 /* Directional */, {\n            position: types.makeUniformFloat3Value(identifiers.uniforms.directionalLightPositions, [0, 0, 0]).disallowNewType(),\n            color: types.makeUniformFloat3Value(identifiers.uniforms.directionalLightColors, [1, 1, 1]).disallowNewType()\n        });\n    };\n    return Light;\n}());\nexports.Light = Light;\n\n\n//# sourceURL=webpack:///./build/src/gl/lights.js?");

/***/ }),

/***/ "./build/src/gl/material.js":
/*!**********************************!*\
  !*** ./build/src/gl/material.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar _1 = __webpack_require__(/*! . */ \"./build/src/gl/index.js\");\nvar texture_1 = __webpack_require__(/*! ./texture */ \"./build/src/gl/texture.js\");\nvar Material = /** @class */ (function () {\n    function Material(descriptor) {\n        this.id = Material.ID++;\n        this.descriptor = descriptor;\n        this.activeUniforms = this.getActiveUniforms();\n        this.schemaDidChange = true;\n        this.textureSet = new texture_1.Texture2DSet();\n        this.initializeTextureSet();\n    }\n    Material.prototype.getActiveUniforms = function () {\n        var uniforms = this.descriptor.uniforms;\n        var props = Object.keys(uniforms);\n        var activeUniforms = [];\n        for (var i = 0; i < props.length; i++) {\n            if (uniforms.hasOwnProperty(props[i]) && uniforms[props[i]] !== undefined) {\n                activeUniforms.push(props[i]);\n            }\n        }\n        return activeUniforms;\n    };\n    Material.prototype.addTexture = function (tex) {\n        this.textureSet.addTexture(tex);\n    };\n    Material.prototype.removeTexture = function (tex) {\n        this.textureSet.removeTexture(tex);\n    };\n    Material.prototype.initializeTextureSet = function () {\n        var self = this;\n        this.useActiveUniforms(function (uniform, kind) {\n            if (uniform.isTexture()) {\n                self.addTexture(uniform.value);\n            }\n        });\n    };\n    Material.prototype.hasUniform = function (name) {\n        return this.descriptor.uniforms[name] !== undefined;\n    };\n    Material.prototype.makeVariableForUniform = function (name) {\n        if (this.hasUniform(name)) {\n            var uniform = this.descriptor.uniforms[name];\n            return _1.types.makeGLSLVariable(uniform.identifier, uniform.type);\n        }\n        else {\n            return null;\n        }\n    };\n    Material.prototype.useActiveUniforms = function (cb) {\n        var uniforms = this.descriptor.uniforms;\n        for (var i = 0; i < this.activeUniforms.length; i++) {\n            var kind = this.activeUniforms[i];\n            cb(uniforms[kind], kind);\n        }\n    };\n    Material.prototype.setUniforms = function (inProgram) {\n        var uniforms = this.descriptor.uniforms;\n        for (var i = 0; i < this.activeUniforms.length; i++) {\n            var activeUniform = uniforms[this.activeUniforms[i]];\n            inProgram.setUniform(activeUniform);\n        }\n    };\n    Material.prototype.useTextures = function (cb) {\n        this.textureSet.useTextures(cb);\n    };\n    Material.prototype.hasTextureUniform = function () {\n        return this.textureSet.size() > 0;\n    };\n    Material.prototype.removeUnusedUniforms = function (inProg) {\n        for (var i = 0; i < this.activeUniforms.length; i++) {\n            var kind = this.activeUniforms[i];\n            var uniform = this.descriptor.uniforms[kind];\n            var identifier = uniform.identifier;\n            if (!inProg.isUniform(identifier)) {\n                this.activeUniforms.splice(i, 1);\n                if (uniform.isTexture()) {\n                    this.removeTexture(uniform.value);\n                }\n            }\n        }\n    };\n    Material.prototype.addUniformProperty = function (name, value) {\n        var hadUniform = this.hasUniform(name);\n        this.descriptor.uniforms[name] = value;\n        if (!hadUniform) {\n            this.activeUniforms.push(name);\n        }\n        if (value.isTexture()) {\n            this.addTexture(value.value);\n        }\n    };\n    Material.prototype.setUniformProperty = function (name, value, numChannels) {\n        var uniforms = this.descriptor.uniforms;\n        if (!this.hasUniform(name)) {\n            console.warn(\"No such material property: \\\"\" + name + \"\\\".\");\n            return;\n        }\n        var uniform = uniforms[name];\n        var prevType = uniform.type;\n        var prevValue = uniform.value;\n        uniform.set(value, numChannels);\n        var isNewType = uniform.isNewType();\n        if (uniform.isTexture()) {\n            this.addTexture(uniform.value);\n        }\n        else if (isNewType && prevType === 'sampler2D') {\n            this.removeTexture(prevValue);\n        }\n        this.schemaDidChange = isNewType;\n    };\n    Material.prototype.isNewSchema = function () {\n        return this.schemaDidChange;\n    };\n    Material.prototype.clearIsNewSchema = function () {\n        this.schemaDidChange = false;\n        for (var i = 0; i < this.activeUniforms.length; i++) {\n            this.descriptor.uniforms[this.activeUniforms[i]].clearIsNewType();\n        }\n    };\n    Material.requireIdentifiers = function (identifiers) {\n        if (identifiers === undefined) {\n            return _1.types.DefaultShaderIdentifiers;\n        }\n        else {\n            return identifiers;\n        }\n    };\n    Material.Empty = function (identifiers) {\n        identifiers = Material.requireIdentifiers(identifiers);\n        return new Material({\n            receivesShadow: false,\n            castsShadow: false,\n            lightingModel: 2 /* None */,\n            uniforms: {}\n        });\n    };\n    Material.Phong = function (identifiers) {\n        identifiers = Material.requireIdentifiers(identifiers);\n        return new Material({\n            receivesShadow: true,\n            castsShadow: true,\n            lightingModel: 0 /* Phong */,\n            uniforms: {\n                ambientConstant: _1.types.makeUniformFloatValue(identifiers.uniforms.ambientConstant, 0.25),\n                diffuseConstant: _1.types.makeUniformFloatValue(identifiers.uniforms.diffuseConstant, 0.25),\n                specularConstant: _1.types.makeUniformFloatValue(identifiers.uniforms.specularConstant, 0.25),\n                specularPower: _1.types.makeUniformFloatValue(identifiers.uniforms.specularPower, 16.0),\n                modelColor: _1.types.makeUniformFloat3Value(identifiers.uniforms.modelColor, [1, 1, 1])\n            }\n        });\n    };\n    Material.NoLight = function (identifiers) {\n        identifiers = Material.requireIdentifiers(identifiers);\n        return new Material({\n            receivesShadow: true,\n            castsShadow: true,\n            lightingModel: 2 /* None */,\n            uniforms: {\n                modelColor: _1.types.makeUniformFloat3Value(identifiers.uniforms.modelColor, [1, 1, 1])\n            }\n        });\n    };\n    Material.Physical = function (identifiers) {\n        identifiers = Material.requireIdentifiers(identifiers);\n        return new Material({\n            receivesShadow: true,\n            castsShadow: true,\n            lightingModel: 1 /* Physical */,\n            uniforms: {\n                ambientConstant: _1.types.makeUniformFloatValue(identifiers.uniforms.ambientConstant, 0.2),\n                roughness: _1.types.makeUniformFloatValue(identifiers.uniforms.roughness, 0.5),\n                metallic: _1.types.makeUniformFloatValue(identifiers.uniforms.metallic, 0.5),\n                modelColor: _1.types.makeUniformFloat3Value(identifiers.uniforms.modelColor, [1, 1, 1])\n            }\n        });\n    };\n    Material.ID = 0;\n    return Material;\n}());\nexports.Material = Material;\n\n\n//# sourceURL=webpack:///./build/src/gl/material.js?");

/***/ }),

/***/ "./build/src/gl/math.js":
/*!******************************!*\
  !*** ./build/src/gl/math.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nexports.EPSILON = 0.000001;\nfunction isPow2(num) {\n    //  https://www.geeksforgeeks.org/program-to-find-whether-a-no-is-power-of-two/\n    return (num % 1 === 0) && num > 0 && (!(num & (num - 1)));\n}\nexports.isPow2 = isPow2;\nfunction distance3(x0, y0, z0, x1, y1, z1) {\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dz = z1 - z0;\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\nexports.distance3 = distance3;\nfunction clamp(v, minBound, maxBound) {\n    if (v < minBound) {\n        return minBound;\n    }\n    else if (v > maxBound) {\n        return maxBound;\n    }\n    else {\n        return v;\n    }\n}\nexports.clamp = clamp;\nfunction goldenRatio() {\n    return (1 + Math.sqrt(5)) / 2;\n}\nexports.goldenRatio = goldenRatio;\nfunction clamp01(v) {\n    return clamp(v, 0, 1);\n}\nexports.clamp01 = clamp01;\nfunction sub3(out, a, b) {\n    for (var i = 0; i < 3; i++) {\n        out[i] = a[i] - b[i];\n    }\n}\nexports.sub3 = sub3;\nfunction add3(out, a, b) {\n    for (var i = 0; i < 3; i++) {\n        out[i] = a[i] + b[i];\n    }\n}\nexports.add3 = add3;\nfunction norm3(out, a) {\n    var len = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n    if (len !== 0) {\n        out[0] = a[0] / len;\n        out[1] = a[1] / len;\n        out[2] = a[2] / len;\n    }\n    else {\n        out[0] = 0;\n        out[1] = 0;\n        out[2] = 0;\n    }\n}\nexports.norm3 = norm3;\nfunction scale3(out, a, by) {\n    for (var i = 0; i < 3; i++) {\n        out[i] = a[i] * by;\n    }\n}\nexports.scale3 = scale3;\nfunction arrayMin(arr) {\n    var min = Infinity;\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n    }\n    return min;\n}\nexports.arrayMin = arrayMin;\nfunction arrayMax(arr) {\n    var max = -Infinity;\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\nexports.arrayMax = arrayMax;\nfunction arrayScale(out, a, by) {\n    var len = Math.min(out.length, a.length);\n    for (var i = 0; i < len; i++) {\n        out[i] = a[i] * by;\n    }\n}\nexports.arrayScale = arrayScale;\nfunction dtSecRatio(dt) {\n    return dt / (1 / 60);\n}\nexports.dtSecRatio = dtSecRatio;\nfunction dtSecSampleIncrement(dt) {\n    return Math.max(Math.ceil((dt / (1 / 60))), 1);\n}\nexports.dtSecSampleIncrement = dtSecSampleIncrement;\nfunction dtSecScale(dt, value) {\n    return (dt / (1 / 60)) * value;\n}\nexports.dtSecScale = dtSecScale;\nfunction dtSecScaleInv(dt, value) {\n    return (1 / (dt / (1 / 60))) * value;\n}\nexports.dtSecScaleInv = dtSecScaleInv;\nfunction normalize01(out, a) {\n    var minValue = arrayMin(a);\n    var maxValue = arrayMax(a);\n    var len = Math.min(out.length, a.length);\n    var minMaxRange = maxValue - minValue;\n    for (var i = 0; i < len; i++) {\n        out[i] = (a[i] - minValue) / minMaxRange;\n    }\n}\nexports.normalize01 = normalize01;\nvar Ray = /** @class */ (function () {\n    function Ray() {\n        this.origin = gl_matrix_1.vec3.create();\n        this.direction = gl_matrix_1.vec3.create();\n    }\n    Ray.prototype.pointAt = function (out, t) {\n        gl_matrix_1.vec3.copy(out, this.direction);\n        gl_matrix_1.vec3.scale(out, out, t);\n        gl_matrix_1.vec3.add(out, this.origin, out);\n        return out;\n    };\n    Ray.prototype.set = function (origin, direction) {\n        for (var i = 0; i < 3; i++) {\n            this.origin[i] = origin[i];\n            this.direction[i] = direction[i];\n        }\n        return this;\n    };\n    Ray.fromOriginDirection = function (origin, direction) {\n        var ray = new Ray();\n        ray.set(origin, direction);\n        return ray;\n    };\n    return Ray;\n}());\nexports.Ray = Ray;\nvar Aabb = /** @class */ (function () {\n    function Aabb() {\n        this.minX = NaN;\n        this.maxX = NaN;\n        this.minY = NaN;\n        this.maxY = NaN;\n        this.minZ = NaN;\n        this.maxZ = NaN;\n    }\n    Aabb.prototype.toString = function () {\n        return \"x0:\" + this.minX + \", x1:\" + this.maxX + \", y0:\" + this.minY + \", y1:\" + this.maxY + \", z0:\" + this.minZ + \", z1:\" + this.maxZ;\n    };\n    Aabb.prototype.width = function () {\n        return this.maxX - this.minX;\n    };\n    Aabb.prototype.height = function () {\n        return this.maxY - this.minY;\n    };\n    Aabb.prototype.depth = function () {\n        return this.maxZ - this.minZ;\n    };\n    Aabb.prototype.midX = function () {\n        return this.minX + this.width() / 2;\n    };\n    Aabb.prototype.midY = function () {\n        return this.minY + this.height() / 2;\n    };\n    Aabb.prototype.midZ = function () {\n        return this.minZ + this.depth() / 2;\n    };\n    Aabb.prototype.move = function (by) {\n        this.move3(by[0], by[1], by[2]);\n    };\n    Aabb.prototype.move3 = function (byX, byY, byZ) {\n        this.minX += byX;\n        this.maxX += byX;\n        this.minY += byY;\n        this.maxY += byY;\n        this.minZ += byZ;\n        this.maxZ += byZ;\n    };\n    Aabb.prototype.moveTo = function (pos) {\n        this.moveTo3(pos[0], pos[1], pos[2]);\n    };\n    Aabb.prototype.moveTo3 = function (x, y, z) {\n        var w = this.width();\n        var h = this.height();\n        var d = this.depth();\n        this.minX = x;\n        this.minY = y;\n        this.minZ = z;\n        this.maxX = x + w;\n        this.maxY = y + h;\n        this.maxZ = z + d;\n    };\n    Aabb.prototype.moveToY = function (y) {\n        var h = this.height();\n        this.minY = y;\n        this.maxY = y + h;\n    };\n    Aabb.prototype.assign = function (aabb) {\n        this.minX = aabb.minX;\n        this.maxX = aabb.maxX;\n        this.minY = aabb.minY;\n        this.maxY = aabb.maxY;\n        this.minZ = aabb.minZ;\n        this.maxZ = aabb.maxZ;\n    };\n    Aabb.copy = function (out, a) {\n        out.assign(a);\n        return out;\n    };\n    Aabb.fromValues = function (minX, maxX, minY, maxY, minZ, maxZ) {\n        var aabb = new Aabb();\n        aabb.minX = minX;\n        aabb.maxX = maxX;\n        aabb.minY = minY;\n        aabb.maxY = maxY;\n        aabb.minZ = minZ;\n        aabb.maxZ = maxZ;\n        return aabb;\n    };\n    Aabb.fromOriginDimensions = function (origin, dims) {\n        var aabb = new Aabb();\n        aabb.minX = origin[0];\n        aabb.maxX = origin[0] + dims[0];\n        aabb.minY = origin[1];\n        aabb.maxY = origin[1] + dims[1];\n        aabb.minZ = origin[2];\n        aabb.maxZ = origin[2] + dims[2];\n        return aabb;\n    };\n    return Aabb;\n}());\nexports.Aabb = Aabb;\n\n\n//# sourceURL=webpack:///./build/src/gl/math.js?");

/***/ }),

/***/ "./build/src/gl/model.js":
/*!*******************************!*\
  !*** ./build/src/gl/model.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar transform_1 = __webpack_require__(/*! ./transform */ \"./build/src/gl/transform.js\");\nvar Model = /** @class */ (function () {\n    function Model(drawable, material) {\n        this.drawable = drawable;\n        this.material = material;\n        this.transform = new transform_1.Transform();\n    }\n    return Model;\n}());\nexports.Model = Model;\n\n\n//# sourceURL=webpack:///./build/src/gl/model.js?");

/***/ }),

/***/ "./build/src/gl/mouse-picker.js":
/*!**************************************!*\
  !*** ./build/src/gl/mouse-picker.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nvar MousePicker = /** @class */ (function () {\n    function MousePicker() {\n        this.invProj = gl_matrix_1.mat4.create();\n        this.invView = gl_matrix_1.mat4.create();\n        this.tmpVec4 = gl_matrix_1.vec4.create();\n    }\n    MousePicker.prototype.ray = function (out, x, y, view, projection, clientWidth, clientHeight) {\n        var invProj = this.invProj;\n        var invView = this.invView;\n        var coords = this.tmpVec4;\n        gl_matrix_1.mat4.invert(invView, view);\n        gl_matrix_1.mat4.invert(invProj, projection);\n        x = -1 + (x / clientWidth) * 2;\n        y = 1 - (y / clientHeight) * 2;\n        coords[0] = x;\n        coords[1] = y;\n        coords[2] = -1;\n        coords[3] = 1;\n        gl_matrix_1.vec4.transformMat4(coords, coords, invProj);\n        coords[2] = -1;\n        coords[3] = 0;\n        gl_matrix_1.vec4.transformMat4(coords, coords, invView);\n        for (var i = 0; i < 3; i++) {\n            out[i] = coords[i];\n        }\n        gl_matrix_1.vec3.normalize(out, out);\n    };\n    return MousePicker;\n}());\nexports.MousePicker = MousePicker;\n\n\n//# sourceURL=webpack:///./build/src/gl/mouse-picker.js?");

/***/ }),

/***/ "./build/src/gl/parsers/index.js":
/*!***************************************!*\
  !*** ./build/src/gl/parsers/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nexports.__esModule = true;\n__export(__webpack_require__(/*! ./obj */ \"./build/src/gl/parsers/obj.js\"));\n\n\n//# sourceURL=webpack:///./build/src/gl/parsers/index.js?");

/***/ }),

/***/ "./build/src/gl/parsers/obj.js":
/*!*************************************!*\
  !*** ./build/src/gl/parsers/obj.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar Obj = /** @class */ (function () {\n    function Obj(source) {\n        this.NUM_VERTICES_PER_FACE = 3;\n        this.positionSize = NaN;\n        this.normalSize = NaN;\n        this.texCoordSize = NaN;\n        this.source = source;\n        this.currentGroups = [];\n        this.numCurrentGroups = 0;\n        this.currentSmoothGroup = '';\n        this.end = source.length;\n        this.tmpVertexData = [NaN, NaN, NaN, NaN];\n        this.numTmpVertexComponents = 0;\n        this.currentLine = 0;\n        this.positions = [];\n        this.normals = [];\n        this.texCoords = [];\n        this.positionGroupIndices = [];\n        this.normalGroupIndices = [];\n        this.texCoordGroupIndices = [];\n        this.groups = [];\n        this.positionIndices = [];\n        this.normalIndices = [];\n        this.texCoordIndices = [];\n        this.numFaces = 0;\n        this.parse();\n        this.analyzeParse();\n    }\n    Obj.prototype.parse = function () {\n        var i = 0;\n        while (i < this.end) {\n            var sentinel = this.source[i];\n            switch (sentinel) {\n                case '#':\n                    i = this.consumeComment(i);\n                    break;\n                case 'g':\n                    i = this.group(i);\n                    break;\n                case 'v':\n                    i = this.vertexData(i);\n                    break;\n                case 's':\n                    i = this.smoothGroup(i);\n                    break;\n                case 'f':\n                    i = this.face(i);\n                    break;\n                default:\n                    if (sentinel === '\\n') {\n                        this.nextLine();\n                    }\n                    i = this.consumeToNextLine(i);\n                    break;\n            }\n        }\n    };\n    Obj.prototype.analyzeParse = function () {\n        this.numFaces = this.positionIndices.length / this.NUM_VERTICES_PER_FACE;\n    };\n    Obj.prototype.consumeToNextLine = function (begin) {\n        var i = begin + 1;\n        while (i < this.end && this.source[i] !== '\\n') {\n            i++;\n        }\n        if (i < this.end) {\n            this.nextLine();\n        }\n        return (i + 1);\n    };\n    Obj.prototype.consume = function (begin, expect, after) {\n        if (this.source[begin] !== expect) {\n            throw new Error(\"Expected \\\"\" + expect + \"\\\" after \\\"\" + after + \"\\\"; got \\\"\" + this.source[begin] + \"\\\".\");\n        }\n        else {\n            return begin + 1;\n        }\n    };\n    Obj.prototype.addToCurrentGroup = function (name) {\n        if (this.currentGroups.length === this.numCurrentGroups) {\n            this.currentGroups.push(name);\n        }\n        else {\n            this.currentGroups[this.numCurrentGroups] = name;\n        }\n        this.numCurrentGroups++;\n    };\n    Obj.prototype.clearCurrentGroup = function () {\n        this.numCurrentGroups = 0;\n    };\n    Obj.prototype.finalizeCurrentGroup = function () {\n        this.groups.push(this.currentGroups.slice(0, this.numCurrentGroups));\n    };\n    Obj.prototype.face = function (begin) {\n        var i = this.consume(begin + 1, ' ', 'f (face)');\n        var firstDigit = i;\n        var componentIdx = 0;\n        var numVerticesPerFace = 0;\n        while (i < this.end) {\n            var c = this.source[i];\n            var isSeparator = c === '/' || c === ' ';\n            var isTerminator = c === '\\n' || i === this.end - 1;\n            if (c === '\\n') {\n                this.nextLine();\n            }\n            if (isSeparator || isTerminator) {\n                var numDigits = i - firstDigit;\n                if (numDigits === 0) {\n                    if (componentIdx === 0) {\n                        throw new Error(this.errorString('Position data cannot be empty.'));\n                    }\n                    else if (componentIdx === 1) {\n                        this.texCoordIndices.push(-1);\n                    }\n                    else if (componentIdx === 2) {\n                        this.normalIndices.push(-1);\n                    }\n                    else {\n                        throw new Error(this.errorString(\"Out of range component index: \" + componentIdx + \".\"));\n                    }\n                    componentIdx++;\n                    firstDigit = i + 1;\n                }\n                else {\n                    var substr = this.source.substr(firstDigit, i - firstDigit);\n                    var idx = parseInt(substr);\n                    if (isNaN(idx)) {\n                        throw new Error(this.errorString(\"Non-integer face index for: \\\"\" + substr + \"\\\".\"));\n                    }\n                    var assignedToIndices = null;\n                    var underlyingArray = null;\n                    var componentSize = -1;\n                    var componentName = null;\n                    switch (componentIdx) {\n                        case 0:\n                            componentName = 'position';\n                            assignedToIndices = this.positionIndices;\n                            underlyingArray = this.positions;\n                            componentSize = this.positionSize;\n                            break;\n                        case 1:\n                            componentName = 'texCoords';\n                            assignedToIndices = this.texCoordIndices;\n                            underlyingArray = this.texCoords;\n                            componentSize = this.texCoordSize;\n                            break;\n                        case 2:\n                            componentName = 'normal';\n                            assignedToIndices = this.normalIndices;\n                            underlyingArray = this.normals;\n                            componentSize = this.normalSize;\n                            break;\n                        default:\n                            throw new Error(this.errorString(\"Out of range component index: \" + componentIdx + \".\"));\n                    }\n                    if (isNaN(componentSize)) {\n                        throw new Error(this.errorString(\"Expected defined \" + componentName + \" size before face.\"));\n                    }\n                    // const assignedIdx = (idx-1) * componentSize;\n                    var assignedIdx = (idx - 1);\n                    if (assignedIdx < 0 || assignedIdx * componentSize >= underlyingArray.length) {\n                        throw new Error(this.errorString(\"Out of bounds index \" + assignedIdx + \"; max: \" + underlyingArray.length + \".\"));\n                    }\n                    assignedToIndices.push(assignedIdx);\n                    firstDigit = i + 1;\n                    componentIdx++;\n                }\n            }\n            if (componentIdx > 2) {\n                numVerticesPerFace++;\n                componentIdx = 0;\n            }\n            if (isTerminator) {\n                break;\n            }\n            i++;\n        }\n        if (numVerticesPerFace !== this.NUM_VERTICES_PER_FACE) {\n            throw new Error(this.errorString(\"Expected \" + this.NUM_VERTICES_PER_FACE + \" vertices per face; got \" + numVerticesPerFace + \".\"));\n        }\n        return (i + 1);\n    };\n    Obj.prototype.parseVertexComponents = function (begin, kind, maxNumComponents) {\n        var i = this.consume(begin + 1, ' ', kind);\n        var firstDigit = i;\n        var componentIdx = 0;\n        this.numTmpVertexComponents = 0;\n        while (i < this.end) {\n            var c = this.source[i];\n            if (c === ' ' || c === '\\n' || i === this.end - 1) {\n                if (componentIdx > maxNumComponents) {\n                    var msg = \"Expected at maximum \" + maxNumComponents + \" components following vertex data symbol; got \" + (componentIdx + 1) + \".\";\n                    throw new Error(this.errorString(msg));\n                }\n                var parsedSrc = this.source.substr(firstDigit, i - firstDigit);\n                var parsedNum = parseFloat(parsedSrc);\n                if (isNaN(parsedNum)) {\n                    throw new Error(this.errorString('Failed to parse float in vertex data.'));\n                }\n                this.tmpVertexData[componentIdx++] = parsedNum;\n                this.numTmpVertexComponents++;\n                firstDigit = i + 1;\n                if (c === '\\n') {\n                    this.nextLine();\n                    return (i + 1);\n                }\n            }\n            i++;\n        }\n        return i;\n    };\n    Obj.prototype.addRawVertexData = function (data, groupIndices) {\n        for (var i = 0; i < this.numTmpVertexComponents; i++) {\n            data.push(this.tmpVertexData[i]);\n            groupIndices.push(this.groups.length - 1);\n        }\n    };\n    Obj.prototype.checkConsistentVertexSize = function (current, kind) {\n        var incoming = this.numTmpVertexComponents;\n        if (isNaN(current)) {\n            return;\n        }\n        else if (current !== incoming) {\n            var msg = this.errorString(\"Expected vertex data of type \\\"\" + kind + \"\\\" to have \" + current + \" elements; \" + incoming + \" were present.\");\n            throw new Error(msg);\n        }\n    };\n    Obj.prototype.vertexNormal = function (begin) {\n        var i = this.parseVertexComponents(begin, 'vn (vertex normal)', 3);\n        if (this.numTmpVertexComponents !== 3) {\n            throw new Error('Expected 3 elements following \"vn\" symbol.');\n        }\n        else if (isNaN(this.normalSize)) {\n            this.normalSize = this.numTmpVertexComponents;\n        }\n        this.checkConsistentVertexSize(this.normalSize, 'normals');\n        this.addRawVertexData(this.normals, this.normalGroupIndices);\n        return i;\n    };\n    Obj.prototype.vertexPosition = function (begin) {\n        var i = this.parseVertexComponents(begin, 'v (vertex position)', 3);\n        if (this.numTmpVertexComponents !== 3) {\n            throw new Error('Expected 3 elements following \"v\" symbol.');\n        }\n        else if (isNaN(this.positionSize)) {\n            this.positionSize = this.numTmpVertexComponents;\n        }\n        this.checkConsistentVertexSize(this.positionSize, 'positions');\n        this.addRawVertexData(this.positions, this.positionGroupIndices);\n        return i;\n    };\n    Obj.prototype.vertexTexCoord = function (begin) {\n        var i = this.parseVertexComponents(begin, 'vt (vertex tex coord)', 2);\n        if (this.numTmpVertexComponents < 2) {\n            throw new Error('Expected 2 elements following \"vt\" symbol.');\n        }\n        else if (isNaN(this.texCoordSize)) {\n            this.texCoordSize = this.numTmpVertexComponents;\n        }\n        this.checkConsistentVertexSize(this.texCoordSize, 'tex coords');\n        this.addRawVertexData(this.texCoords, this.texCoordGroupIndices);\n        return i;\n    };\n    Obj.prototype.vertexData = function (begin) {\n        var i = begin + 1;\n        if (i < this.end) {\n            var sentinel = this.source[i];\n            if (sentinel === 'n') {\n                return this.vertexNormal(i);\n            }\n            else if (sentinel === 't') {\n                return this.vertexTexCoord(i);\n            }\n            else if (sentinel === ' ') {\n                return this.vertexPosition(i - 1);\n            }\n            else {\n                throw new Error(this.errorString(\"Unexpected symbol following \\\"v\\\": \\\"\" + sentinel + \"\\\".\"));\n            }\n        }\n        else {\n            throw new Error(this.errorString('Unexpected EOF after symbol \"v\".'));\n        }\n    };\n    Obj.prototype.smoothGroup = function (begin) {\n        var i = begin + 1;\n        while (i < this.end && this.source[i] !== '\\n') {\n            i++;\n        }\n        return (i + 1);\n    };\n    Obj.prototype.group = function (begin) {\n        var i = this.consume(begin + 1, ' ', 'g (group statement)');\n        var lastStart = i;\n        this.clearCurrentGroup();\n        while (i < this.end) {\n            var c = this.source[i];\n            if (c === ' ' || c === '\\n' || i === this.end - 1) {\n                var name_1 = this.source.substr(lastStart, i - lastStart);\n                this.addToCurrentGroup(name_1);\n                lastStart = i + 1;\n                if (c === '\\n') {\n                    this.nextLine();\n                    this.finalizeCurrentGroup();\n                    return (i + 1);\n                }\n            }\n            i++;\n        }\n        this.finalizeCurrentGroup();\n        return i;\n    };\n    Obj.prototype.nextLine = function () {\n        this.currentLine++;\n    };\n    Obj.prototype.consumeComment = function (begin) {\n        var i = begin + 1; //  consume #\n        while (i < this.end && this.source[i] !== '\\n') {\n            i++;\n        }\n        if (i < this.end) {\n            this.nextLine();\n        }\n        return (i + 1);\n    };\n    Obj.prototype.errorString = function (msg) {\n        return \"Line \" + this.currentLine + \": \" + msg;\n    };\n    return Obj;\n}());\nexports.Obj = Obj;\n\n\n//# sourceURL=webpack:///./build/src/gl/parsers/obj.js?");

/***/ }),

/***/ "./build/src/gl/program.js":
/*!*********************************!*\
  !*** ./build/src/gl/program.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar shader_1 = __webpack_require__(/*! ./shader */ \"./build/src/gl/shader.js\");\nvar types = __webpack_require__(/*! ./types */ \"./build/src/gl/types.js\");\nvar _1 = __webpack_require__(/*! . */ \"./build/src/gl/index.js\");\nvar Program = /** @class */ (function () {\n    function Program(gl) {\n        this.program = null;\n        this.gl = gl;\n        this.attributeLocations = {};\n        this.uniformLocations = {};\n        this.id = Program.ID++;\n    }\n    Program.prototype.maybeGetCachedLocation = function (map, kind, name, locGetter, locValidator, forceQuery) {\n        if (this.program === null) {\n            throw new Error(\"Cannot get \" + kind + \" from invalid or unattached program.\");\n        }\n        var potentialLoc = map[name];\n        if (!forceQuery && potentialLoc !== undefined) {\n            return potentialLoc;\n        }\n        else {\n            potentialLoc = locGetter();\n            if (locValidator(potentialLoc)) {\n                map[name] = potentialLoc;\n            }\n            return potentialLoc;\n        }\n    };\n    Program.prototype.use = function () {\n        this.gl.useProgram(this.program);\n    };\n    Program.prototype.getAttributeLocation = function (name, forceQuery) {\n        if (forceQuery === void 0) { forceQuery = false; }\n        var self = this;\n        var locGetter = function () { return self.gl.getAttribLocation(self.program, name); };\n        var locValidator = function (loc) { return loc !== -1; };\n        return this.maybeGetCachedLocation(this.attributeLocations, 'attribute', name, locGetter, locValidator, forceQuery);\n    };\n    Program.prototype.getUniformLocation = function (name, forceQuery) {\n        if (forceQuery === void 0) { forceQuery = false; }\n        var self = this;\n        var locGetter = function () { return self.gl.getUniformLocation(self.program, name); };\n        var locValidator = function (loc) { return loc !== null; };\n        return this.maybeGetCachedLocation(this.uniformLocations, 'uniform', name, locGetter, locValidator, forceQuery);\n    };\n    Program.prototype.setUniformFromComponents = function (identifier, type, value) {\n        switch (type) {\n            case 'float':\n                this.set1f(identifier, value);\n                break;\n            case 'sampler2D': {\n                var tex = value;\n                this.set1i(identifier, tex.index);\n                break;\n            }\n            case 'vec3':\n                this.setVec3(identifier, value);\n                break;\n            case 'mat4':\n                this.setMat4(identifier, value);\n                break;\n            default:\n                console.warn(\"No uniform-setting function for type: \" + type + \".\");\n        }\n    };\n    Program.prototype.isUniform = function (name) {\n        return this.getUniformLocation(name) !== null;\n    };\n    Program.prototype.setUniform = function (uniform) {\n        this.setUniformFromComponents(uniform.identifier, uniform.type, uniform.value);\n    };\n    Program.prototype.setArrayUniform = function (uniform, atIndex) {\n        var identifier = uniform.identifier + \"[\" + atIndex + \"]\";\n        this.setUniformFromComponents(identifier, uniform.type, uniform.value);\n    };\n    Program.prototype.setMat4 = function (name, value) {\n        var loc = this.getUniformLocation(name);\n        if (loc === null) {\n            console.warn(\"Unrecognized uniform \\\"\" + name + \"\\\".\");\n            return;\n        }\n        this.gl.uniformMatrix4fv(loc, false, value);\n    };\n    Program.prototype.set3f = function (name, x, y, z) {\n        var loc = this.getUniformLocation(name);\n        if (loc === null) {\n            console.warn(\"Unrecognized uniform \\\"\" + name + \"\\\".\");\n            return;\n        }\n        this.gl.uniform3f(loc, x, y, z);\n    };\n    Program.prototype.set1f = function (name, x) {\n        var loc = this.getUniformLocation(name);\n        if (loc === null) {\n            console.warn(\"Unrecognized uniform \\\"\" + name + \"\\\".\");\n            return;\n        }\n        this.gl.uniform1f(loc, x);\n    };\n    Program.prototype.set2f = function (name, x, y) {\n        var loc = this.getUniformLocation(name);\n        if (loc === null) {\n            console.warn(\"Unrecognized uniform \\\"\" + name + \"\\\".\");\n            return;\n        }\n        this.gl.uniform2f(loc, x, y);\n    };\n    Program.prototype.set1i = function (name, x) {\n        var loc = this.getUniformLocation(name);\n        if (loc === null) {\n            console.warn(\"Unrecognized uniform \\\"\" + name + \"\\\".\");\n            return;\n        }\n        this.gl.uniform1i(loc, x);\n    };\n    Program.prototype.setTexture = function (name, index) {\n        this.set1i(name, index);\n    };\n    Program.prototype.setVec3 = function (name, value) {\n        this.set3f(name, value[0], value[1], value[2]);\n    };\n    Program.prototype.attachShadersAndFinalize = function (shaders) {\n        if (shaders.length === 0) {\n            throw new Error('Expected 1 or more shader in program; got 0.');\n        }\n        var gl = this.gl;\n        var program = gl.createProgram();\n        for (var i = 0; i < shaders.length; i++) {\n            shaders[i].attachTo(program);\n        }\n        gl.linkProgram(program);\n        for (var i = 0; i < shaders.length; i++) {\n            // shaders[i].detachFrom(program);\n            shaders[i].dispose();\n        }\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            var errInfo = gl.getProgramInfoLog(program);\n            gl.deleteProgram(program);\n            throw new Error('Failed to link shader program: ' + errInfo);\n        }\n        this.program = program;\n    };\n    Program.prototype.dispose = function () {\n        if (this.program !== null) {\n            this.gl.deleteProgram(this.program);\n            this.program = null;\n        }\n    };\n    Program.prototype.isValid = function () {\n        return this.program !== null;\n    };\n    Program.fromSources = function (gl, vertSource, fragSource) {\n        var vertShader = new shader_1.Shader(gl, 0 /* Vertex */, vertSource);\n        var fragShader = new shader_1.Shader(gl, 1 /* Fragment */, fragSource);\n        var prog = new Program(gl);\n        prog.attachShadersAndFinalize([vertShader, fragShader]);\n        return prog;\n    };\n    Program.fromSchemas = function (gl, vertSchema, fragSchema) {\n        var vertSource = _1.shaderBuilder.common.shaderSchemaToString(vertSchema);\n        var fragSource = _1.shaderBuilder.common.shaderSchemaToString(fragSchema);\n        return Program.fromSources(gl, vertSource, fragSource);\n    };\n    Program.ID = 0;\n    return Program;\n}());\nexports.Program = Program;\n\n\n//# sourceURL=webpack:///./build/src/gl/program.js?");

/***/ }),

/***/ "./build/src/gl/render-context.js":
/*!****************************************!*\
  !*** ./build/src/gl/render-context.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar RenderContext = /** @class */ (function () {\n    function RenderContext(gl) {\n        this.gl = gl;\n        this.getExtensions(gl);\n        this.boundVao = null;\n        this.boundVbo = null;\n        this.boundProgram = null;\n        this.boundTexture2D = null;\n        this.numActiveTextures = 0;\n    }\n    RenderContext.prototype.pushActiveTexture2DAndBind = function (tex) {\n        if (!this.isBoundTexture2D(tex)) {\n            tex.index = this.numActiveTextures++;\n            tex.activateAndBind();\n            this.boundTexture2D = tex;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    RenderContext.prototype.popTexture2D = function () {\n        this.numActiveTextures--;\n    };\n    RenderContext.prototype.isBoundTexture2D = function (tex) {\n        return this.boundTexture2D !== null && this.boundTexture2D.id === tex.id;\n    };\n    RenderContext.prototype.bindTexture2D = function (tex) {\n        if (!this.isBoundTexture2D(tex)) {\n            tex.bind();\n            this.boundTexture2D = tex;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    RenderContext.prototype.bindVao = function (vao) {\n        if (this.boundVao === null || this.boundVao.id !== vao.id) {\n            vao.bind();\n            this.boundVao = vao;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    RenderContext.prototype.bindVbo = function (vbo) {\n        if (this.boundVbo === null || this.boundVbo.id !== vbo.id) {\n            vbo.bind(this.gl);\n            this.boundVbo = vbo;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    RenderContext.prototype.useProgram = function (program) {\n        if (this.boundProgram === null || this.boundProgram.id !== program.id) {\n            program.use();\n            this.boundProgram = program;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    RenderContext.prototype.getExtensions = function (gl) {\n        var namesProperties = [\n            { name: 'ANGLE_instanced_arrays', property: 'extInstancedArrays' },\n            { name: 'OES_vertex_array_object', property: 'extOesVao' },\n            { name: 'OES_texture_float', property: 'extOesTextureFloat' }\n        ];\n        var self = this;\n        namesProperties.map(function (nameProp) {\n            var ext = gl.getExtension(nameProp.name);\n            if (!ext) {\n                console.warn(\"Missing extension: \\\"\" + nameProp.name + \"\\\".\");\n            }\n            self[nameProp.property] = ext;\n        });\n    };\n    return RenderContext;\n}());\nexports.RenderContext = RenderContext;\n\n\n//# sourceURL=webpack:///./build/src/gl/render-context.js?");

/***/ }),

/***/ "./build/src/gl/renderer.js":
/*!**********************************!*\
  !*** ./build/src/gl/renderer.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar shader_builder_1 = __webpack_require__(/*! ./shader-builder */ \"./build/src/gl/shader-builder/index.js\");\nvar gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nvar _1 = __webpack_require__(/*! . */ \"./build/src/gl/index.js\");\nvar Renderer = /** @class */ (function () {\n    function Renderer(renderContext) {\n        var _this = this;\n        this.renderContext = renderContext;\n        this.programBuilder = new shader_builder_1.ProgramBuilder(renderContext.gl);\n        this.programsByMaterialId = new Map();\n        this.identifiers = _1.types.DefaultShaderIdentifiers;\n        this.textureSetter = function (tex) { return textureSetter(_this.renderContext, tex); };\n        this.textureFinisher = function (tex) { return textureFinisher(_this.renderContext, tex); };\n        this.inverseTransposeModel = gl_matrix_1.mat4.create();\n    }\n    Renderer.prototype.makeCurrentInverseTransposeModel = function (model) {\n        var invModel = this.inverseTransposeModel;\n        gl_matrix_1.mat4.invert(gl_matrix_1.mat4.transpose(invModel, model), invModel);\n    };\n    Renderer.prototype.setTextures = function (mat) {\n        mat.useTextures(this.textureSetter);\n    };\n    Renderer.prototype.unsetTextures = function (mat) {\n        mat.useTextures(this.textureFinisher);\n    };\n    Renderer.prototype.setModelViewProjection = function (prog, model, view, proj) {\n        var idents = this.identifiers;\n        prog.setMat4(idents.uniforms.model, model);\n        prog.setMat4(idents.uniforms.view, view);\n        prog.setMat4(idents.uniforms.projection, proj);\n    };\n    Renderer.prototype.setLightUniforms = function (prog, lights, camera) {\n        for (var j = 0; j < lights.length; j++) {\n            lights[j].setUniforms(prog);\n        }\n        prog.setVec3(this.identifiers.uniforms.cameraPosition, camera.position);\n    };\n    Renderer.prototype.render = function (scene, camera, view, proj) {\n        var models = scene.models;\n        var lights = scene.lights;\n        var renderContext = this.renderContext;\n        var identifiers = this.identifiers;\n        for (var i = 0; i < models.length; i++) {\n            var model = models[i];\n            var material = model.material;\n            var drawComponent = model.drawable;\n            var progForMaterial = this.requireProgram(material);\n            renderContext.useProgram(progForMaterial);\n            if (material.descriptor.lightingModel !== 2 /* None */) {\n                this.setLightUniforms(progForMaterial, lights, camera);\n                this.makeCurrentInverseTransposeModel(model.transform.matrix);\n                progForMaterial.setMat4(identifiers.uniforms.inverseTransposeModel, this.inverseTransposeModel);\n            }\n            this.setModelViewProjection(progForMaterial, model.transform.matrix, view, proj);\n            material.useTextures(this.textureSetter);\n            material.setUniforms(progForMaterial);\n            renderContext.bindVao(drawComponent.vao);\n            drawComponent.draw();\n            material.useTextures(this.textureFinisher);\n            material.clearIsNewSchema();\n        }\n    };\n    Renderer.prototype.requireProgram = function (forMaterial) {\n        var progForMaterial = this.programsByMaterialId.get(forMaterial.id);\n        if (progForMaterial === undefined || forMaterial.isNewSchema()) {\n            progForMaterial = this.programBuilder.requireProgram(forMaterial);\n            this.programsByMaterialId.set(forMaterial.id, progForMaterial);\n        }\n        return progForMaterial;\n    };\n    return Renderer;\n}());\nexports.Renderer = Renderer;\nfunction textureSetter(renderContext, texture) {\n    renderContext.pushActiveTexture2DAndBind(texture);\n}\nfunction textureFinisher(renderContext, texture) {\n    renderContext.popTexture2D();\n}\n\n\n//# sourceURL=webpack:///./build/src/gl/renderer.js?");

/***/ }),

/***/ "./build/src/gl/scene.js":
/*!*******************************!*\
  !*** ./build/src/gl/scene.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar transform_1 = __webpack_require__(/*! ./transform */ \"./build/src/gl/transform.js\");\nvar Scene = /** @class */ (function () {\n    function Scene() {\n        this.transform = new transform_1.Transform();\n        this.models = [];\n        this.lights = [];\n        this.numLightsByType = new Map();\n    }\n    Scene.prototype.setLightIndex = function (light) {\n        var lightIndex = this.numLightsByType.get(light.kind);\n        if (lightIndex === undefined) {\n            lightIndex = 0;\n        }\n        light.index = lightIndex;\n        this.numLightsByType.set(light.kind, lightIndex + 1);\n    };\n    Scene.prototype.addModel = function (model) {\n        this.models.push(model);\n    };\n    Scene.prototype.addLight = function (light) {\n        this.setLightIndex(light);\n        this.lights.push(light);\n    };\n    return Scene;\n}());\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack:///./build/src/gl/scene.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/builder.js":
/*!************************************************!*\
  !*** ./build/src/gl/shader-builder/builder.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar types = __webpack_require__(/*! ../types */ \"./build/src/gl/types.js\");\nvar _1 = __webpack_require__(/*! . */ \"./build/src/gl/shader-builder/index.js\");\nvar program_1 = __webpack_require__(/*! ../program */ \"./build/src/gl/program.js\");\nvar util_1 = __webpack_require__(/*! ../../util */ \"./build/src/util/index.js\");\nfunction generateMaterialHash(forDescriptor) {\n    var into = [];\n    generateUniformIdentifierTypeIds(forDescriptor.uniforms, into);\n    generateAdditionalPropertyIds(forDescriptor, into);\n    return into.join(',');\n}\nfunction generateAdditionalPropertyIds(descriptor, into) {\n    var props = Object.keys(descriptor);\n    for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if (descriptor.hasOwnProperty(prop) && descriptor[prop] !== undefined) {\n            var value = descriptor[prop];\n            if (typeof value === 'boolean' || typeof value === 'string') {\n                into.push(prop + \",\" + value);\n            }\n        }\n    }\n}\nfunction generateUniformIdentifierTypeIds(uniforms, into) {\n    for (var prop in uniforms) {\n        if (uniforms[prop] !== undefined) {\n            var uniform = uniforms[prop];\n            into.push(uniform.identifier + \",\" + uniform.type);\n        }\n    }\n}\nfunction handleLightingModel(forMaterial, fragSchema, identifiers) {\n    var lightingModel = forMaterial.descriptor.lightingModel;\n    var fragInputPlug = _1.fragColor.makeDefaultInputPlug(identifiers);\n    if (lightingModel === 0 /* Phong */) {\n        var inputPlug = _1.phong.makeDefaultInputPlug(identifiers);\n        var outputPlug = _1.phong.makeDefaultOutputPlug(identifiers);\n        outputPlug.modelColor.connectTo(fragInputPlug.modelColor);\n        _1.phong.applyComponent(fragSchema, forMaterial, inputPlug, outputPlug);\n    }\n    else if (lightingModel === 1 /* Physical */) {\n        var inputPlug = _1.physical.makeDefaultInputPlug(identifiers);\n        var outputPlug = _1.physical.makeDefaultOutputPlug(identifiers);\n        outputPlug.modelColor.connectTo(fragInputPlug.modelColor);\n        _1.physical.applyComponent(fragSchema, forMaterial, inputPlug, outputPlug);\n    }\n    else if (lightingModel === 2 /* None */) {\n        var inputPlug = _1.noLight.makeDefaultInputPlug(identifiers);\n        var outputPlug = _1.noLight.makeDefaultOutputPlug(identifiers);\n        outputPlug.modelColor.connectTo(fragInputPlug.modelColor);\n        _1.noLight.applyComponent(fragSchema, forMaterial, inputPlug, outputPlug);\n    }\n    else {\n        console.warn(\"Unsupported lighting model: \\\"\" + forMaterial.descriptor.lightingModel + \"\\\".\");\n    }\n    _1.fragColor.applyComponent(fragSchema, forMaterial, fragInputPlug);\n}\nfunction handleGeometry(forMaterial, vertSchema, fragSchema, identifiers) {\n    var needsUv = forMaterial.hasTextureUniform();\n    var needsNormal = forMaterial.descriptor.lightingModel !== 2 /* None */;\n    var needsVaryingPosition = forMaterial.descriptor.lightingModel !== 2 /* None */;\n    var posAttr = types.makeGLSLVariable(identifiers.attributes.position, 'vec3');\n    var normAttr = types.makeGLSLVariable(identifiers.attributes.normal, 'vec3');\n    var uvAttr = types.makeGLSLVariable(identifiers.attributes.uv, 'vec2');\n    vertSchema.requireAttribute(posAttr);\n    var posVarying = types.makeGLSLVariable(identifiers.varyings.position, 'vec3');\n    var normVarying = types.makeGLSLVariable(identifiers.varyings.normal, 'vec3');\n    var uvVarying = types.makeGLSLVariable(identifiers.varyings.uv, 'vec2');\n    if (needsVaryingPosition) {\n        vertSchema.requireVarying(posVarying);\n        fragSchema.requireVarying(posVarying);\n    }\n    if (needsNormal) {\n        vertSchema.requireVarying(normVarying);\n        vertSchema.requireAttribute(normAttr);\n        //\n        fragSchema.requireVarying(normVarying);\n    }\n    if (needsUv) {\n        vertSchema.requireVarying(uvVarying);\n        vertSchema.requireAttribute(uvAttr);\n        //\n        fragSchema.requireVarying(uvVarying);\n    }\n    var worldInput = _1.worldPosition.makeDefaultInputPlug(identifiers);\n    var worldOutput = _1.worldPosition.makeDefaultOutputPlug(identifiers);\n    //\n    var normInput = _1.worldNormal.makeDefaultInputPlug(identifiers);\n    var normOutput = _1.worldNormal.makeDefaultOutputPlug(identifiers);\n    //\n    var projInput = _1.projectivePosition.makeDefaultInputPlug(identifiers);\n    var projOutput = _1.projectivePosition.makeDefaultOutputPlug(identifiers);\n    //\n    var vertInput = _1.vertexPosition.makeDefaultInputPlug(identifiers);\n    worldInput.position = types.makeAttributeComponentPlug(posAttr);\n    worldOutput.position.connectTo(projInput.position);\n    projOutput.position.connectTo(vertInput.position);\n    _1.worldPosition.applyComponent(vertSchema, worldInput, worldOutput);\n    _1.projectivePosition.applyComponent(vertSchema, projInput, projOutput);\n    _1.vertexPosition.applyComponent(vertSchema, vertInput);\n    if (needsVaryingPosition) {\n        _1.common.assignToVariableOrLogError(vertSchema, posVarying, worldOutput.position);\n    }\n    if (needsNormal) {\n        _1.worldNormal.applyComponent(vertSchema, normInput, normOutput);\n        // common.assignToVariableOrLogError(vertSchema, normVarying, normOutput.normal);\n    }\n    if (needsUv) {\n        _1.common.assignToVariableOrLogError(vertSchema, uvVarying, uvAttr);\n    }\n}\nfunction makeProgram(gl, forMaterial) {\n    var vertSchema = types.ShaderSchema.Vertex();\n    var fragSchema = types.ShaderSchema.Fragment();\n    var identifiers = types.DefaultShaderIdentifiers;\n    handleGeometry(forMaterial, vertSchema, fragSchema, identifiers);\n    handleLightingModel(forMaterial, fragSchema, identifiers);\n    // console.log(common.shaderSchemaToString(vertSchema));\n    // console.log(common.shaderSchemaToString(fragSchema));\n    return program_1.Program.fromSchemas(gl, vertSchema, fragSchema);\n}\nvar ProgramBuilder = /** @class */ (function () {\n    function ProgramBuilder(gl) {\n        this.isDebug = false;\n        this.gl = gl;\n        this.programs = {};\n        this.stopWatch = new util_1.Stopwatch();\n    }\n    ProgramBuilder.prototype.makeProgram = function (progHash, forMaterial) {\n        this.stopWatch.reset();\n        var prog = makeProgram(this.gl, forMaterial);\n        if (this.isDebug) {\n            console.log(\"Made new program in \" + this.stopWatch.elapsed().toFixed(2) + \" ms.\");\n        }\n        this.programs[progHash] = prog;\n        return prog;\n    };\n    ProgramBuilder.prototype.requireProgram = function (forMaterial) {\n        var programInfoHash = generateMaterialHash(forMaterial.descriptor);\n        var maybeProg = this.programs[programInfoHash];\n        if (maybeProg === undefined) {\n            return this.makeProgram(programInfoHash, forMaterial);\n        }\n        else {\n            if (this.isDebug) {\n                console.log('Using cached program ...');\n            }\n            return maybeProg;\n        }\n    };\n    return ProgramBuilder;\n}());\nexports.ProgramBuilder = ProgramBuilder;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/builder.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/common.js":
/*!***********************************************!*\
  !*** ./build/src/gl/shader-builder/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar __1 = __webpack_require__(/*! .. */ \"./build/src/gl/index.js\");\nvar errors;\n(function (errors) {\n    function inconsistentTypesForSameIdentifier(ident, srcType, destType) {\n        return \"Usage of identifier \\\"\" + ident + \"\\\" is inconsistent; source type is \\\"\" + srcType + \"\\\", while destination type is \\\"\" + destType + \"\\\".\";\n    }\n    errors.inconsistentTypesForSameIdentifier = inconsistentTypesForSameIdentifier;\n    function incompatibleTypesForAssignment(destIdent, destType, srcIdent, srcType) {\n        return \"Unsupported source type: \" + srcType + \" for destination type: \" + destType + \"; for source: \\\"\" + srcIdent + \"\\\" and destination: \\\"\" + destIdent + \"\\\".\";\n    }\n    errors.incompatibleTypesForAssignment = incompatibleTypesForAssignment;\n})(errors || (errors = {}));\nfunction requireIdentifiers(identifiers) {\n    if (identifiers === undefined) {\n        return __1.types.DefaultShaderIdentifiers;\n    }\n    else {\n        return identifiers;\n    }\n}\nexports.requireIdentifiers = requireIdentifiers;\nfunction applyMaterial(toPlug, forMaterial) {\n    forMaterial.useActiveUniforms(function (uniform, kind) {\n        if (kind in toPlug) {\n            toPlug[kind].getSource().type = uniform.type;\n        }\n    });\n}\nexports.applyMaterial = applyMaterial;\nfunction assertConnectSuccess(result) {\n    if (!result.success) {\n        throw new Error(result.message);\n    }\n}\nexports.assertConnectSuccess = assertConnectSuccess;\nfunction makeSuccessConnectResult() {\n    return { success: true };\n}\nfunction makeErrorConnectResult(message) {\n    return { success: false, message: message };\n}\nfunction connect(forSchema, plug, toOutlet, isInput) {\n    var toJoin = [];\n    for (var connectionName in toOutlet) {\n        var outlet = toOutlet[connectionName];\n        var connection = plug[connectionName];\n        forSchema.requireTemporaryIfNotStatic(outlet);\n        if (plug.hasOwnProperty(connectionName) && connection !== undefined) {\n            var source = connection.getSource();\n            var sourceId = source.identifier;\n            var samplerSource = connection.getSamplerSource();\n            var outletId = outlet.identifier;\n            var outletType = outlet.type;\n            var srcIsSampler = source.type === 'sampler2D';\n            if (srcIsSampler && !isInput) {\n                return makeErrorConnectResult('Sampler source is not a valid assignment target.');\n            }\n            else if (srcIsSampler && samplerSource === undefined) {\n                return makeErrorConnectResult('Sampler source requires an additional samplerSource input.');\n            }\n            else if (outletId === sourceId) {\n                //  Ignore self- assignment\n                if (outletType !== source.type) {\n                    //  Assignment between unlike types, but same identifier.\n                    if (isInput) {\n                        return makeErrorConnectResult(errors.inconsistentTypesForSameIdentifier(outletId, source.type, outletType));\n                    }\n                    else {\n                        return makeErrorConnectResult(errors.inconsistentTypesForSameIdentifier(sourceId, outletType, source.type));\n                    }\n                }\n            }\n            else {\n                var samplerSourceId = samplerSource === undefined ? '' : samplerSource.getSource().identifier;\n                var assignResult = void 0;\n                if (isInput) {\n                    assignResult = assign(outletId, outletType, sourceId, source.type, samplerSourceId);\n                }\n                else {\n                    assignResult = assign(sourceId, source.type, outletId, outletType, '');\n                }\n                if (assignResult.success) {\n                    toJoin.push(assignResult.value);\n                    if (!isInput || connection.getSourceType() !== 3 /* Temporary */) {\n                        forSchema.requireBySourceType(source, connection.getSourceType());\n                    }\n                }\n                else {\n                    return makeErrorConnectResult(assignResult.value);\n                }\n            }\n        }\n    }\n    forSchema.body.push(function () { return toJoin.join('\\n'); });\n    return makeSuccessConnectResult();\n}\nfunction connectOutputs(forSchema, plug, toOutlet) {\n    return connect(forSchema, plug, toOutlet, false);\n}\nexports.connectOutputs = connectOutputs;\nfunction connectInputs(forSchema, plug, toOutlet) {\n    return connect(forSchema, plug, toOutlet, true);\n}\nexports.connectInputs = connectInputs;\nfunction requireStatics(toSchema, statics) {\n    var toJoin = [];\n    for (var staticName in statics) {\n        var staticValue = statics[staticName];\n        var source = staticValue.getSource();\n        var sourceType = staticValue.getSourceType();\n        switch (sourceType) {\n            case 3 /* Temporary */:\n                toJoin.push(declarationToString(source));\n                break;\n            case 2 /* Uniform */:\n                toSchema.requireUniform(source);\n                break;\n            default:\n                console.error(\"Invalid source type \\\"\" + sourceType + \"\\\" for static: \\\"\" + source.identifier + \"\\\".\");\n        }\n    }\n    toSchema.head.push(function () { return toJoin.join('\\n'); });\n}\nexports.requireStatics = requireStatics;\nfunction requireTemporaries(toSchema, requiredTemporaries) {\n    for (var temporaryName in requiredTemporaries) {\n        toSchema.requireTemporary(requiredTemporaries[temporaryName]);\n    }\n}\nexports.requireTemporaries = requireTemporaries;\nfunction singleComponentInitializerExpressionForType(type, to) {\n    switch (type) {\n        case 'float':\n            return to;\n        case 'vec2':\n            return \"vec2(\" + to + \")\";\n        case 'vec3':\n            return \"vec3(\" + to + \")\";\n        case 'vec4':\n            return \"vec4(\" + to + \")\";\n        case 'mat2':\n            return \"mat2(\" + to + \")\";\n        case 'mat3':\n            return \"mat3(\" + to + \")\";\n        case 'mat4':\n            return \"mat4(\" + to + \")\";\n        case 'sampler2D':\n            console.error('No float initializer allowed for sampler2D.');\n            return '';\n    }\n}\nexports.singleComponentInitializerExpressionForType = singleComponentInitializerExpressionForType;\nfunction defaultInitializerExpressionForType(type) {\n    return singleComponentInitializerExpressionForType(type, '0.0');\n}\nfunction rgbComponentString(numComponents) {\n    switch (numComponents) {\n        case 1:\n            return 'r';\n        case 2:\n            return 'rg';\n        case 3:\n            return 'rgb';\n        case 4:\n            return 'rgba';\n        default:\n            return 'r';\n    }\n}\nfunction xyzComponentString(numComponents) {\n    switch (numComponents) {\n        case 1:\n            return 'x';\n        case 2:\n            return 'xy';\n        case 3:\n            return 'xyz';\n        case 4:\n            return 'xyzw';\n        default:\n            return 'x';\n    }\n}\nfunction expandFloatToComponents(srcIdentifier, destIdentifier, destType) {\n    var initializer = singleComponentInitializerExpressionForType(destType, srcIdentifier);\n    return assignmentComponentsToString(destIdentifier, initializer);\n}\nfunction sampler2DToTemporary(srcIdentifier, destIdentifier, destType, uvIdentifier) {\n    var numDestComponents = __1.types.numComponentsInGLSLType(destType);\n    var destSamplerSuffix = rgbComponentString(numDestComponents);\n    var initializer = \"texture2D(\" + srcIdentifier + \", \" + uvIdentifier + \").\" + destSamplerSuffix;\n    return assignmentComponentsToString(destIdentifier, initializer);\n}\nfunction demoteVector(srcType, srcIdentifier, destType) {\n    var numDestComponents = __1.types.numComponentsInGLSLType(destType);\n    var numToDemote = numDestComponents;\n    var componentStr = xyzComponentString(numToDemote);\n    return srcIdentifier + \".\" + componentStr;\n}\nexports.demoteVector = demoteVector;\nfunction promoteVector(srcType, srcIdentifier, destType, fillComponent, numDecimalPlaces) {\n    if (fillComponent === void 0) { fillComponent = 1; }\n    if (numDecimalPlaces === void 0) { numDecimalPlaces = 1; }\n    var numSrcComponents = __1.types.numComponentsInGLSLType(srcType);\n    var numDestComponents = __1.types.numComponentsInGLSLType(destType);\n    var numToFill = numDestComponents - numSrcComponents;\n    var fillWith = \"\" + fillComponent.toFixed(numDecimalPlaces);\n    var toJoin = [];\n    for (var i = 0; i < numToFill; i++) {\n        toJoin.push(',' + fillWith);\n    }\n    var joinStr = toJoin.join('');\n    return destType + \"(\" + srcIdentifier + joinStr + \")\";\n}\nexports.promoteVector = promoteVector;\nfunction makeSuccessAssignResult(value) {\n    return { success: true, value: value };\n}\nfunction makeErrorAssignResult(msg) {\n    return { success: false, value: msg };\n}\nfunction assignToVariableOrLogError(schema, dest, src) {\n    var assignResult;\n    if (__1.types.typeTest.isShaderComponentPlug(src)) {\n        assignResult = assignPlugToVariable(dest.identifier, dest.type, src);\n    }\n    else {\n        assignResult = assign(dest.identifier, dest.type, src.identifier, src.type, '');\n    }\n    if (!assignResult.success) {\n        console.error(assignResult.value);\n    }\n    else {\n        schema.body.push(function () { return assignResult.value; });\n    }\n}\nexports.assignToVariableOrLogError = assignToVariableOrLogError;\nfunction assignPlugToVariable(destIdent, destType, src) {\n    var source = src.getSource();\n    var samplerSource = src.getSamplerSource();\n    if (samplerSource === undefined) {\n        return assign(destIdent, destType, source.identifier, source.type, undefined);\n    }\n    else {\n        var samplerIdent = samplerSource.getSource().identifier;\n        return assign(destIdent, destType, source.identifier, source.type, samplerIdent);\n    }\n}\nexports.assignPlugToVariable = assignPlugToVariable;\nfunction assign(destIdentifier, destType, srcIdentifier, srcType, uvIdentifier) {\n    if (destType === 'sampler2D') {\n        return makeErrorAssignResult(\"sampler2D \\\"\" + destIdentifier + \"\\\" is not a valid assignment target.\");\n    }\n    if (srcType === destType) {\n        return makeSuccessAssignResult(assignmentComponentsToString(destIdentifier, srcIdentifier));\n    }\n    switch (srcType) {\n        case 'float':\n            return makeSuccessAssignResult(expandFloatToComponents(srcIdentifier, destIdentifier, destType));\n        case 'sampler2D': {\n            if (uvIdentifier.length > 0) {\n                return makeSuccessAssignResult(sampler2DToTemporary(srcIdentifier, destIdentifier, destType, uvIdentifier));\n            }\n            else {\n                return makeErrorAssignResult('Identifier of sample coordinates for sampler2D input was empty.');\n            }\n        }\n        case 'vec2':\n        case 'vec3':\n        case 'vec4':\n            if (__1.types.numComponentsInGLSLType(srcType) < __1.types.numComponentsInGLSLType(destType)) {\n                return makeSuccessAssignResult(assignmentComponentsToString(destIdentifier, promoteVector(srcType, srcIdentifier, destType, 1)));\n            }\n            else {\n                return makeSuccessAssignResult(assignmentComponentsToString(destIdentifier, demoteVector(srcType, srcIdentifier, destType)));\n            }\n    }\n    return makeErrorAssignResult(errors.incompatibleTypesForAssignment(destIdentifier, destType, srcIdentifier, srcType));\n}\nexports.assign = assign;\nfunction prefixedDeclarationToString(prefix, decl) {\n    return prefix + \" \" + declarationToString(decl);\n}\nfunction assignmentComponentsToString(destIdentifier, srcIdentifier) {\n    return destIdentifier + \" = \" + srcIdentifier + \";\";\n}\nfunction completeTypeIdentifier(forVariable) {\n    if (forVariable.isArray === true) {\n        var sz = forVariable.arraySize || 1;\n        return forVariable.type + \" \" + forVariable.identifier + \"[\" + sz + \"]\";\n    }\n    else {\n        return forVariable.type + \" \" + forVariable.identifier;\n    }\n}\nfunction declarationToString(decl, initializer) {\n    if (initializer !== undefined) {\n        return completeTypeIdentifier(decl) + \" = \" + initializer + \";\";\n    }\n    else {\n        return completeTypeIdentifier(decl) + \";\";\n    }\n}\nfunction precisionDeclaration(precision) {\n    return \"precision \" + precision + \" float;\";\n}\nfunction addPrefixed(toArray, prefix, values) {\n    for (var i = 0; i < values.length; i++) {\n        toArray.push(prefixedDeclarationToString(prefix, values[i]));\n    }\n}\nfunction shaderSchemaToString(schema) {\n    var arrayRes = [];\n    arrayRes.push(schema.version);\n    arrayRes.push(precisionDeclaration(schema.precision));\n    addPrefixed(arrayRes, 'attribute', schema.attributes);\n    addPrefixed(arrayRes, 'varying', schema.varyings);\n    addPrefixed(arrayRes, 'uniform', schema.uniforms);\n    for (var i = 0; i < schema.head.length; i++) {\n        arrayRes.push(schema.head[i]());\n    }\n    arrayRes.push('void main() {');\n    for (var i = 0; i < schema.temporaries.length; i++) {\n        var temporary = schema.temporaries[i];\n        arrayRes.push(declarationToString(temporary));\n        // const initializer = defaultInitializerExpressionForType(temporary.type);\n        // arrayRes.push(declarationToString(temporary, initializer));\n    }\n    for (var i = 0; i < schema.body.length; i++) {\n        arrayRes.push(schema.body[i]());\n    }\n    arrayRes.push('}');\n    return arrayRes.join('\\n');\n}\nexports.shaderSchemaToString = shaderSchemaToString;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/common.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/components.js":
/*!***************************************************!*\
  !*** ./build/src/gl/shader-builder/components.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar types = __webpack_require__(/*! ../types */ \"./build/src/gl/types.js\");\nvar common_1 = __webpack_require__(/*! ./common */ \"./build/src/gl/shader-builder/common.js\");\nfunction makeDefaultSamplerSource(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    return types.makeConcreteComponentPlug(types.makeGLSLVariable(identifiers.varyings.uv, 'vec2'), 1 /* Varying */);\n}\nexports.makeDefaultSamplerSource = makeDefaultSamplerSource;\nfunction makeDefaultCommonLightStatics(identifiers) {\n    var maxNumDirLights = types.ShaderLimits.maxNumUniformDirectionalLights;\n    var maxNumPointLights = types.ShaderLimits.maxNumUniformPointLights;\n    var makePlug = types.makeConcreteComponentPlug;\n    var makeVar = types.makeGLSLVariable;\n    var uniforms = identifiers.uniforms;\n    return {\n        directionalLightPositions: makePlug(makeVar(uniforms.directionalLightPositions, 'vec3', true, maxNumDirLights), 2 /* Uniform */),\n        directionalLightColors: makePlug(makeVar(uniforms.directionalLightColors, 'vec3', true, maxNumDirLights), 2 /* Uniform */),\n        pointLightPositions: makePlug(makeVar(uniforms.pointLightPositions, 'vec3', true, maxNumPointLights), 2 /* Uniform */),\n        pointLightColors: makePlug(makeVar(uniforms.pointLightColors, 'vec3', true, maxNumPointLights), 2 /* Uniform */),\n        cameraPosition: makePlug(makeVar(uniforms.cameraPosition, 'vec3'), 2 /* Uniform */)\n    };\n}\nexports.makeDefaultCommonLightStatics = makeDefaultCommonLightStatics;\nfunction isMixablePlug(plug) {\n    var source = plug.getSource();\n    return types.isGLSLVector(source.type) || source.type === 'float' || (source.type === 'sampler2D' && plug.getSamplerSource() !== undefined);\n}\nfunction mix(a, b, byFactor) {\n    var sourceA = a.getSource();\n    var sourceB = b.getSource();\n    var sourceFactor = byFactor.getSource();\n    if (!isMixablePlug(a) || !isMixablePlug(b) || !isMixablePlug(byFactor)) {\n        throw new Error('Mixing values must be vector, float, or sampler2D with valid samplerSource.');\n    }\n    var aIsSampler = sourceA.type === 'sampler2D';\n    var bIsSampler = sourceB.type === 'sampler2D';\n    var factorIsSampler = sourceFactor.type === 'sampler2D';\n    if (aIsSampler || bIsSampler || factorIsSampler) {\n        //  Samplers not yet supported.\n        throw new Error('Mixing values must be vector or float.');\n    }\n    var numComponentsA = aIsSampler ? 1 : types.numComponentsInGLSLType(sourceA.type);\n    var numComponentsB = bIsSampler ? 1 : types.numComponentsInGLSLType(sourceB.type);\n    var numComponentsSrc = factorIsSampler ? 1 : types.numComponentsInGLSLType(sourceFactor.type);\n    var identA = sourceA.identifier;\n    var identB = sourceB.identifier;\n    var identFactor = sourceFactor.identifier;\n    var strA = identA;\n    var strB = identB;\n    var factorStr = identFactor;\n    var maxNumComponents = Math.max(numComponentsA, numComponentsB);\n    var maxType = numComponentsA >= numComponentsB ? sourceA.type : sourceB.type;\n    if (numComponentsA < maxNumComponents) {\n        if (sourceA.type === 'float') {\n            strA = common_1.singleComponentInitializerExpressionForType(sourceB.type, identA);\n        }\n        else {\n            strA = common_1.promoteVector(sourceA.type, identA, sourceB.type);\n        }\n    }\n    if (numComponentsB < maxNumComponents) {\n        if (sourceB.type === 'float') {\n            strB = common_1.singleComponentInitializerExpressionForType(sourceA.type, identB);\n        }\n        else {\n            strB = common_1.promoteVector(sourceB.type, identB, sourceA.type);\n        }\n    }\n    if (numComponentsSrc > maxNumComponents) {\n        factorStr = common_1.demoteVector(sourceFactor.type, identFactor, maxType);\n    }\n    else if (numComponentsSrc < maxNumComponents) {\n        if (sourceFactor.type === 'float') {\n            factorStr = common_1.singleComponentInitializerExpressionForType(maxType, identFactor);\n        }\n        else {\n            factorStr = common_1.promoteVector(sourceFactor.type, identFactor, maxType);\n        }\n    }\n    return \"mix(\" + strA + \", \" + strB + \", \" + factorStr + \")\";\n}\nexports.mix = mix;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/components.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/frag-color.js":
/*!***************************************************!*\
  !*** ./build/src/gl/shader-builder/frag-color.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar __1 = __webpack_require__(/*! .. */ \"./build/src/gl/index.js\");\nvar common_1 = __webpack_require__(/*! ./common */ \"./build/src/gl/shader-builder/common.js\");\nvar DefaultFragColorInputs = makeDefaultInputOutlet(__1.types.DefaultShaderIdentifiers);\nfunction makeDefaultInputOutlet(identifiers) {\n    return {\n        modelColor: __1.types.makeGLSLVariable(identifiers.temporaries.fragColor.identifier, 'vec4')\n    };\n}\nexports.makeDefaultInputOutlet = makeDefaultInputOutlet;\nfunction makeDefaultInputPlug(identifiers) {\n    if (identifiers === undefined) {\n        identifiers = __1.types.DefaultShaderIdentifiers;\n    }\n    return {\n        modelColor: __1.types.makeConcreteComponentPlug(identifiers.temporaries.modelColor, 3 /* Temporary */)\n    };\n}\nexports.makeDefaultInputPlug = makeDefaultInputPlug;\nfunction assignFragColor(inputs) {\n    return \"gl_FragColor = \" + inputs.modelColor.identifier + \";\";\n}\nfunction applyComponent(toSchema, forMaterial, plugInputs) {\n    var inputs = DefaultFragColorInputs;\n    common_1.assertConnectSuccess(common_1.connectInputs(toSchema, plugInputs, inputs));\n    toSchema.body.push(function () { return assignFragColor(inputs); });\n}\nexports.applyComponent = applyComponent;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/frag-color.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/index.js":
/*!**********************************************!*\
  !*** ./build/src/gl/shader-builder/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar common = __webpack_require__(/*! ./common */ \"./build/src/gl/shader-builder/common.js\");\nexports.common = common;\nvar components = __webpack_require__(/*! ./components */ \"./build/src/gl/shader-builder/components.js\");\nexports.components = components;\nvar physical = __webpack_require__(/*! ./physical */ \"./build/src/gl/shader-builder/physical.js\");\nexports.physical = physical;\nvar fragColor = __webpack_require__(/*! ./frag-color */ \"./build/src/gl/shader-builder/frag-color.js\");\nexports.fragColor = fragColor;\nvar phong = __webpack_require__(/*! ./phong */ \"./build/src/gl/shader-builder/phong.js\");\nexports.phong = phong;\nvar noLight = __webpack_require__(/*! ./no-light */ \"./build/src/gl/shader-builder/no-light.js\");\nexports.noLight = noLight;\nvar worldPosition = __webpack_require__(/*! ./world-position */ \"./build/src/gl/shader-builder/world-position.js\");\nexports.worldPosition = worldPosition;\nvar projectivePosition = __webpack_require__(/*! ./projective-position */ \"./build/src/gl/shader-builder/projective-position.js\");\nexports.projectivePosition = projectivePosition;\nvar vertexPosition = __webpack_require__(/*! ./vertex-position */ \"./build/src/gl/shader-builder/vertex-position.js\");\nexports.vertexPosition = vertexPosition;\nvar worldNormal = __webpack_require__(/*! ./world-normal */ \"./build/src/gl/shader-builder/world-normal.js\");\nexports.worldNormal = worldNormal;\nvar builder_1 = __webpack_require__(/*! ./builder */ \"./build/src/gl/shader-builder/builder.js\");\nexports.ProgramBuilder = builder_1.ProgramBuilder;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/index.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/library.js":
/*!************************************************!*\
  !*** ./build/src/gl/shader-builder/library.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nfunction phongDirectionalLightingDeclaration() {\n    return \"\\nvec3 phong_directional_lighting(vec3 normal, vec3 light_position, \\n  vec3 light_color, vec3 normal_to_camera, float ka, float kd, float ks, float spec_power) {\\n\\n  vec3 to_light = normalize(light_position);\\n  vec3 reflect_dir = normalize(normal_to_camera + to_light);\\n\\n  float diffuse = kd * max(dot(normal, to_light), 0.0);\\n  float spec = ks * pow(max(dot(normal, reflect_dir), 0.0), spec_power);\\n\\n  float total_light = ka + diffuse + spec;\\n\\n  return light_color * total_light;\\n}\\n\";\n}\nexports.phongDirectionalLightingDeclaration = phongDirectionalLightingDeclaration;\nfunction phongPointLightingDeclaration() {\n    return \"\\nvec3 phong_point_lighting(vec3 position, vec3 normal, vec3 light_position, vec3 light_color, \\n  vec3 normal_to_camera, float ka, float kd, float ks, float spec_power) {\\n\\n  vec3 to_light = normalize(light_position - position);\\n  vec3 reflect_dir = normalize(normal_to_camera + to_light);\\n\\n  float diffuse = kd * max(dot(normal, to_light), 0.0);\\n  float spec = ks * pow(max(dot(normal, reflect_dir), 0.0), spec_power);\\n\\n  float total_light = ka + diffuse + spec;\\n\\n  return light_color * total_light;\\n}\\n\";\n}\nexports.phongPointLightingDeclaration = phongPointLightingDeclaration;\nfunction pbrDeclaration() {\n    return \"\\n    const float PI = \" + Math.PI + \";\\n\\n\\t\\tfloat distribution_ggx(vec3 N, vec3 H, float roughness);\\n\\t\\tfloat geometry_schlick_ggx(float NdotV, float roughness);\\n\\t\\tfloat geometry_smith(vec3 N, vec3 V, vec3 L, float roughness);\\n\\t\\tvec3 fresnel_schlick(float cos_theta, vec3 F0);\\n\\t\\tvec3 PBR(\\n\\t\\t     vec3 normals,\\n\\t\\t     vec3 albedo,\\n\\t\\t     float roughness,\\n\\t\\t     float metallic,\\n\\t\\t     vec3 cam_position,\\n\\t\\t     vec3 world_position,\\n\\t\\t     vec3 light_position,\\n\\t\\t     vec3 light_color,\\n\\t\\t     bool is_directional) {\\n\\t\\t    \\n\\t\\t    vec3 F0 = vec3(0.04);\\n\\t\\t    F0 = mix(F0, albedo, metallic);\\n\\t\\t    \\n\\t\\t    vec3 N = normalize(normals);\\n\\t\\t    vec3 V = normalize(cam_position - world_position);\\n\\t\\t    \\n\\t\\t    vec3 L;\\n\\t\\t    if (is_directional) {\\n          L = normalize(light_position);\\n\\t\\t    } else {\\n          L = normalize(light_position - world_position);\\n\\t\\t    }\\n\\t\\t    vec3 H = normalize(V + L);\\n\\t\\t    float attenuation = 1.0;\\n\\t\\t    \\n\\t\\t    if (!is_directional) {\\n\\t\\t    \\tfloat distance = length(light_position - world_position);\\n\\t\\t    \\tattenuation = 1.0 / (distance * distance * 0.0002);\\n\\t\\t    }\\n\\t\\t    \\n\\t\\t    vec3 radiance = light_color * attenuation;\\n\\t\\t    \\n\\t\\t    vec3 F = fresnel_schlick(max(dot(H, V), 0.0), F0);\\n\\t\\t    float NDF = distribution_ggx(N, H, roughness);\\n\\t\\t    float G = geometry_smith(N, V, L, roughness);\\n\\t\\t    vec3 numer = vec3(NDF) * vec3(G) * F;\\n\\t\\t    float denom = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;\\n\\t\\t    vec3 specular = numer / denom;\\n\\t\\t    \\n\\t\\t    vec3 kS = F;\\n\\t\\t    vec3 kD = vec3(1.0) - kS;\\n\\t\\t    kD *= 1.0 - metallic;\\n\\t\\t    \\n\\t\\t    float NdotL = max(dot(N, L), 0.0);\\n\\t\\t    return (kD * albedo / PI + specular) * radiance * NdotL;\\n\\t\\t}\\n\\t\\t//\\n\\t\\t//  Fresnel component (F)\\n\\t\\t//\\n\\t\\tvec3 fresnel_schlick(float cosTheta, vec3 F0) {\\n      return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\\n\\t\\t}\\n\\t\\t//\\n\\t\\t//  Normal distribution component (D)\\n\\t\\t//\\n\\t\\tfloat distribution_beckman(vec3 h, vec3 n, float roughness) {\\n      float a = roughness * roughness;\\n      float a2 = a * a;\\n      float n_dot_h = max(dot(n, h), 0.0);\\n      float n_dot_h2 = n_dot_h * n_dot_h;\\n      float part_a = 1.0 / (PI * a2 * pow(n_dot_h, 4.0));\\n      float exp_component = (n_dot_h2 - 1.0) / (a2 * n_dot_h2);\\n      return part_a * exp(exp_component);\\n\\t\\t}\\n\\t\\tfloat distribution_ggx(vec3 N, vec3 H, float roughness) {\\n\\t\\t    float a = roughness * roughness;\\n\\t\\t    float a2 = a * a;\\n\\t\\t    float NdotH = max(dot(N, H), 0.0);\\n\\t\\t    float NdotH2 = NdotH * NdotH;\\n\\t\\t    \\n\\t\\t    float denom = (NdotH2 * (a2-1.0) + 1.0);\\n\\t\\t    denom = PI * denom * denom;\\n\\t\\t    \\n\\t\\t    return a2 / denom;\\n\\t\\t}\\n\\t\\t//\\n\\t\\t//  Geometry distribution component (G)\\n\\t\\t//\\n\\t\\tfloat geometry_schlick_ggx(float NdotV, float roughness) {\\n\\t\\t    float r = roughness + 1.0;\\n\\t\\t    //  direct light\\n\\t\\t    float k = (r*r) / 8.0;\\n\\t\\t    //  IBL\\n\\t\\t    //  float k = (roughness * roughness) / 2;\\n\\t\\t    float denom = NdotV * (1.0 - k) + k;\\n\\t\\t    return NdotV / denom;\\n\\t\\t}\\n\\t\\tfloat geometry_smith(vec3 N, vec3 V, vec3 L, float roughness) {\\n\\t\\t    float NdotV = max(dot(N, V), 0.0);\\n\\t\\t    float NdotL = max(dot(N, L), 0.0);\\n\\t\\t    float ggx2 = geometry_schlick_ggx(NdotV, roughness);\\n\\t\\t    float ggx1 = geometry_schlick_ggx(NdotL, roughness);\\n\\t\\t    return ggx1 * ggx2;\\n\\t\\t}\";\n}\nexports.pbrDeclaration = pbrDeclaration;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/library.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/no-light.js":
/*!*************************************************!*\
  !*** ./build/src/gl/shader-builder/no-light.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar __1 = __webpack_require__(/*! .. */ \"./build/src/gl/index.js\");\nvar components = __webpack_require__(/*! ./components */ \"./build/src/gl/shader-builder/components.js\");\nvar common_1 = __webpack_require__(/*! ./common */ \"./build/src/gl/shader-builder/common.js\");\nvar DefaultOutletInputs = makeDefaultInputOutlet(__1.types.DefaultShaderIdentifiers);\nvar DefaultOutletOutputs = makeDefaultOutputOutlet(__1.types.DefaultShaderIdentifiers);\nfunction makeDefaultInputOutlet(identifiers) {\n    return {\n        modelColor: identifiers.temporaries.modelColor\n    };\n}\nexports.makeDefaultInputOutlet = makeDefaultInputOutlet;\nfunction makeDefaultOutputOutlet(identifiers) {\n    return {\n        modelColor: identifiers.temporaries.modelColor\n    };\n}\nexports.makeDefaultOutputOutlet = makeDefaultOutputOutlet;\nfunction makeDefaultInputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    var uniforms = identifiers.uniforms;\n    var makeVar = __1.types.makeGLSLVariable;\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    var defaultSamplerSource = components.makeDefaultSamplerSource(identifiers);\n    return {\n        modelColor: makePlug(makeVar(uniforms.modelColor, 'vec3'), 2 /* Uniform */, defaultSamplerSource)\n    };\n}\nexports.makeDefaultInputPlug = makeDefaultInputPlug;\nfunction makeDefaultOutputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    return {\n        modelColor: __1.types.makeConcreteComponentPlug(identifiers.temporaries.modelColor, 3 /* Temporary */)\n    };\n}\nexports.makeDefaultOutputPlug = makeDefaultOutputPlug;\nfunction applyComponent(toSchema, forMaterial, plugInputs, plugOutputs) {\n    var inputs = DefaultOutletInputs;\n    var outputs = DefaultOutletOutputs;\n    common_1.applyMaterial(plugInputs, forMaterial);\n    common_1.assertConnectSuccess(common_1.connectInputs(toSchema, plugInputs, inputs));\n    common_1.assertConnectSuccess(common_1.connectOutputs(toSchema, plugOutputs, outputs));\n}\nexports.applyComponent = applyComponent;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/no-light.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/phong.js":
/*!**********************************************!*\
  !*** ./build/src/gl/shader-builder/phong.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar __1 = __webpack_require__(/*! .. */ \"./build/src/gl/index.js\");\nvar common_1 = __webpack_require__(/*! ./common */ \"./build/src/gl/shader-builder/common.js\");\nvar components = __webpack_require__(/*! ./components */ \"./build/src/gl/shader-builder/components.js\");\nvar library_1 = __webpack_require__(/*! ./library */ \"./build/src/gl/shader-builder/library.js\");\nvar DefaultOutletInputs = makeDefaultInputOutlet(__1.types.DefaultShaderIdentifiers);\nvar DefaultOutletOutputs = makeDefaultOutputOutlet(__1.types.DefaultShaderIdentifiers);\nvar DefaultStatics = makeDefaultStatics(__1.types.DefaultShaderIdentifiers);\nvar DefaultTemporaries = makeDefaultTemporaries(__1.types.DefaultShaderIdentifiers);\nfunction makeDefaultTemporaries(identifiers) {\n    return {\n        lightContribution: identifiers.temporaries.lightContribution,\n        normalToCamera: identifiers.temporaries.normalToCamera\n    };\n}\nexports.makeDefaultTemporaries = makeDefaultTemporaries;\nfunction makeDefaultStatics(identifiers) {\n    return components.makeDefaultCommonLightStatics(identifiers);\n}\nexports.makeDefaultStatics = makeDefaultStatics;\nfunction makeDefaultInputOutlet(identifiers) {\n    return {\n        ambientConstant: identifiers.temporaries.ambientConstant,\n        diffuseConstant: identifiers.temporaries.diffuseConstant,\n        specularConstant: identifiers.temporaries.specularConstant,\n        specularPower: identifiers.temporaries.specularPower,\n        modelColor: identifiers.temporaries.modelColor,\n        normal: identifiers.temporaries.normal,\n        position: identifiers.temporaries.position\n    };\n}\nexports.makeDefaultInputOutlet = makeDefaultInputOutlet;\nfunction makeDefaultOutputOutlet(identifiers) {\n    return {\n        modelColor: identifiers.temporaries.modelColor\n    };\n}\nexports.makeDefaultOutputOutlet = makeDefaultOutputOutlet;\nfunction makeDefaultInputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    var uniforms = identifiers.uniforms;\n    var varyings = identifiers.varyings;\n    var makeVar = __1.types.makeGLSLVariable;\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    var defaultSamplerSource = components.makeDefaultSamplerSource(identifiers);\n    return {\n        ambientConstant: makePlug(makeVar(uniforms.ambientConstant, 'float'), 2 /* Uniform */, defaultSamplerSource),\n        diffuseConstant: makePlug(makeVar(uniforms.diffuseConstant, 'float'), 2 /* Uniform */, defaultSamplerSource),\n        specularConstant: makePlug(makeVar(uniforms.specularConstant, 'float'), 2 /* Uniform */, defaultSamplerSource),\n        specularPower: makePlug(makeVar(uniforms.specularPower, 'float'), 2 /* Uniform */, defaultSamplerSource),\n        modelColor: makePlug(makeVar(uniforms.modelColor, 'vec3'), 2 /* Uniform */, defaultSamplerSource),\n        normal: makePlug(makeVar(varyings.normal, 'vec3'), 1 /* Varying */),\n        position: makePlug(makeVar(varyings.position, 'vec3'), 1 /* Varying */)\n    };\n}\nexports.makeDefaultInputPlug = makeDefaultInputPlug;\nfunction makeDefaultOutputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    return {\n        modelColor: __1.types.makeConcreteComponentPlug(identifiers.temporaries.modelColor, 3 /* Temporary */)\n    };\n}\nexports.makeDefaultOutputPlug = makeDefaultOutputPlug;\nfunction phongPointLightLoop(inputs, outputs, statics, temporaries) {\n    var maxNumLights = __1.types.ShaderLimits.maxNumUniformPointLights;\n    var lightPos = statics.pointLightPositions.getSource().identifier;\n    var lightColor = statics.pointLightColors.getSource().identifier;\n    var lightFunc = 'phong_point_lighting';\n    var ka = inputs.ambientConstant.identifier;\n    var kd = inputs.diffuseConstant.identifier;\n    var ks = inputs.specularConstant.identifier;\n    var specPower = inputs.specularPower.identifier;\n    var normal = inputs.normal.identifier;\n    var position = inputs.position.identifier;\n    var normToCamera = temporaries.normalToCamera.identifier;\n    return \"\\n  for (int i = 0; i < \" + maxNumLights + \"; i++) {\\n    \" + temporaries.lightContribution.identifier + \" += \" + lightFunc + \"(\" + position + \", \" + normal + \", \\n      \" + lightPos + \"[i], \" + lightColor + \"[i], \\n      \" + normToCamera + \", \" + ka + \", \" + kd + \", \" + ks + \", \" + specPower + \");\\n  }\";\n}\nfunction phongDirectionalLightLoop(inputs, outputs, statics, temporaries) {\n    var maxNumLights = __1.types.ShaderLimits.maxNumUniformDirectionalLights;\n    var lightPos = statics.directionalLightPositions.getSource().identifier;\n    var lightColor = statics.directionalLightColors.getSource().identifier;\n    var lightFunc = 'phong_directional_lighting';\n    var ka = inputs.ambientConstant.identifier;\n    var kd = inputs.diffuseConstant.identifier;\n    var ks = inputs.specularConstant.identifier;\n    var specPower = inputs.specularPower.identifier;\n    var normal = inputs.normal.identifier;\n    var normToCamera = temporaries.normalToCamera.identifier;\n    return \"\\n  for (int i = 0; i < \" + maxNumLights + \"; i++) {\\n    \" + temporaries.lightContribution.identifier + \" += \" + lightFunc + \"(\" + normal + \", \\n      \" + lightPos + \"[i], \" + lightColor + \"[i], \\n      \" + normToCamera + \", \" + ka + \", \" + kd + \", \" + ks + \", \" + specPower + \");\\n  }\";\n}\nfunction normalToCamera(inputs, outputs, statics, temporaries) {\n    var normToCam = temporaries.normalToCamera.identifier;\n    var camPos = statics.cameraPosition.getSource().identifier;\n    var pos = inputs.position.identifier;\n    return normToCam + \" = normalize(\" + camPos + \" - \" + pos + \");\";\n}\nfunction phongLightingBody(inputs, outputs, statics, temporaries) {\n    return \"\\n  \" + inputs.normal.identifier + \" = normalize(\" + inputs.normal.identifier + \");\\n  \" + normalToCamera(inputs, outputs, statics, temporaries) + \"\\n  \" + phongDirectionalLightLoop(inputs, outputs, statics, temporaries) + \"\\n  \" + phongPointLightLoop(inputs, outputs, statics, temporaries) + \";\\n  \" + outputs.modelColor.identifier + \" = \" + temporaries.lightContribution.identifier + \" * \" + inputs.modelColor.identifier + \";\";\n}\nfunction applyComponent(toSchema, forMaterial, plugInputs, plugOutputs) {\n    var inputs = DefaultOutletInputs;\n    var outputs = DefaultOutletOutputs;\n    var statics = DefaultStatics;\n    var temporaries = DefaultTemporaries;\n    common_1.applyMaterial(plugInputs, forMaterial);\n    common_1.assertConnectSuccess(common_1.connectInputs(toSchema, plugInputs, inputs));\n    common_1.requireTemporaries(toSchema, temporaries);\n    common_1.requireStatics(toSchema, statics);\n    toSchema.head.push(library_1.phongDirectionalLightingDeclaration);\n    toSchema.head.push(library_1.phongPointLightingDeclaration);\n    toSchema.body.push(function () { return phongLightingBody(inputs, outputs, statics, temporaries); });\n    common_1.assertConnectSuccess(common_1.connectOutputs(toSchema, plugOutputs, outputs));\n}\nexports.applyComponent = applyComponent;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/phong.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/physical.js":
/*!*************************************************!*\
  !*** ./build/src/gl/shader-builder/physical.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar __1 = __webpack_require__(/*! .. */ \"./build/src/gl/index.js\");\nvar components = __webpack_require__(/*! ./components */ \"./build/src/gl/shader-builder/components.js\");\nvar common_1 = __webpack_require__(/*! ./common */ \"./build/src/gl/shader-builder/common.js\");\nvar library_1 = __webpack_require__(/*! ./library */ \"./build/src/gl/shader-builder/library.js\");\nvar DefaultPhysicalOutletInputs = makeDefaultInputOutlet(__1.types.DefaultShaderIdentifiers);\nvar DefaultPhysicalOutletOutputs = makeDefaultOutputOutlet(__1.types.DefaultShaderIdentifiers);\nvar DefaultPhysicalStatics = makeDefaultStatics(__1.types.DefaultShaderIdentifiers);\nvar DefaultPhysicalTemporaries = makeDefaultTemporaries(__1.types.DefaultShaderIdentifiers);\nfunction makeDefaultTemporaries(identifiers) {\n    return {\n        lightContribution: identifiers.temporaries.lightContribution\n    };\n}\nexports.makeDefaultTemporaries = makeDefaultTemporaries;\nfunction makeDefaultStatics(identifiers) {\n    return components.makeDefaultCommonLightStatics(identifiers);\n}\nexports.makeDefaultStatics = makeDefaultStatics;\nfunction makeDefaultInputOutlet(identifiers) {\n    return {\n        roughness: identifiers.temporaries.roughness,\n        metallic: identifiers.temporaries.metallic,\n        ambientConstant: identifiers.temporaries.ambientConstant,\n        modelColor: identifiers.temporaries.modelColor,\n        normal: identifiers.temporaries.normal,\n        position: identifiers.temporaries.position\n    };\n}\nexports.makeDefaultInputOutlet = makeDefaultInputOutlet;\nfunction makeDefaultOutputOutlet(identifiers) {\n    return {\n        modelColor: identifiers.temporaries.modelColor\n    };\n}\nexports.makeDefaultOutputOutlet = makeDefaultOutputOutlet;\nfunction makeDefaultInputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    var uniforms = identifiers.uniforms;\n    var varyings = identifiers.varyings;\n    var makeVar = __1.types.makeGLSLVariable;\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    var defaultSamplerSource = components.makeDefaultSamplerSource(identifiers);\n    return {\n        roughness: makePlug(makeVar(uniforms.roughness, 'float'), 2 /* Uniform */, defaultSamplerSource),\n        metallic: makePlug(makeVar(uniforms.metallic, 'float'), 2 /* Uniform */, defaultSamplerSource),\n        ambientConstant: makePlug(makeVar(uniforms.ambientConstant, 'float'), 2 /* Uniform */, defaultSamplerSource),\n        modelColor: makePlug(makeVar(uniforms.modelColor, 'vec3'), 2 /* Uniform */, defaultSamplerSource),\n        normal: makePlug(makeVar(varyings.normal, 'vec3'), 1 /* Varying */),\n        position: makePlug(makeVar(varyings.position, 'vec3'), 1 /* Varying */)\n    };\n}\nexports.makeDefaultInputPlug = makeDefaultInputPlug;\nfunction makeDefaultOutputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    return {\n        modelColor: __1.types.makeConcreteComponentPlug(identifiers.temporaries.modelColor, 3 /* Temporary */)\n    };\n}\nexports.makeDefaultOutputPlug = makeDefaultOutputPlug;\nfunction physicalPointLightLoop(inputs, outputs, statics, temporaries) {\n    var maxNumLights = __1.types.ShaderLimits.maxNumUniformPointLights;\n    return \"\\n  for (int i = 0; i < \" + maxNumLights + \"; i++) {\\n    \" + temporaries.lightContribution.identifier + \" += PBR(\\n      \" + inputs.normal.identifier + \",\\n      \" + inputs.modelColor.identifier + \",\\n      \" + inputs.roughness.identifier + \",\\n      \" + inputs.metallic.identifier + \",\\n      \" + statics.cameraPosition.getSource().identifier + \",\\n      \" + inputs.position.identifier + \",\\n      \" + statics.pointLightPositions.getSource().identifier + \"[i],\\n      \" + statics.pointLightColors.getSource().identifier + \"[i],\\n      false);\\n  }\";\n}\nfunction physicalDirectionalLightLoop(inputs, outputs, statics, temporaries) {\n    var maxNumLights = __1.types.ShaderLimits.maxNumUniformDirectionalLights;\n    return \"\\n  for (int i = 0; i < \" + maxNumLights + \"; i++) {\\n    \" + temporaries.lightContribution.identifier + \" += PBR(\\n      \" + inputs.normal.identifier + \",\\n      \" + inputs.modelColor.identifier + \",\\n      \" + inputs.roughness.identifier + \",\\n      \" + inputs.metallic.identifier + \",\\n      \" + statics.cameraPosition.getSource().identifier + \",\\n      \" + inputs.position.identifier + \",\\n      \" + statics.directionalLightPositions.getSource().identifier + \"[i],\\n      \" + statics.directionalLightColors.getSource().identifier + \"[i],\\n      true);\\n  }\";\n}\nfunction physicalFragmentLightingBody(inputs, outputs, statics, temporaries) {\n    var lightContrib = temporaries.lightContribution.identifier;\n    var ambientConstant = inputs.ambientConstant.identifier;\n    var inputModelColor = inputs.modelColor.identifier;\n    var outputModelColor = outputs.modelColor.identifier;\n    return \"\\n  \" + inputs.normal.identifier + \" = normalize(\" + inputs.normal.identifier + \");\\n  \" + physicalPointLightLoop(inputs, outputs, statics, temporaries) + \"\\n  \" + physicalDirectionalLightLoop(inputs, outputs, statics, temporaries) + \"\\n  \" + outputModelColor + \" = \" + lightContrib + \" + \" + ambientConstant + \" * \" + inputModelColor + \";\\n  \" + outputModelColor + \" = \" + outputModelColor + \" / (\" + outputModelColor + \" + vec3(1.0));\\n  \" + outputModelColor + \" = pow(\" + outputModelColor + \", vec3(1.0/2.2));\";\n}\nfunction applyComponent(toSchema, forMaterial, plugInputs, plugOutputs) {\n    var inputs = DefaultPhysicalOutletInputs;\n    var outputs = DefaultPhysicalOutletOutputs;\n    var statics = DefaultPhysicalStatics;\n    var temporaries = DefaultPhysicalTemporaries;\n    common_1.applyMaterial(plugInputs, forMaterial);\n    common_1.assertConnectSuccess(common_1.connectInputs(toSchema, plugInputs, inputs));\n    common_1.requireTemporaries(toSchema, temporaries);\n    common_1.requireStatics(toSchema, statics);\n    toSchema.head.push(library_1.pbrDeclaration);\n    toSchema.body.push(function () { return physicalFragmentLightingBody(inputs, outputs, statics, temporaries); });\n    common_1.assertConnectSuccess(common_1.connectOutputs(toSchema, plugOutputs, outputs));\n}\nexports.applyComponent = applyComponent;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/physical.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/projective-position.js":
/*!************************************************************!*\
  !*** ./build/src/gl/shader-builder/projective-position.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar __1 = __webpack_require__(/*! .. */ \"./build/src/gl/index.js\");\nvar common_1 = __webpack_require__(/*! ./common */ \"./build/src/gl/shader-builder/common.js\");\nvar DefaultStatics = makeDefaultStatics(__1.types.DefaultShaderIdentifiers);\nvar DefaultOutletInputs = makeDefaultInputOutlet(__1.types.DefaultShaderIdentifiers);\nvar DefaultOutletOutputs = makeDefaultOutputOutlet(__1.types.DefaultShaderIdentifiers);\nfunction makeDefaultStatics(identifiers) {\n    var makeVar = __1.types.makeGLSLVariable;\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    return {\n        view: makePlug(makeVar(identifiers.uniforms.view, 'mat4'), 2 /* Uniform */),\n        projection: makePlug(makeVar(identifiers.uniforms.projection, 'mat4'), 2 /* Uniform */)\n    };\n}\nexports.makeDefaultStatics = makeDefaultStatics;\nfunction makeDefaultInputOutlet(identifiers) {\n    return {\n        position: __1.types.makeGLSLVariable(identifiers.temporaries.projectivePosition.identifier, 'vec4')\n    };\n}\nexports.makeDefaultInputOutlet = makeDefaultInputOutlet;\nfunction makeDefaultOutputOutlet(identifiers) {\n    return {\n        position: __1.types.makeGLSLVariable(identifiers.temporaries.projectivePosition.identifier, 'vec4')\n    };\n}\nexports.makeDefaultOutputOutlet = makeDefaultOutputOutlet;\nfunction makeDefaultInputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    var temporaries = identifiers.temporaries;\n    var makeVar = __1.types.makeGLSLVariable;\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    return {\n        position: makePlug(makeVar(temporaries.worldPosition.identifier, 'vec4'), 3 /* Temporary */)\n    };\n}\nexports.makeDefaultInputPlug = makeDefaultInputPlug;\nfunction makeDefaultOutputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    var makeVar = __1.types.makeGLSLVariable;\n    return {\n        position: makePlug(makeVar(identifiers.temporaries.projectivePosition.identifier, 'vec4'), 3 /* Temporary */)\n    };\n}\nexports.makeDefaultOutputPlug = makeDefaultOutputPlug;\nfunction projectivePositionBody(inputs, outputs, statics) {\n    var outPos = outputs.position.identifier;\n    var inPos = inputs.position.identifier;\n    var view = statics.view.getSource().identifier;\n    var projection = statics.projection.getSource().identifier;\n    return outPos + \" = \" + projection + \" * \" + view + \" * \" + inPos + \";\";\n}\nfunction applyComponent(toSchema, plugInputs, plugOutputs) {\n    var inputs = DefaultOutletInputs;\n    var outputs = DefaultOutletOutputs;\n    var statics = DefaultStatics;\n    common_1.assertConnectSuccess(common_1.connectInputs(toSchema, plugInputs, inputs));\n    common_1.requireStatics(toSchema, statics);\n    toSchema.body.push(function () { return projectivePositionBody(inputs, outputs, statics); });\n    common_1.assertConnectSuccess(common_1.connectOutputs(toSchema, plugOutputs, outputs));\n}\nexports.applyComponent = applyComponent;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/projective-position.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/vertex-position.js":
/*!********************************************************!*\
  !*** ./build/src/gl/shader-builder/vertex-position.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar __1 = __webpack_require__(/*! .. */ \"./build/src/gl/index.js\");\nvar common_1 = __webpack_require__(/*! ./common */ \"./build/src/gl/shader-builder/common.js\");\nvar DefaultOutletInputs = makeDefaultInputOutlet(__1.types.DefaultShaderIdentifiers);\nfunction makeDefaultInputOutlet(identifiers) {\n    return {\n        position: __1.types.makeGLSLVariable(identifiers.temporaries.projectivePosition.identifier, 'vec4')\n    };\n}\nexports.makeDefaultInputOutlet = makeDefaultInputOutlet;\nfunction makeDefaultInputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    var temporaries = identifiers.temporaries;\n    var makeVar = __1.types.makeGLSLVariable;\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    return {\n        position: makePlug(makeVar(temporaries.projectivePosition.identifier, 'vec4'), 3 /* Temporary */)\n    };\n}\nexports.makeDefaultInputPlug = makeDefaultInputPlug;\nfunction vertexPositionBody(inputs) {\n    return \"gl_Position = \" + inputs.position.identifier + \";\";\n}\nfunction applyComponent(toSchema, plugInputs) {\n    var inputs = DefaultOutletInputs;\n    common_1.assertConnectSuccess(common_1.connectInputs(toSchema, plugInputs, inputs));\n    toSchema.body.push(function () { return vertexPositionBody(inputs); });\n}\nexports.applyComponent = applyComponent;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/vertex-position.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/world-normal.js":
/*!*****************************************************!*\
  !*** ./build/src/gl/shader-builder/world-normal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar __1 = __webpack_require__(/*! .. */ \"./build/src/gl/index.js\");\nvar common_1 = __webpack_require__(/*! ./common */ \"./build/src/gl/shader-builder/common.js\");\nvar DefaultStatics = makeDefaultStatics(__1.types.DefaultShaderIdentifiers);\nvar DefaultOutletInputs = makeDefaultInputOutlet(__1.types.DefaultShaderIdentifiers);\nvar DefaultOutletOutputs = makeDefaultOutputOutlet(__1.types.DefaultShaderIdentifiers);\nfunction makeDefaultStatics(identifiers) {\n    var makeVar = __1.types.makeGLSLVariable;\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    return {\n        inverseTransposeModel: makePlug(makeVar(identifiers.uniforms.inverseTransposeModel, 'mat4'), 2 /* Uniform */)\n    };\n}\nexports.makeDefaultStatics = makeDefaultStatics;\nfunction makeDefaultInputOutlet(identifiers) {\n    return {\n        normal: __1.types.makeGLSLVariable(identifiers.attributes.normal, 'vec3')\n    };\n}\nexports.makeDefaultInputOutlet = makeDefaultInputOutlet;\nfunction makeDefaultOutputOutlet(identifiers) {\n    return {\n        normal: __1.types.makeGLSLVariable(identifiers.varyings.normal, 'vec3')\n    };\n}\nexports.makeDefaultOutputOutlet = makeDefaultOutputOutlet;\nfunction makeDefaultInputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    var attributes = identifiers.attributes;\n    var makeVar = __1.types.makeGLSLVariable;\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    return {\n        normal: makePlug(makeVar(attributes.normal, 'vec3'), 0 /* Attribute */)\n    };\n}\nexports.makeDefaultInputPlug = makeDefaultInputPlug;\nfunction makeDefaultOutputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    var makeVar = __1.types.makeGLSLVariable;\n    return {\n        normal: makePlug(makeVar(identifiers.varyings.normal, 'vec3'), 1 /* Varying */)\n    };\n}\nexports.makeDefaultOutputPlug = makeDefaultOutputPlug;\nfunction worldNormalBody(inputs, outputs, statics) {\n    var outNorm = outputs.normal.identifier;\n    var inNorm = inputs.normal.identifier;\n    var model = statics.inverseTransposeModel.getSource().identifier;\n    return outNorm + \" = mat3(\" + model + \") * \" + inNorm + \";\";\n}\nfunction applyComponent(toSchema, plugInputs, plugOutputs) {\n    var inputs = DefaultOutletInputs;\n    var outputs = DefaultOutletOutputs;\n    var statics = DefaultStatics;\n    common_1.assertConnectSuccess(common_1.connectInputs(toSchema, plugInputs, inputs));\n    common_1.requireStatics(toSchema, statics);\n    toSchema.body.push(function () { return worldNormalBody(inputs, outputs, statics); });\n    common_1.assertConnectSuccess(common_1.connectOutputs(toSchema, plugOutputs, outputs));\n}\nexports.applyComponent = applyComponent;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/world-normal.js?");

/***/ }),

/***/ "./build/src/gl/shader-builder/world-position.js":
/*!*******************************************************!*\
  !*** ./build/src/gl/shader-builder/world-position.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar __1 = __webpack_require__(/*! .. */ \"./build/src/gl/index.js\");\nvar common_1 = __webpack_require__(/*! ./common */ \"./build/src/gl/shader-builder/common.js\");\nvar DefaultStatics = makeDefaultStatics(__1.types.DefaultShaderIdentifiers);\nvar DefaultOutletInputs = makeDefaultInputOutlet(__1.types.DefaultShaderIdentifiers);\nvar DefaultOutletOutputs = makeDefaultOutputOutlet(__1.types.DefaultShaderIdentifiers);\nfunction makeDefaultStatics(identifiers) {\n    var makeVar = __1.types.makeGLSLVariable;\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    return {\n        model: makePlug(makeVar(identifiers.uniforms.model, 'mat4'), 2 /* Uniform */)\n    };\n}\nexports.makeDefaultStatics = makeDefaultStatics;\nfunction makeDefaultInputOutlet(identifiers) {\n    return {\n        position: __1.types.makeGLSLVariable(identifiers.temporaries.worldPosition.identifier, 'vec4')\n    };\n}\nexports.makeDefaultInputOutlet = makeDefaultInputOutlet;\nfunction makeDefaultOutputOutlet(identifiers) {\n    return {\n        position: __1.types.makeGLSLVariable(identifiers.temporaries.worldPosition.identifier, 'vec4')\n    };\n}\nexports.makeDefaultOutputOutlet = makeDefaultOutputOutlet;\nfunction makeDefaultInputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    var attributes = identifiers.attributes;\n    var makeVar = __1.types.makeGLSLVariable;\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    return {\n        position: makePlug(makeVar(attributes.position, 'vec3'), 0 /* Attribute */)\n    };\n}\nexports.makeDefaultInputPlug = makeDefaultInputPlug;\nfunction makeDefaultOutputPlug(identifiers) {\n    identifiers = common_1.requireIdentifiers(identifiers);\n    var makePlug = __1.types.makeConcreteComponentPlug;\n    var makeVar = __1.types.makeGLSLVariable;\n    return {\n        position: makePlug(makeVar(identifiers.temporaries.worldPosition.identifier, 'vec4'), 3 /* Temporary */)\n    };\n}\nexports.makeDefaultOutputPlug = makeDefaultOutputPlug;\nfunction worldPositionBody(inputs, outputs, statics) {\n    var outPos = outputs.position.identifier;\n    var inPos = inputs.position.identifier;\n    var model = statics.model.getSource().identifier;\n    return outPos + \" = \" + model + \" * \" + inPos + \";\";\n}\nfunction applyComponent(toSchema, plugInputs, plugOutputs) {\n    var inputs = DefaultOutletInputs;\n    var outputs = DefaultOutletOutputs;\n    var statics = DefaultStatics;\n    common_1.assertConnectSuccess(common_1.connectInputs(toSchema, plugInputs, inputs));\n    common_1.requireStatics(toSchema, statics);\n    toSchema.body.push(function () { return worldPositionBody(inputs, outputs, statics); });\n    common_1.assertConnectSuccess(common_1.connectOutputs(toSchema, plugOutputs, outputs));\n}\nexports.applyComponent = applyComponent;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader-builder/world-position.js?");

/***/ }),

/***/ "./build/src/gl/shader.js":
/*!********************************!*\
  !*** ./build/src/gl/shader.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar types = __webpack_require__(/*! ./types */ \"./build/src/gl/types.js\");\nvar Shader = /** @class */ (function () {\n    function Shader(gl, type, source) {\n        this.shader = null;\n        var glType = this.glShaderType(gl, type);\n        var shader = gl.createShader(glType);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            var errInfo = gl.getShaderInfoLog(shader);\n            gl.deleteShader(shader);\n            throw new Error('Failed to compile shader: ' + errInfo);\n        }\n        this.gl = gl;\n        this.shader = shader;\n    }\n    Shader.prototype.attachTo = function (prog) {\n        if (!this.isValid()) {\n            throw new Error('Shader is invalid.');\n        }\n        this.gl.attachShader(prog, this.shader);\n    };\n    Shader.prototype.detachFrom = function (prog) {\n        this.gl.detachShader(prog, this.shader);\n    };\n    Shader.prototype.isValid = function () {\n        return this.shader !== null;\n    };\n    Shader.prototype.dispose = function () {\n        if (this.shader !== null) {\n            this.gl.deleteShader(this.shader);\n            this.shader = null;\n        }\n    };\n    Shader.prototype.glShaderType = function (gl, kind) {\n        if (kind === 0 /* Vertex */) {\n            return gl.VERTEX_SHADER;\n        }\n        else if (kind === 1 /* Fragment */) {\n            return gl.FRAGMENT_SHADER;\n        }\n        else {\n            throw new Error(\"Internal error: Expected Vertex or Fragment shader type; got \" + kind);\n        }\n    };\n    return Shader;\n}());\nexports.Shader = Shader;\n\n\n//# sourceURL=webpack:///./build/src/gl/shader.js?");

/***/ }),

/***/ "./build/src/gl/terrain.js":
/*!*********************************!*\
  !*** ./build/src/gl/terrain.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar math = __webpack_require__(/*! ./math */ \"./build/src/gl/math.js\");\nvar ImageHeightMap = /** @class */ (function () {\n    function ImageHeightMap(image) {\n        if (image.componentType !== 2 /* Uint8 */) {\n            throw new Error('ImageHeightMap requires Uint8 image.');\n        }\n        this.image = image;\n        this.data = image.data;\n        this.min = math.arrayMin(this.data);\n        this.max = math.arrayMax(this.data);\n        this.interpolationExtent = 0;\n    }\n    ImageHeightMap.prototype.setInterpolationExtent = function (extent) {\n        this.interpolationExtent = math.clamp01(extent);\n    };\n    ImageHeightMap.prototype.interpolate = function (xPixel, zPixel, componentIndex) {\n        var interpX = Math.floor((this.image.width - 1) * this.interpolationExtent);\n        var interpZ = Math.floor((this.image.height - 1) * this.interpolationExtent);\n        var minPixelX = math.clamp(xPixel - Math.floor(interpX / 2), 0, this.image.width - 1);\n        var maxPixelX = math.clamp(minPixelX + interpX, 0, this.image.width - 1);\n        var minPixelZ = math.clamp(zPixel - Math.floor(interpZ / 2), 0, this.image.height - 1);\n        var maxPixelZ = math.clamp(zPixel + interpZ, 0, this.image.height - 1);\n        var actualValue = this.getPixelValue(xPixel, zPixel, componentIndex);\n        var iters = 1;\n        for (var i = minPixelX; i < maxPixelX; i++) {\n            for (var j = minPixelZ; j < maxPixelZ; j++) {\n                if (i !== xPixel && j !== zPixel) {\n                    var nearby = this.getPixelValue(i, j, componentIndex);\n                    actualValue = (actualValue * iters + nearby) / ++iters;\n                }\n            }\n        }\n        return actualValue;\n    };\n    ImageHeightMap.prototype.getPixelValue = function (xPixel, zPixel, componentIndex) {\n        var w = this.image.width;\n        var numComponents = this.image.numComponents;\n        return this.data[zPixel * numComponents * w + xPixel * numComponents + componentIndex];\n    };\n    ImageHeightMap.prototype.normalizedValueAtNormalizedXz = function (x, z, componentIndex) {\n        if (this.data.length === 0) {\n            return 0;\n        }\n        var numComponents = this.image.numComponents;\n        if (componentIndex === undefined) {\n            componentIndex = 0;\n        }\n        else {\n            componentIndex = math.clamp(componentIndex, 0, numComponents - 1);\n        }\n        x = math.clamp01(x);\n        z = math.clamp01(z);\n        var xPixel = Math.floor(x * (this.image.width - 1));\n        var zPixel = Math.floor(z * (this.image.height - 1));\n        var value;\n        if (this.interpolationExtent === 0) {\n            value = this.getPixelValue(xPixel, zPixel, componentIndex);\n        }\n        else {\n            value = this.interpolate(xPixel, zPixel, componentIndex);\n        }\n        var result = (value - this.min) / (this.max - this.min);\n        return (isNaN(result) || !isFinite(result)) ? 0 : result;\n    };\n    return ImageHeightMap;\n}());\nexports.ImageHeightMap = ImageHeightMap;\n\n\n//# sourceURL=webpack:///./build/src/gl/terrain.js?");

/***/ }),

/***/ "./build/src/gl/texture.js":
/*!*********************************!*\
  !*** ./build/src/gl/texture.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nexports.__esModule = true;\n;\nvar _TextureSet = /** @class */ (function () {\n    function _TextureSet() {\n        this.textures = new Map();\n    }\n    _TextureSet.prototype.addTexture = function (tex) {\n        this.textures.set(tex.id, tex);\n    };\n    _TextureSet.prototype.removeTexture = function (tex) {\n        this.textures[\"delete\"](tex.id);\n    };\n    _TextureSet.prototype.completeSet = function () {\n        return this.textures.values();\n    };\n    _TextureSet.prototype.useTextures = function (cb) {\n        this.textures.forEach(cb);\n    };\n    _TextureSet.prototype.size = function () {\n        return this.textures.size;\n    };\n    return _TextureSet;\n}());\nvar Texture2DSet = /** @class */ (function (_super) {\n    __extends(Texture2DSet, _super);\n    function Texture2DSet() {\n        return _super.call(this) || this;\n    }\n    return Texture2DSet;\n}(_TextureSet));\nexports.Texture2DSet = Texture2DSet;\nvar Texture2D = /** @class */ (function () {\n    function Texture2D(gl) {\n        this.gl = gl;\n        this.minFilter = gl.NEAREST;\n        this.magFilter = gl.NEAREST;\n        this.wrapS = gl.CLAMP_TO_EDGE;\n        this.wrapT = gl.CLAMP_TO_EDGE;\n        this.level = 0;\n        this.width = 0;\n        this.height = 0;\n        this.border = 0;\n        this.internalFormat = gl.RGBA;\n        this.srcFormat = gl.RGBA;\n        this.srcType = gl.UNSIGNED_BYTE;\n        this.texture = gl.createTexture();\n        this.index = 0;\n        this.data = null;\n        this.id = Texture2D.ID++;\n    }\n    Texture2D.prototype.bind = function () {\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n    };\n    Texture2D.prototype.bindAndConfigure = function () {\n        this.bind();\n        this.configure();\n    };\n    Texture2D.prototype.activate = function () {\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.index);\n    };\n    Texture2D.prototype.activateAndBind = function () {\n        this.activate();\n        this.bind();\n    };\n    Texture2D.prototype.configure = function () {\n        var gl = this.gl;\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.minFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.magFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.wrapS);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.wrapT);\n    };\n    Texture2D.prototype.fillImage = function (data) {\n        var level = this.level;\n        var internalFormat = this.internalFormat;\n        var width = this.width;\n        var height = this.height;\n        var border = this.border;\n        var srcFormat = this.srcFormat;\n        var srcType = this.srcType;\n        var gl = this.gl;\n        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, data);\n    };\n    Texture2D.prototype.fillImageElement = function (data, assignDimensions) {\n        if (assignDimensions === void 0) { assignDimensions = true; }\n        var gl = this.gl;\n        var level = this.level;\n        gl.texImage2D(gl.TEXTURE_2D, level, this.internalFormat, this.srcFormat, this.srcType, data);\n        if (assignDimensions) {\n            this.width = data.width;\n            this.height = data.height;\n        }\n    };\n    Texture2D.prototype.subImage = function (data) {\n        var width = this.width;\n        var height = this.height;\n        var format = this.srcFormat;\n        var type = this.srcType;\n        var gl = this.gl;\n        var level = this.level;\n        gl.texSubImage2D(gl.TEXTURE_2D, level, 0, 0, width, height, format, type, data);\n    };\n    Texture2D.prototype.dispose = function () {\n        this.gl.deleteTexture(this.texture);\n    };\n    Texture2D.prototype.numComponentsPerPixel = function () {\n        switch (this.srcFormat) {\n            case this.gl.LUMINANCE_ALPHA:\n                return 2;\n            case this.gl.ALPHA:\n            case this.gl.LUMINANCE:\n                return 1;\n            case this.gl.RGB:\n                return 3;\n            case this.gl.RGBA:\n                return 4;\n            default:\n                console.warn('Unrecognized source format.');\n                return 0;\n        }\n    };\n    Texture2D.linearRepeatRGBA = function (gl, size) {\n        var tex = new Texture2D(gl);\n        tex.minFilter = gl.LINEAR;\n        tex.magFilter = gl.LINEAR;\n        tex.wrapS = gl.REPEAT;\n        tex.wrapT = gl.REPEAT;\n        tex.internalFormat = gl.RGBA;\n        tex.srcFormat = gl.RGBA;\n        tex.srcType = gl.UNSIGNED_BYTE;\n        tex.level = 0;\n        tex.border = 0;\n        if (size !== undefined) {\n            tex.width = size;\n            tex.height = size;\n        }\n        return tex;\n    };\n    Texture2D.linearRepeatAlpha = function (gl, size) {\n        var tex = new Texture2D(gl);\n        tex.minFilter = gl.LINEAR;\n        tex.magFilter = gl.LINEAR;\n        tex.wrapS = gl.REPEAT;\n        tex.wrapT = gl.REPEAT;\n        tex.internalFormat = gl.ALPHA;\n        tex.srcFormat = gl.ALPHA;\n        tex.srcType = gl.UNSIGNED_BYTE;\n        tex.level = 0;\n        tex.border = 0;\n        tex.width = size;\n        tex.height = size;\n        return tex;\n    };\n    Texture2D.nearestEdgeClampedRGBA = function (gl, size) {\n        var tex = new Texture2D(gl);\n        tex.minFilter = gl.NEAREST;\n        tex.magFilter = gl.NEAREST;\n        tex.wrapS = gl.CLAMP_TO_EDGE;\n        tex.wrapT = gl.CLAMP_TO_EDGE;\n        tex.level = 0;\n        tex.internalFormat = gl.RGBA;\n        tex.width = size;\n        tex.height = size;\n        tex.border = 0;\n        tex.srcFormat = gl.RGBA;\n        tex.srcType = gl.UNSIGNED_BYTE;\n        return tex;\n    };\n    Texture2D.nearestEdgeClampedAlpha = function (gl, size) {\n        var tex = new Texture2D(gl);\n        tex.minFilter = gl.NEAREST;\n        tex.magFilter = gl.NEAREST;\n        tex.wrapS = gl.CLAMP_TO_EDGE;\n        tex.wrapT = gl.CLAMP_TO_EDGE;\n        tex.level = 0;\n        tex.internalFormat = gl.ALPHA;\n        tex.width = size;\n        tex.height = size;\n        tex.border = 0;\n        tex.srcFormat = gl.ALPHA;\n        tex.srcType = gl.UNSIGNED_BYTE;\n        return tex;\n    };\n    Texture2D.ID = 0;\n    return Texture2D;\n}());\nexports.Texture2D = Texture2D;\n\n\n//# sourceURL=webpack:///./build/src/gl/texture.js?");

/***/ }),

/***/ "./build/src/gl/transform.js":
/*!***********************************!*\
  !*** ./build/src/gl/transform.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nvar types = __webpack_require__(/*! ./types */ \"./build/src/gl/types.js\");\nvar Transform = /** @class */ (function () {\n    function Transform() {\n        this.matrix = gl_matrix_1.mat4.create();\n    }\n    Transform.prototype.identity = function () {\n        gl_matrix_1.mat4.identity(this.matrix);\n    };\n    Transform.prototype.translate = function (to) {\n        gl_matrix_1.mat4.translate(this.matrix, this.matrix, to);\n    };\n    Transform.prototype.scale = function (to) {\n        if (types.typeTest.isNumber(to)) {\n            gl_matrix_1.mat4.scale(this.matrix, this.matrix, [to, to, to]);\n        }\n        else {\n            gl_matrix_1.mat4.scale(this.matrix, this.matrix, to);\n        }\n    };\n    return Transform;\n}());\nexports.Transform = Transform;\n\n\n//# sourceURL=webpack:///./build/src/gl/transform.js?");

/***/ }),

/***/ "./build/src/gl/types.js":
/*!*******************************!*\
  !*** ./build/src/gl/types.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nexports.__esModule = true;\nvar _1 = __webpack_require__(/*! . */ \"./build/src/gl/index.js\");\nvar typeTest;\n(function (typeTest) {\n    function isShaderComponentPlug(a) {\n        return a instanceof ShaderComponentPlug;\n    }\n    typeTest.isShaderComponentPlug = isShaderComponentPlug;\n    function isNumber(a) {\n        return typeof a === 'number';\n    }\n    typeTest.isNumber = isNumber;\n    function isArray(a) {\n        return Array.isArray(a);\n    }\n    typeTest.isArray = isArray;\n    function isArrayOfNumber(a) {\n        return isArray(a) && (a.length === 0 || isNumber(a[0]));\n    }\n    typeTest.isArrayOfNumber = isArrayOfNumber;\n    function isTexture2D(a) {\n        return a instanceof _1.Texture2D;\n    }\n    typeTest.isTexture2D = isTexture2D;\n    function isFloat32Array(a) {\n        return a instanceof Float32Array;\n    }\n    typeTest.isFloat32Array = isFloat32Array;\n})(typeTest = exports.typeTest || (exports.typeTest = {}));\n;\nfunction builtinAttributeToIdentifier(attr, identifiers) {\n    if (identifiers === undefined) {\n        identifiers = exports.DefaultShaderIdentifiers;\n    }\n    switch (attr) {\n        case 0 /* Position */:\n            return identifiers.attributes.position;\n        case 1 /* Normal */:\n            return identifiers.attributes.normal;\n        case 2 /* Uv */:\n            return identifiers.attributes.uv;\n        default:\n            console.warn(\"Unhandled attribute: \" + attr + \".\");\n            return '';\n    }\n}\nexports.builtinAttributeToIdentifier = builtinAttributeToIdentifier;\nfunction numComponentsInBuiltinAttribute(attr) {\n    switch (attr) {\n        case 0 /* Position */:\n            return 3;\n        case 1 /* Normal */:\n            return 3;\n        case 2 /* Uv */:\n            return 2;\n        default:\n            console.warn(\"Unhandled attribute: \" + attr + \".\");\n            return 0;\n    }\n}\nexports.numComponentsInBuiltinAttribute = numComponentsInBuiltinAttribute;\nfunction builtinAttributeToDescriptor(gl, attr, identifiers) {\n    var ident = builtinAttributeToIdentifier(attr);\n    var size = numComponentsInBuiltinAttribute(attr);\n    return makeAttribute(ident, gl.FLOAT, size, 0);\n}\nexports.builtinAttributeToDescriptor = builtinAttributeToDescriptor;\nexports.ShaderLimits = {\n    maxNumUniformDirectionalLights: 3,\n    maxNumUniformPointLights: 3\n};\n;\nfunction makeConcreteComponentPlug(source, sourceType, samplerSource) {\n    var plug = new ShaderComponentPlug();\n    plug.setConcreteSource(source, sourceType, samplerSource);\n    return plug;\n}\nexports.makeConcreteComponentPlug = makeConcreteComponentPlug;\nfunction makeTemporaryComponentPlug(source, samplerSource) {\n    var plug = new ShaderComponentPlug();\n    plug.setConcreteSource(source, 3 /* Temporary */, samplerSource);\n    return plug;\n}\nexports.makeTemporaryComponentPlug = makeTemporaryComponentPlug;\nfunction makeAttributeComponentPlug(source, samplerSource) {\n    var plug = new ShaderComponentPlug();\n    plug.setConcreteSource(source, 0 /* Attribute */, samplerSource);\n    return plug;\n}\nexports.makeAttributeComponentPlug = makeAttributeComponentPlug;\nvar ShaderComponentPlug = /** @class */ (function () {\n    function ShaderComponentPlug() {\n        this.id = ShaderComponentPlug.ID++;\n        this.source = null;\n    }\n    ShaderComponentPlug.prototype.connectTo = function (source) {\n        if (this.hasCyclicReference(source)) {\n            throw new Error('Connecting this source would create a cyclic dependency between components.');\n        }\n        source.source = this;\n    };\n    ShaderComponentPlug.prototype.setConcreteSource = function (source, sourceType, samplerSource) {\n        this.source = source;\n        this.sourceType = sourceType;\n        this.samplerSource = samplerSource;\n    };\n    ShaderComponentPlug.prototype.getSource = function () {\n        this.assertHasSource();\n        return this.getRootPlug().source;\n    };\n    ShaderComponentPlug.prototype.getSourceType = function () {\n        this.assertHasSource();\n        return this.getRootPlug().sourceType;\n    };\n    ShaderComponentPlug.prototype.getSamplerSource = function () {\n        this.assertHasSource();\n        return this.getRootPlug().samplerSource;\n    };\n    ShaderComponentPlug.prototype.getRootPlug = function () {\n        var prev = this;\n        var src = this.source;\n        while (ShaderComponentPlug.isShaderComponentPlug(src)) {\n            prev = src;\n            src = src.source;\n        }\n        return prev;\n    };\n    ShaderComponentPlug.prototype.assertHasSource = function () {\n        if (this.source === null) {\n            throw new Error('No source has yet been set.');\n        }\n    };\n    ShaderComponentPlug.isShaderComponentPlug = function (source) {\n        return source instanceof ShaderComponentPlug;\n    };\n    ShaderComponentPlug.prototype.hasCyclicReference = function (source) {\n        var isPlug = ShaderComponentPlug.isShaderComponentPlug;\n        if (!isPlug(source) || !isPlug(this.source)) {\n            return false;\n        }\n        var newSource = source;\n        var selfSource = this.source;\n        var visitedIds = {};\n        while (isPlug(selfSource)) {\n            visitedIds[selfSource.id] = 0;\n            selfSource = selfSource.source;\n        }\n        while (isPlug(newSource)) {\n            if (visitedIds[newSource.id] !== undefined) {\n                return true;\n            }\n            visitedIds[newSource.id] = 0;\n            newSource = newSource.source;\n        }\n        return false;\n    };\n    ShaderComponentPlug.ID = 0;\n    return ShaderComponentPlug;\n}());\nexports.ShaderComponentPlug = ShaderComponentPlug;\nfunction makeDefaultShaderIdentifiers() {\n    return {\n        attributes: {\n            position: 'a_position',\n            normal: 'a_normal',\n            uv: 'a_uv'\n        },\n        varyings: {\n            position: 'v_position',\n            normal: 'v_normal',\n            uv: 'v_uv'\n        },\n        uniforms: {\n            model: 'model',\n            inverseTransposeModel: 'inv_trans_model',\n            view: 'view',\n            projection: 'projection',\n            cameraPosition: 'camera_position',\n            directionalLightColors: 'directional_light_colors',\n            directionalLightPositions: 'directional_light_positions',\n            pointLightColors: 'point_light_colors',\n            pointLightPositions: 'point_light_positions',\n            modelColor: 'model_color',\n            ambientConstant: 'ambient_constant',\n            diffuseConstant: 'diffuse_constant',\n            specularConstant: 'specular_constant',\n            specularPower: 'specular_power',\n            roughness: 'roughness',\n            metallic: 'metallic'\n        },\n        temporaries: {\n            worldPosition: { identifier: 'world_position', type: 'vec4' },\n            projectivePosition: { identifier: 'projective_position', type: 'vec4' },\n            normal: { identifier: 'normal', type: 'vec3' },\n            position: { identifier: 'position', type: 'vec3' },\n            normalToCamera: { identifier: 'normal_to_camera', type: 'vec3' },\n            cameraPosition: { identifier: 'tmp_camera_position', type: 'vec3' },\n            lightContribution: { identifier: 'light_contribution', type: 'vec3' },\n            ambientConstant: { identifier: 'ka', type: 'float' },\n            diffuseConstant: { identifier: 'kd', type: 'float' },\n            specularConstant: { identifier: 'ks', type: 'float' },\n            specularPower: { identifier: 'spec_pow', type: 'float' },\n            modelColor: { identifier: 'use_color', type: 'vec3' },\n            fragColor: { identifier: 'frag_color', type: 'vec4' },\n            uv: { identifier: 'uv', type: 'vec2' },\n            roughness: { identifier: 'tmp_roughness', type: 'float' },\n            metallic: { identifier: 'tmp_metallic', type: 'float' },\n            directionalLightPositions: { identifier: 'tmp_directional_light_pos', type: 'vec3', isArray: true, arraySize: exports.ShaderLimits.maxNumUniformDirectionalLights },\n            directionalLightColors: { identifier: 'tmp_directional_light_color', type: 'vec3', isArray: true, arraySize: exports.ShaderLimits.maxNumUniformDirectionalLights },\n            pointLightPositions: { identifier: 'tmp_point_light_pos', type: 'vec3', isArray: true, arraySize: exports.ShaderLimits.maxNumUniformPointLights },\n            pointLightColors: { identifier: 'tmp_point_light_colors', type: 'vec3', isArray: true, arraySize: exports.ShaderLimits.maxNumUniformPointLights }\n        }\n    };\n}\nexports.makeDefaultShaderIdentifiers = makeDefaultShaderIdentifiers;\nexports.DefaultShaderIdentifiers = makeDefaultShaderIdentifiers();\n;\n;\nvar UniformValue = /** @class */ (function () {\n    function UniformValue(identifier, value, type, channels) {\n        this.identifier = identifier;\n        this.value = value;\n        this.type = type;\n        this.channels = channels;\n        this.typeChanged = true;\n        this.allowNewType = true;\n    }\n    UniformValue.prototype.isTexture = function () {\n        return this.type === 'sampler2D';\n    };\n    UniformValue.prototype.isNewType = function () {\n        return this.typeChanged;\n    };\n    UniformValue.prototype.clearIsNewType = function () {\n        this.typeChanged = false;\n    };\n    UniformValue.prototype.disallowNewType = function () {\n        this.allowNewType = false;\n        return this;\n    };\n    UniformValue.prototype.set = function (to, numChannels) {\n        var newType = glslTypeFromUniformSettableValue(to);\n        var isNewType = this.type !== newType;\n        if (isNewType && !this.allowNewType) {\n            console.error(\"Cannot overwrite value of original type \\\"\" + this.type + \"\\\" with value of new type \\\"\" + newType + \"\\\".\");\n        }\n        this.typeChanged = isNewType;\n        this.value = to;\n        this.type = newType;\n        if (numChannels !== undefined) {\n            this.channels = numChannels;\n        }\n    };\n    return UniformValue;\n}());\nexports.UniformValue = UniformValue;\n;\nfunction makeUniformValue(name, value, type, channels) {\n    return new UniformValue(name, value, type, channels);\n}\nexports.makeUniformValue = makeUniformValue;\nfunction makeUniformFloatValue(name, value) {\n    return new UniformValue(name, value, 'float');\n}\nexports.makeUniformFloatValue = makeUniformFloatValue;\nfunction makeUniformFloat3Value(name, value) {\n    return new UniformValue(name, value, 'vec3');\n}\nexports.makeUniformFloat3Value = makeUniformFloat3Value;\n;\nfunction isGLSLVector(type) {\n    switch (type) {\n        case 'vec2':\n        case 'vec3':\n        case 'vec4':\n            return true;\n        default:\n            return false;\n    }\n}\nexports.isGLSLVector = isGLSLVector;\nfunction makeAnonymousGLSLVariable(type, isArray, arraySize) {\n    return { identifier: '', type: type, isArray: isArray, arraySize: arraySize };\n}\nexports.makeAnonymousGLSLVariable = makeAnonymousGLSLVariable;\nfunction makeGLSLVariable(identifier, type, isArray, arraySize) {\n    return { identifier: identifier, type: type, isArray: isArray, arraySize: arraySize };\n}\nexports.makeGLSLVariable = makeGLSLVariable;\nfunction glslTypeFromAttributeDescriptor(gl, attr) {\n    if (attr.type === gl.FLOAT) {\n        return glslFloatTypeFromNumComponents(attr.size);\n    }\n    else {\n        console.warn(\"Unsupported type: \" + attr.type);\n        return 'float';\n    }\n}\nexports.glslTypeFromAttributeDescriptor = glslTypeFromAttributeDescriptor;\nfunction glslFloatTypeFromNumComponents(numComponents) {\n    switch (numComponents) {\n        case 1:\n            return 'float';\n        case 2:\n            return 'vec2';\n        case 3:\n            return 'vec3';\n        case 4:\n            return 'vec4';\n        default:\n            console.warn(\"Unsupported size: \" + numComponents);\n            return 'float';\n    }\n}\nexports.glslFloatTypeFromNumComponents = glslFloatTypeFromNumComponents;\nfunction glslTypeFromUniformSettableValue(value) {\n    if (typeTest.isNumber(value)) {\n        return 'float';\n    }\n    else if (typeTest.isTexture2D(value)) {\n        return 'sampler2D';\n    }\n    else if (typeTest.isArrayOfNumber(value) || typeTest.isFloat32Array(value)) {\n        if (value.length === 0) {\n            console.error('Empty array ???');\n            return 'float';\n        }\n        else if (value.length === 1) {\n            return 'float';\n        }\n        else if (value.length === 2) {\n            return 'vec2';\n        }\n        else if (value.length === 3) {\n            return 'vec3';\n        }\n        else if (value.length === 4) {\n            return 'vec4';\n        }\n        else if (value.length === 9) {\n            return 'mat3';\n        }\n        else {\n            return 'mat4';\n        }\n    }\n    else {\n        console.error('No known GLSL type for value: ' + value);\n        return 'float';\n    }\n}\nexports.glslTypeFromUniformSettableValue = glslTypeFromUniformSettableValue;\nfunction componentTypeFromGLSLType(gl, type) {\n    switch (type) {\n        case 'float':\n        case 'vec2':\n        case 'vec3':\n        case 'vec4':\n        case 'mat2':\n        case 'mat3':\n        case 'mat4':\n            return gl.FLOAT;\n        case 'sampler2D':\n            return gl.INT;\n        default:\n            console.warn(\"No registered component type for \" + type + \".\");\n            return gl.FLOAT;\n    }\n}\nexports.componentTypeFromGLSLType = componentTypeFromGLSLType;\nfunction numComponentsInGLSLType(type) {\n    switch (type) {\n        case 'float':\n        case 'sampler2D':\n            return 1;\n        case 'vec2':\n            return 2;\n        case 'vec3':\n            return 3;\n        case 'vec4':\n            return 4;\n        case 'mat2':\n            return 4;\n        case 'mat3':\n            return 9;\n        case 'mat4':\n            return 16;\n        default:\n            console.warn(\"No known component number for \" + type + \".\");\n            return 1;\n    }\n}\nexports.numComponentsInGLSLType = numComponentsInGLSLType;\nfunction makeAttributeWithGLSLType(gl, name, type, divisor) {\n    return { name: name, type: componentTypeFromGLSLType(gl, type), size: numComponentsInGLSLType(type), divisor: divisor };\n}\nexports.makeAttributeWithGLSLType = makeAttributeWithGLSLType;\nfunction makeAttribute(name, type, size, divisor) {\n    return { name: name, type: type, size: size, divisor: divisor };\n}\nexports.makeAttribute = makeAttribute;\nfunction makeFloatAttribute(gl, name, size, divisor) {\n    return makeAttribute(name, gl.FLOAT, size, divisor);\n}\nexports.makeFloatAttribute = makeFloatAttribute;\nfunction makeFloat2Attribute(gl, name, divisor) {\n    return makeFloatAttribute(gl, name, 2, divisor);\n}\nexports.makeFloat2Attribute = makeFloat2Attribute;\nfunction makeFloat3Attribute(gl, name, divisor) {\n    return makeFloatAttribute(gl, name, 3, divisor);\n}\nexports.makeFloat3Attribute = makeFloat3Attribute;\nfunction makeVboDescriptor(name, attributes, data, drawType) {\n    return { name: name, attributes: attributes, data: data, drawType: drawType };\n}\nexports.makeVboDescriptor = makeVboDescriptor;\nfunction makeAnonymousVboDescriptor(attributes, data, drawType) {\n    var useName = attributes.length === 0 ? 'a' : attributes[0].name;\n    return { name: useName, attributes: attributes, data: data, drawType: drawType };\n}\nexports.makeAnonymousVboDescriptor = makeAnonymousVboDescriptor;\nfunction makeAnonymousEboDescriptor(indices) {\n    return { name: 'indices', indices: indices };\n}\nexports.makeAnonymousEboDescriptor = makeAnonymousEboDescriptor;\nfunction makeEboDescriptor(name, indices) {\n    return { name: name, indices: indices };\n}\nexports.makeEboDescriptor = makeEboDescriptor;\nvar BufferDescriptor = /** @class */ (function () {\n    function BufferDescriptor() {\n        this.attributes = [];\n    }\n    BufferDescriptor.prototype.getAttributes = function () {\n        return this.attributes.slice();\n    };\n    BufferDescriptor.prototype.getAttributeLocations = function (prog) {\n        for (var i = 0; i < this.attributes.length; i++) {\n            this.attributes[i].location = prog.getAttributeLocation(this.attributes[i].name);\n        }\n    };\n    BufferDescriptor.prototype.addAttribute = function (attr) {\n        if (this.attributes.length > 0 && this.attributes[0].type !== attr.type) {\n            throw new Error('Attribute types must match between attributes.');\n        }\n        this.attributes.push(attr);\n    };\n    BufferDescriptor.prototype.numComponents = function () {\n        var sz = 0;\n        for (var i = 0; i < this.attributes.length; i++) {\n            sz += this.attributes[i].size;\n        }\n        return sz;\n    };\n    return BufferDescriptor;\n}());\nexports.BufferDescriptor = BufferDescriptor;\nvar ShaderSchema = /** @class */ (function () {\n    function ShaderSchema(type) {\n        this.type = type;\n        this.version = '';\n        this.precision = 'highp';\n        this.attributes = [];\n        this.varyings = [];\n        this.uniforms = [];\n        this.temporaries = [];\n        this.head = [];\n        this.body = [];\n    }\n    ShaderSchema.prototype.hasIdentifierLinearSearch = function (name, inArr) {\n        for (var i = 0; i < inArr.length; i++) {\n            if (inArr[i].identifier === name) {\n                return true;\n            }\n        }\n        return false;\n    };\n    ShaderSchema.prototype.hasVarying = function (name) {\n        return this.hasIdentifierLinearSearch(name, this.varyings);\n    };\n    ShaderSchema.prototype.hasUniform = function (name) {\n        return this.hasIdentifierLinearSearch(name, this.uniforms);\n    };\n    ShaderSchema.prototype.hasAttribute = function (name) {\n        return this.hasIdentifierLinearSearch(name, this.attributes);\n    };\n    ShaderSchema.prototype.hasTemporary = function (name) {\n        return this.hasIdentifierLinearSearch(name, this.temporaries);\n    };\n    ShaderSchema.prototype.hasStatic = function (name) {\n        return this.hasVarying(name) || this.hasUniform(name) || this.hasAttribute(name);\n    };\n    ShaderSchema.prototype.addUniform = function (value) {\n        this.uniforms.push(value);\n        return this;\n    };\n    ShaderSchema.prototype.addVarying = function (value) {\n        this.varyings.push(value);\n        return this;\n    };\n    ShaderSchema.prototype.addAttribute = function (value) {\n        this.attributes.push(value);\n        return this;\n    };\n    ShaderSchema.prototype.requireTemporaryIfNotStatic = function (value) {\n        if (!this.hasStatic(value.identifier)) {\n            this.requireTemporary(value);\n        }\n        return this;\n    };\n    ShaderSchema.prototype.requireTemporary = function (value) {\n        if (!this.hasTemporary(value.identifier)) {\n            this.temporaries.push(value);\n        }\n        return this;\n    };\n    ShaderSchema.prototype.requireAttribute = function (value) {\n        if (!this.hasAttribute(value.identifier)) {\n            this.addAttribute(value);\n        }\n        return this;\n    };\n    ShaderSchema.prototype.requireVarying = function (value) {\n        if (!this.hasVarying(value.identifier)) {\n            this.addVarying(value);\n        }\n        return this;\n    };\n    ShaderSchema.prototype.requireUniform = function (value) {\n        if (!this.hasUniform(value.identifier)) {\n            this.addUniform(value);\n        }\n        return this;\n    };\n    ShaderSchema.prototype.requireInput = function (value) {\n        switch (this.type) {\n            case 0 /* Vertex */:\n                this.requireAttribute(value);\n                break;\n            case 1 /* Fragment */:\n                this.requireVarying(value);\n                break;\n        }\n        return this;\n    };\n    ShaderSchema.prototype.requireOutput = function (value) {\n        switch (this.type) {\n            case 0 /* Vertex */:\n                this.requireVarying(value);\n                break;\n            case 1 /* Fragment */:\n                console.error(\"Fragment shader outputs are not supported. Ignoring \\\"\" + value.identifier + \"\\\".\");\n                break;\n        }\n        return this;\n    };\n    ShaderSchema.prototype.requireBySourceType = function (value, type) {\n        switch (type) {\n            case 0 /* Attribute */:\n                this.requireAttribute(value);\n                break;\n            case 1 /* Varying */:\n                this.requireVarying(value);\n                break;\n            case 2 /* Uniform */:\n                this.requireUniform(value);\n                break;\n            case 3 /* Temporary */:\n                this.requireTemporary(value);\n        }\n        return this;\n    };\n    ShaderSchema.prototype.addAttributeFromAttributeDescriptor = function (gl, attr) {\n        this.attributes.push({ identifier: attr.name, type: glslTypeFromAttributeDescriptor(gl, attr) });\n        return this;\n    };\n    ShaderSchema.prototype.addAttributesFromVboDescriptor = function (gl, descriptor) {\n        for (var i = 0; i < descriptor.attributes.length; i++) {\n            this.addAttributeFromAttributeDescriptor(gl, descriptor.attributes[i]);\n        }\n        return this;\n    };\n    ShaderSchema.prototype.addAttributesFromVboDescriptors = function (gl, descriptors) {\n        for (var i = 0; i < descriptors.length; i++) {\n            this.addAttributesFromVboDescriptor(gl, descriptors[i]);\n        }\n        return this;\n    };\n    ShaderSchema.Vertex = function () {\n        return new ShaderSchema(0 /* Vertex */);\n    };\n    ShaderSchema.Fragment = function () {\n        return new ShaderSchema(1 /* Fragment */);\n    };\n    return ShaderSchema;\n}());\nexports.ShaderSchema = ShaderSchema;\n;\nvar DrawableBase = /** @class */ (function () {\n    function DrawableBase(renderContext, drawFunction) {\n        this.renderContext = renderContext;\n        this.drawFunction = drawFunction;\n    }\n    return DrawableBase;\n}());\nvar DrawFunctions;\n(function (DrawFunctions) {\n    function indexed(rc, drawable) {\n        rc.gl.drawElements(drawable.mode, drawable.count, drawable.type, drawable.offset);\n    }\n    DrawFunctions.indexed = indexed;\n    function arrays(rc, drawable) {\n        rc.gl.drawArrays(drawable.mode, drawable.offset, drawable.count);\n    }\n    DrawFunctions.arrays = arrays;\n    function indexedInstanced(rc, drawable) {\n        rc.extInstancedArrays.drawElementsInstancedANGLE(drawable.mode, drawable.count, drawable.type, drawable.offset, drawable.numActiveInstances);\n    }\n    DrawFunctions.indexedInstanced = indexedInstanced;\n    function arraysInstanced(rc, drawable) {\n        rc.extInstancedArrays.drawArraysInstancedANGLE(drawable.mode, drawable.offset, drawable.count, drawable.numActiveInstances);\n    }\n    DrawFunctions.arraysInstanced = arraysInstanced;\n})(DrawFunctions = exports.DrawFunctions || (exports.DrawFunctions = {}));\nvar Drawable = /** @class */ (function (_super) {\n    __extends(Drawable, _super);\n    function Drawable(renderContext, vao, drawFunction) {\n        var _this = _super.call(this, renderContext, drawFunction) || this;\n        _this.vao = vao;\n        _this.mode = renderContext.gl.TRIANGLES;\n        _this.count = 0;\n        _this.type = renderContext.gl.UNSIGNED_SHORT;\n        _this.offset = 0;\n        _this.isInstanced = false;\n        _this.numActiveInstances = 0;\n        return _this;\n    }\n    Drawable.prototype.draw = function () {\n        this.drawFunction(this.renderContext, this);\n    };\n    Drawable.prototype.assignPropsIfDefined = function (mode, count, type, offset, isInstanced, numActiveInstances) {\n        if (mode !== undefined) {\n            this.mode = mode;\n        }\n        if (count !== undefined) {\n            this.count = count;\n        }\n        if (type !== undefined) {\n            this.type = type;\n        }\n        if (offset !== undefined) {\n            this.offset = offset;\n        }\n        if (isInstanced !== undefined) {\n            this.isInstanced = isInstanced;\n        }\n        if (numActiveInstances !== undefined) {\n            this.numActiveInstances = numActiveInstances;\n        }\n    };\n    Drawable.indexed = function (renderContext, vao, numIndices) {\n        var drawFunc = DrawFunctions.indexed;\n        var drawable = Drawable.fromProperties(renderContext, vao, drawFunc);\n        drawable.count = numIndices;\n        return drawable;\n    };\n    Drawable.fromProperties = function (renderContext, vao, drawFunction, mode, count, type, offset, isInstanced, numActiveInstances) {\n        var drawable = new Drawable(renderContext, vao, drawFunction);\n        drawable.assignPropsIfDefined(mode, count, type, offset, isInstanced, numActiveInstances);\n        return drawable;\n    };\n    return Drawable;\n}(DrawableBase));\nexports.Drawable = Drawable;\n;\n\n\n//# sourceURL=webpack:///./build/src/gl/types.js?");

/***/ }),

/***/ "./build/src/gl/vao.js":
/*!*****************************!*\
  !*** ./build/src/gl/vao.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar _1 = __webpack_require__(/*! . */ \"./build/src/gl/index.js\");\nvar Vao = /** @class */ (function () {\n    function Vao(gl) {\n        this.oesVaoExt = null;\n        this.vao = null;\n        var oesVaoExt = gl.getExtension('OES_vertex_array_object');\n        if (oesVaoExt === null) {\n            throw new Error('VAOs are not supported in your browser.');\n        }\n        this.gl = gl;\n        this.oesVaoExt = oesVaoExt;\n        this.vao = oesVaoExt.createVertexArrayOES();\n        this.vbos = {};\n        this.ebos = {};\n        this.id = Vao.ID++;\n    }\n    Vao.prototype.isBound = function () {\n        return this.isBoundState;\n    };\n    Vao.prototype.bind = function () {\n        this.oesVaoExt.bindVertexArrayOES(this.vao);\n        this.isBoundState = true;\n    };\n    Vao.prototype.unbind = function () {\n        this.oesVaoExt.bindVertexArrayOES(null);\n        this.isBoundState = false;\n    };\n    Vao.prototype.getEbo = function (name) {\n        var ebo = this.ebos[name];\n        if (ebo === undefined || !this.ebos.hasOwnProperty(name)) {\n            console.warn(\"No ebo named \\\"\" + name + \"\\\".\");\n            return null;\n        }\n        return ebo;\n    };\n    Vao.prototype.getVbo = function (name) {\n        var vbo = this.vbos[name];\n        if (vbo === undefined || !this.vbos.hasOwnProperty(name)) {\n            console.warn(\"No vbo named \\\"\" + name + \"\\\".\");\n            return null;\n        }\n        return vbo;\n    };\n    Vao.prototype.attachVbo = function (name, vbo) {\n        if (this.vbos.hasOwnProperty(name) && this.vbos[name] !== undefined) {\n            console.warn(\"Vbo named \\\"\" + name + \"\\\" already exists; replacing ...\");\n            this.vbos[name].dispose(this.gl);\n        }\n        this.vbos[name] = vbo;\n    };\n    Vao.prototype.attachEbo = function (name, ebo) {\n        if (this.ebos.hasOwnProperty(name) && this.ebos[name] !== undefined) {\n            console.warn(\"Ebo named \\\"\" + name + \"\\\" already exists; replacing ...\");\n            this.ebos[name].dispose(this.gl);\n        }\n        this.ebos[name] = ebo;\n    };\n    Vao.prototype.dispose = function () {\n        if (this.oesVaoExt !== null && this.vao !== null) {\n            this.oesVaoExt.deleteVertexArrayOES(this.vao);\n            this.vao = null;\n        }\n        for (var vboName in this.vbos) {\n            var vbo = this.vbos[vboName];\n            if (vbo !== undefined) {\n                vbo.dispose(this.gl);\n                this.vbos[vboName] = undefined;\n            }\n        }\n        for (var eboName in this.ebos) {\n            var ebo = this.ebos[eboName];\n            if (ebo !== undefined) {\n                ebo.dispose(this.gl);\n                this.ebos[eboName] = undefined;\n            }\n        }\n    };\n    Vao.fromScalarDescriptors = function (gl, prog, vboDescriptor, eboDescriptor) {\n        return Vao.fromDescriptors(gl, prog, [vboDescriptor], eboDescriptor);\n    };\n    Vao.fromSimpleInterleavedFloatData = function (gl, prog, data, attrs, indices, identifiers) {\n        var attributeDescriptors = [];\n        for (var i = 0; i < attrs.length; i++) {\n            attributeDescriptors.push(_1.types.builtinAttributeToDescriptor(gl, attrs[i], identifiers));\n        }\n        var vboDescriptor = _1.types.makeAnonymousVboDescriptor(attributeDescriptors, data, gl.STATIC_DRAW);\n        var eboDescriptor = undefined;\n        if (indices) {\n            eboDescriptor = _1.types.makeAnonymousEboDescriptor(indices);\n        }\n        return Vao.fromScalarDescriptors(gl, prog, vboDescriptor, eboDescriptor);\n    };\n    Vao.fromDescriptors = function (gl, prog, vboDescriptors, eboDescriptor) {\n        prog.use();\n        var vao = new Vao(gl);\n        vao.bind();\n        for (var i = 0; i < vboDescriptors.length; i++) {\n            var vboDescriptor = vboDescriptors[i];\n            var attributeDescriptors = vboDescriptor.attributes;\n            var vboName = vboDescriptor.name;\n            var vboData = vboDescriptor.data;\n            var bufferDescriptor = new _1.types.BufferDescriptor();\n            for (var j = 0; j < attributeDescriptors.length; j++) {\n                bufferDescriptor.addAttribute(attributeDescriptors[j]);\n            }\n            bufferDescriptor.getAttributeLocations(prog);\n            vao.attachVbo(vboName, new Vbo(gl, bufferDescriptor, vboData));\n        }\n        if (eboDescriptor !== undefined) {\n            vao.attachEbo(eboDescriptor.name, new Ebo(gl, eboDescriptor.indices));\n        }\n        vao.unbind();\n        return vao;\n    };\n    Vao.ID = 0;\n    return Vao;\n}());\nexports.Vao = Vao;\nvar Ebo = /** @class */ (function () {\n    function Ebo(gl, data, drawType) {\n        this.ebo = null;\n        if (drawType === undefined) {\n            drawType = gl.STATIC_DRAW;\n        }\n        var ebo = gl.createBuffer();\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, drawType);\n        this.ebo = ebo;\n    }\n    Ebo.prototype.dispose = function (gl) {\n        if (this.ebo !== null) {\n            gl.deleteBuffer(this.ebo);\n            this.ebo = null;\n        }\n    };\n    return Ebo;\n}());\nexports.Ebo = Ebo;\nvar Vbo = /** @class */ (function () {\n    function Vbo(gl, descriptor, data, drawType) {\n        this.vbo = null;\n        if (drawType === undefined) {\n            drawType = gl.STATIC_DRAW;\n        }\n        var vbo = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n        gl.bufferData(gl.ARRAY_BUFFER, data, drawType);\n        var offset = 0;\n        var numComponents = descriptor.numComponents();\n        var attrs = descriptor.getAttributes();\n        for (var i = 0; i < attrs.length; i++) {\n            var attr = attrs[i];\n            var numBytesForType = this.numBytes(gl, attr.type);\n            var strideBytes = numComponents * numBytesForType;\n            var offsetBytes = offset * numBytesForType;\n            if (attr.location === -1) {\n                console.warn(\"Unknown attribute: \\\"\" + attr.name + \"\\\".\");\n                continue;\n            }\n            gl.vertexAttribPointer(attr.location, attr.size, attr.type, false, strideBytes, offsetBytes);\n            gl.enableVertexAttribArray(attr.location);\n            if (attr.divisor !== undefined) {\n                var ext = gl.getExtension('ANGLE_instanced_arrays');\n                if (!ext) {\n                    gl.deleteBuffer(vbo);\n                    throw new Error(\"Specified a divisor for attribute \\\"\" + attr.name + \"\\\", but instanced arrays are not supported.\");\n                }\n                ext.vertexAttribDivisorANGLE(attr.location, attr.divisor);\n            }\n            offset += attr.size;\n        }\n        this.vbo = vbo;\n        this.dataSize = data.length;\n        this.id = Vbo.ID++;\n    }\n    Vbo.prototype.bind = function (gl) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);\n    };\n    Vbo.prototype.unbind = function (gl) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    };\n    Vbo.prototype.dispose = function (gl) {\n        if (this.vbo !== null) {\n            gl.deleteBuffer(this.vbo);\n            this.vbo = null;\n        }\n    };\n    Vbo.prototype.subData = function (gl, data, byteOffset) {\n        if (byteOffset === void 0) { byteOffset = 0; }\n        var newBytes = data.length * data.BYTES_PER_ELEMENT;\n        var oldBytes = this.dataSize * data.BYTES_PER_ELEMENT;\n        if (newBytes + byteOffset > oldBytes) {\n            throw new Error(\"New data size (\" + (newBytes + byteOffset) + \") is larger than old data size (\" + oldBytes + \").\");\n        }\n        gl.bufferSubData(gl.ARRAY_BUFFER, byteOffset, data);\n    };\n    Vbo.prototype.numBytes = function (gl, type) {\n        switch (type) {\n            case gl.FLOAT:\n                return 4;\n            case gl.BYTE:\n                return 1;\n            case gl.UNSIGNED_BYTE:\n                return 1;\n            default:\n                console.warn(\"Unrecognized gl data type: \" + type + \".\");\n                return 0;\n        }\n    };\n    Vbo.ID = 0;\n    return Vbo;\n}());\nexports.Vbo = Vbo;\n\n\n//# sourceURL=webpack:///./build/src/gl/vao.js?");

/***/ }),

/***/ "./build/src/gl/voxel-grid.js":
/*!************************************!*\
  !*** ./build/src/gl/voxel-grid.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nvar math_1 = __webpack_require__(/*! ./math */ \"./build/src/gl/math.js\");\nvar intersections_1 = __webpack_require__(/*! ./intersections */ \"./build/src/gl/intersections.js\");\nvar VoxelGrid = /** @class */ (function () {\n    function VoxelGrid(pos, gridDimensions, cellDimensions) {\n        this.position = gl_matrix_1.vec3.copy(gl_matrix_1.vec3.create(), pos);\n        this.gridDimensions = gl_matrix_1.vec3.copy(gl_matrix_1.vec3.create(), gridDimensions);\n        this.cellDimensions = gl_matrix_1.vec3.copy(gl_matrix_1.vec3.create(), cellDimensions);\n        this.maxDim = math_1.arrayMax(gridDimensions);\n        this.intersectRay = new math_1.Ray();\n        this.intersectAabb = this.makeAabb(gridDimensions);\n        this.intersectPoint = gl_matrix_1.vec3.create();\n        this.isOccupied = [];\n        this.numFilledCells = 0;\n    }\n    VoxelGrid.prototype.makeAabb = function (gridDims) {\n        return math_1.Aabb.fromValues(0, gridDims[0], 0, gridDims[1], 0, gridDims[2]);\n    };\n    VoxelGrid.prototype.subToInd = function (cell) {\n        var dims = this.gridDimensions;\n        return cell[0] + (cell[1] * dims[0]) + (cell[2] * dims[0] * dims[1]);\n    };\n    VoxelGrid.prototype.getCellCenter = function (out, cellIdx) {\n        for (var i = 0; i < 3; i++) {\n            var minCoord = cellIdx[i] * this.cellDimensions[i] + this.position[i];\n            var halfSz = this.cellDimensions[i] / 2;\n            out[i] = minCoord + halfSz;\n        }\n    };\n    VoxelGrid.prototype.getCellDimensions = function (out) {\n        for (var i = 0; i < 3; i++) {\n            out[i] = this.cellDimensions[i];\n        }\n    };\n    VoxelGrid.prototype.getCellIndexOfComponent = function (component, dim) {\n        if (dim < 0 || dim >= 3) {\n            throw new Error(\"Index \" + dim + \" exceeds 3 dimensions.\");\n        }\n        return Math.floor((component - this.position[dim]) / this.cellDimensions[dim]);\n    };\n    VoxelGrid.prototype.getCellIndexOfPoint = function (outIdx, point) {\n        var pos = this.position;\n        for (var i = 0; i < 3; i++) {\n            outIdx[i] = Math.floor((point[i] - pos[i]) / this.cellDimensions[i]);\n        }\n    };\n    VoxelGrid.prototype.getCellIndexOf3 = function (outIdx, x, y, z) {\n        outIdx[0] = Math.floor((x - this.position[0]) / this.cellDimensions[0]);\n        outIdx[1] = Math.floor((y - this.position[1]) / this.cellDimensions[1]);\n        outIdx[2] = Math.floor((z - this.position[2]) / this.cellDimensions[2]);\n    };\n    VoxelGrid.prototype.getWorldCenter = function (outPoint) {\n        for (var i = 0; i < 3; i++) {\n            var span = this.cellDimensions[i] * this.gridDimensions[i];\n            outPoint[i] = span / 2 + this.position[i];\n        }\n    };\n    VoxelGrid.prototype.isInBoundsVoxelIndex = function (cell) {\n        var gridDims = this.gridDimensions;\n        var ix = cell[0];\n        var iy = cell[1];\n        var iz = cell[2];\n        if (ix < 0 || ix >= gridDims[0] || iy < 0 || iy >= gridDims[1] || iz < 0 || iz >= gridDims[2]) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    VoxelGrid.prototype.countFilled = function () {\n        return this.numFilledCells;\n    };\n    VoxelGrid.prototype.markFilled = function (cell) {\n        var gridDims = this.gridDimensions;\n        var ix = cell[0];\n        var iy = cell[1];\n        var iz = cell[2];\n        if (ix < 0 || ix >= gridDims[0] || iy < 0 || iy >= gridDims[1] || iz < 0 || iz >= gridDims[2]) {\n            console.warn('Attempted to mark an out of bounds cell: ', ix, iy, iz);\n            return;\n        }\n        if (this.isOccupied[ix] === undefined) {\n            this.isOccupied[ix] = [];\n        }\n        if (this.isOccupied[ix][iy] === undefined) {\n            this.isOccupied[ix][iy] = [];\n        }\n        var currFillState = this.isOccupied[ix][iy][iz];\n        this.isOccupied[ix][iy][iz] = true;\n        if (!currFillState) {\n            //  If not already filled.\n            this.numFilledCells++;\n        }\n    };\n    VoxelGrid.prototype.markEmpty = function (cell) {\n        if (!this.isInBoundsVoxelIndex(cell)) {\n            console.warn('Attempted to unmark an out of bounds cell: ', cell);\n            return;\n        }\n        var ix = cell[0];\n        var iy = cell[1];\n        var iz = cell[2];\n        if (this.isOccupied[ix] === undefined) {\n            return;\n        }\n        if (this.isOccupied[ix][iy] === undefined) {\n            return;\n        }\n        var currFillState = this.isOccupied[ix][iy][iz];\n        this.isOccupied[ix][iy][iz] = false;\n        if (currFillState === true) {\n            //  If cell was filled.\n            this.numFilledCells--;\n        }\n    };\n    VoxelGrid.prototype.isFilledAdjacentY = function (cell, shiftY) {\n        return this.isFilled3(cell[0], cell[1] + shiftY, cell[2]);\n    };\n    VoxelGrid.prototype.isFilled3 = function (ix, iy, iz) {\n        var gridDims = this.gridDimensions;\n        if (ix < 0 || ix >= gridDims[0] || iy < 0 || iy >= gridDims[1] || iz < 0 || iz >= gridDims[2]) {\n            return false;\n        }\n        if (this.isOccupied[ix] === undefined) {\n            return false;\n        }\n        if (this.isOccupied[ix][iy] === undefined) {\n            return false;\n        }\n        return this.isOccupied[ix][iy][iz] === true;\n    };\n    VoxelGrid.prototype.isFilled = function (cell) {\n        var ix = cell[0];\n        var iy = cell[1];\n        var iz = cell[2];\n        return this.isFilled3(ix, iy, iz);\n    };\n    VoxelGrid.prototype.intersectingCell = function (outIdx, rayOrigin, rayDir) {\n        var gridDims = this.gridDimensions;\n        var cellDims = this.cellDimensions;\n        var pos = this.position;\n        var ray = this.intersectRay.set(rayOrigin, rayDir);\n        var gridAabb = this.intersectAabb;\n        gridAabb.minX = Math.max(pos[0], rayOrigin[0]);\n        gridAabb.maxX = Math.min(gridDims[0] * cellDims[0], rayOrigin[0]);\n        gridAabb.minY = Math.max(pos[1], rayOrigin[1]);\n        gridAabb.maxY = Math.min(gridDims[1] * cellDims[1], rayOrigin[1]);\n        gridAabb.minZ = Math.max(pos[2], rayOrigin[2]);\n        gridAabb.maxZ = Math.min(gridDims[2] * cellDims[2], rayOrigin[2]);\n        var intersectRes = intersections_1.rayIntersectsAabb(ray, gridAabb);\n        if (!intersectRes.intersects) {\n            return false;\n        }\n        var p0 = ray.pointAt(this.intersectPoint, intersectRes.tMin);\n        this.getCellIndexOfPoint(outIdx, p0);\n        if (this.isFilled(outIdx)) {\n            return true;\n        }\n        var maxIters = this.maxDim * this.maxDim;\n        var sx = Math.sign(rayDir[0]);\n        var sy = Math.sign(rayDir[1]);\n        var sz = Math.sign(rayDir[2]);\n        var xBound = (sx > 0 ? outIdx[0] + 1 : outIdx[0]) * cellDims[0] + pos[0];\n        var yBound = (sy > 0 ? outIdx[1] + 1 : outIdx[1]) * cellDims[1] + pos[1];\n        var zBound = (sz > 0 ? outIdx[2] + 1 : outIdx[2]) * cellDims[2] + pos[2];\n        var tx = Math.abs(cellDims[0] / rayDir[0]);\n        var ty = Math.abs(cellDims[1] / rayDir[1]);\n        var tz = Math.abs(cellDims[2] / rayDir[2]);\n        var cx = (xBound - p0[0]) / rayDir[0];\n        var cy = (yBound - p0[1]) / rayDir[1];\n        var cz = (zBound - p0[2]) / rayDir[2];\n        var ix = 0;\n        var iy = 0;\n        var iz = 0;\n        for (var iter = 0; iter < maxIters; iter++) {\n            if (cx < cy && cx < cz) {\n                ix += sx;\n                cx += tx;\n            }\n            else if (cy < cz) {\n                iy += sy;\n                cy += ty;\n            }\n            else {\n                iz += sz;\n                cz += tz;\n            }\n            var ixTest = outIdx[0] + ix;\n            var iyTest = outIdx[1] + iy;\n            var izTest = outIdx[2] + iz;\n            if (this.isFilled3(ixTest, iyTest, izTest)) {\n                outIdx[0] = ixTest;\n                outIdx[1] = iyTest;\n                outIdx[2] = izTest;\n                return true;\n            }\n            iter++;\n        }\n        return false;\n    };\n    return VoxelGrid;\n}());\nexports.VoxelGrid = VoxelGrid;\n\n\n//# sourceURL=webpack:///./build/src/gl/voxel-grid.js?");

/***/ }),

/***/ "./build/src/util/image.js":
/*!*********************************!*\
  !*** ./build/src/util/image.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar Image = /** @class */ (function () {\n    function Image(data, width, height, numComponents, componentType) {\n        var numPixels = width * height * numComponents;\n        if (numPixels !== data.length) {\n            throw new Error(\"Data of length \" + data.length + \" do not correspond to given number of pixels \" + numPixels + \".\");\n        }\n        this.data = data;\n        this.width = width;\n        this.height = height;\n        this.numComponents = numComponents;\n        this.componentType = componentType;\n    }\n    return Image;\n}());\nexports.Image = Image;\n\n\n//# sourceURL=webpack:///./build/src/util/image.js?");

/***/ }),

/***/ "./build/src/util/index.js":
/*!*********************************!*\
  !*** ./build/src/util/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nexports.__esModule = true;\n__export(__webpack_require__(/*! ./image */ \"./build/src/util/image.js\"));\n__export(__webpack_require__(/*! ./result */ \"./build/src/util/result.js\"));\n__export(__webpack_require__(/*! ./time */ \"./build/src/util/time.js\"));\n__export(__webpack_require__(/*! ./types */ \"./build/src/util/types.js\"));\n__export(__webpack_require__(/*! ./loaders */ \"./build/src/util/loaders.js\"));\n__export(__webpack_require__(/*! ./number-sampler */ \"./build/src/util/number-sampler.js\"));\n__export(__webpack_require__(/*! ./misc */ \"./build/src/util/misc.js\"));\n\n\n//# sourceURL=webpack:///./build/src/util/index.js?");

/***/ }),

/***/ "./build/src/util/loaders.js":
/*!***********************************!*\
  !*** ./build/src/util/loaders.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nexports.__esModule = true;\nvar image_1 = __webpack_require__(/*! ./image */ \"./build/src/util/image.js\");\nfunction loadText(url) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n                    var xhr = new XMLHttpRequest();\n                    xhr.onreadystatechange = function () {\n                        if (xhr.readyState === 4) {\n                            if (xhr.status === 200) {\n                                resolve(xhr.responseText);\n                            }\n                            else {\n                                reject(xhr);\n                            }\n                        }\n                    };\n                    xhr.open('GET', url);\n                    xhr.send();\n                })];\n        });\n    });\n}\nexports.loadText = loadText;\nfunction loadImage(url) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n                    var img = document.createElement('img');\n                    img.onload = function (evt) {\n                        window.URL.revokeObjectURL(img.src);\n                        resolve(img);\n                    };\n                    img.onerror = function (err) { return reject(err); };\n                    img.src = url;\n                })];\n        });\n    });\n}\nexports.loadImage = loadImage;\nvar canvas = null;\nvar canvasContext = null;\nfunction loadImageObject(url) {\n    return __awaiter(this, void 0, void 0, function () {\n        var imageElement, imageData, outData;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, loadImage(url)];\n                case 1:\n                    imageElement = _a.sent();\n                    if (!canvas) {\n                        canvas = document.createElement('canvas');\n                        canvasContext = canvas.getContext('2d');\n                    }\n                    canvas.width = imageElement.width;\n                    canvas.height = imageElement.height;\n                    canvasContext.drawImage(imageElement, 0, 0);\n                    imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);\n                    outData = new Uint8Array(imageData.data.length);\n                    outData.set(imageData.data);\n                    return [2 /*return*/, new image_1.Image(outData, canvas.width, canvas.height, 4, 2 /* Uint8 */)];\n            }\n        });\n    });\n}\nexports.loadImageObject = loadImageObject;\nfunction loadAudioBuffer(audioContext, url) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n                    var req = new XMLHttpRequest();\n                    req.responseType = 'arraybuffer';\n                    req.onload = function () {\n                        var audioData = req.response;\n                        audioContext.decodeAudioData(audioData, function (buffer) { return resolve(buffer); }, function (err) { return reject(err); });\n                    };\n                    req.onerror = function (req) { return reject(req); };\n                    req.open('GET', url, true);\n                    req.send();\n                })];\n        });\n    });\n}\nexports.loadAudioBuffer = loadAudioBuffer;\nfunction loadAudioBufferSourceNode(audioContext, url) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n                    var req = new XMLHttpRequest();\n                    req.responseType = 'arraybuffer';\n                    req.onload = function () {\n                        var audioData = req.response;\n                        audioContext.decodeAudioData(audioData, function (buffer) {\n                            var source = audioContext.createBufferSource();\n                            source.buffer = buffer;\n                            resolve(source);\n                        }, function (err) { return reject(err); });\n                    };\n                    req.onerror = function (req) { return reject(req); };\n                    req.open('GET', url, true);\n                    req.send();\n                })];\n        });\n    });\n}\nexports.loadAudioBufferSourceNode = loadAudioBufferSourceNode;\nfunction loadUint8Buffer(url) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n                    var req = new XMLHttpRequest();\n                    req.responseType = 'arraybuffer';\n                    req.onload = function () {\n                        var buffer = req.response;\n                        var view = new DataView(buffer);\n                        var byteLength = buffer.byteLength;\n                        var array = new Uint8Array(byteLength);\n                        for (var i = 0; i < byteLength; i++) {\n                            array[i] = view.getUint8(i);\n                        }\n                        resolve(array);\n                    };\n                    req.onerror = function (req) { return reject(req); };\n                    req.open('GET', url, true);\n                    req.send();\n                })];\n        });\n    });\n}\nexports.loadUint8Buffer = loadUint8Buffer;\nfunction loadFloat32Buffer(url, isLittleEndian) {\n    if (isLittleEndian === void 0) { isLittleEndian = true; }\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n                    var req = new XMLHttpRequest();\n                    req.responseType = 'arraybuffer';\n                    req.onload = function () {\n                        var buffer = req.response;\n                        var view = new DataView(buffer);\n                        var byteLength = buffer.byteLength;\n                        var destLength = Math.floor(byteLength / 4);\n                        if (byteLength % 4 !== 0) {\n                            console.warn('Improper number of bytes for Float32Array.');\n                        }\n                        var array = new Float32Array(destLength);\n                        for (var i = 0; i < destLength; i++) {\n                            array[i] = view.getFloat32(i * 4, isLittleEndian);\n                        }\n                        resolve(array);\n                    };\n                    req.onerror = function (req) { return reject(req); };\n                    req.open('GET', url, true);\n                    req.send();\n                })];\n        });\n    });\n}\nexports.loadFloat32Buffer = loadFloat32Buffer;\n\n\n//# sourceURL=webpack:///./build/src/util/loaders.js?");

/***/ }),

/***/ "./build/src/util/misc.js":
/*!********************************!*\
  !*** ./build/src/util/misc.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar types = __webpack_require__(/*! ./types */ \"./build/src/util/types.js\");\nvar ObjectToggle = /** @class */ (function () {\n    function ObjectToggle(v) {\n        this.value = v;\n        this.keys = Object.keys(v);\n        this.index = 0;\n    }\n    ObjectToggle.prototype.randomize = function () {\n        this.index = Math.max(Math.min(Math.floor(Math.random() * this.keys.length), this.keys.length - 1), 0);\n    };\n    ObjectToggle.prototype.cycle = function () {\n        this.index++;\n        if (this.index >= this.keys.length) {\n            this.index = 0;\n        }\n    };\n    ObjectToggle.prototype.current = function () {\n        if (this.keys.length === 0) {\n            return null;\n        }\n        else {\n            return this.value[this.keys[this.index]];\n        }\n    };\n    return ObjectToggle;\n}());\nexports.ObjectToggle = ObjectToggle;\nfunction tryExtractErrorMessage(err, orElse) {\n    if (orElse === void 0) { orElse = ''; }\n    return (types.isBasicErr(err) ? err.message : orElse);\n}\nexports.tryExtractErrorMessage = tryExtractErrorMessage;\nfunction asyncTimeout(func, milliseconds) {\n    return new Promise(function (resolve, reject) {\n        var responded = false;\n        func().then(function (v) {\n            if (!responded) {\n                responded = true;\n                resolve(v);\n            }\n        })[\"catch\"](function (err) {\n            if (!responded) {\n                responded = true;\n                reject(err);\n            }\n        });\n        setTimeout(function () {\n            if (!responded) {\n                responded = true;\n                reject(new Error(\"Failed to resolve promise in \" + milliseconds + \" ms.\"));\n            }\n        }, milliseconds);\n    });\n}\nexports.asyncTimeout = asyncTimeout;\n\n\n//# sourceURL=webpack:///./build/src/util/misc.js?");

/***/ }),

/***/ "./build/src/util/number-sampler.js":
/*!******************************************!*\
  !*** ./build/src/util/number-sampler.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar NumberSampler = /** @class */ (function () {\n    function NumberSampler(buffer) {\n        this.buffer = buffer;\n        this.sampleIndex = 0;\n        this.numSamples = buffer.length;\n    }\n    NumberSampler.prototype.randomizeSampleIndex = function () {\n        if (this.numSamples === 0) {\n            return;\n        }\n        this.sampleIndex = Math.floor(Math.random() * (this.numSamples - 1));\n    };\n    NumberSampler.prototype.incrementSampleIndex = function () {\n        this.sampleIndex++;\n        if (this.sampleIndex >= this.numSamples) {\n            this.sampleIndex = 0;\n        }\n    };\n    NumberSampler.prototype.seek = function (to) {\n        if (this.numSamples === 0) {\n            return;\n        }\n        to = to < 0 ? 0 : to > 1 ? 1 : to;\n        this.sampleIndex = Math.floor((this.numSamples - 1) * to);\n    };\n    NumberSampler.prototype.nthNextSample = function (n) {\n        var sample = this.buffer[this.sampleIndex];\n        this.sampleIndex += n;\n        this.sampleIndex %= this.numSamples;\n        return sample;\n        // const sample = this.buffer[this.sampleIndex];\n        // this.sampleIndex += Math.floor(n);\n        // if (this.sampleIndex >= this.numSamples) {\n        //   this.sampleIndex = 0;\n        // }\n        // return sample;\n    };\n    NumberSampler.prototype.nextSample = function () {\n        var sample = this.buffer[this.sampleIndex];\n        this.incrementSampleIndex();\n        return sample;\n    };\n    return NumberSampler;\n}());\nexports.NumberSampler = NumberSampler;\n\n\n//# sourceURL=webpack:///./build/src/util/number-sampler.js?");

/***/ }),

/***/ "./build/src/util/result.js":
/*!**********************************!*\
  !*** ./build/src/util/result.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar Result = /** @class */ (function () {\n    function Result(data, isError) {\n        this.data = data;\n        this.isError = isError;\n    }\n    Result.prototype.isOk = function () {\n        return !this.isError;\n    };\n    Result.prototype.isErr = function () {\n        return this.isError;\n    };\n    Result.prototype.unwrapErr = function () {\n        if (!this.isError) {\n            throw new Error('Attempt to unwrapErr on an ok-value.');\n        }\n        return this.data;\n    };\n    Result.prototype.unwrap = function () {\n        if (this.isError) {\n            throw new Error('Attempt to unwrap an error value.');\n        }\n        return this.data;\n    };\n    Result.Err = function (err) {\n        return new Result(err, true);\n    };\n    Result.Ok = function (val) {\n        return new Result(val, false);\n    };\n    return Result;\n}());\nexports.Result = Result;\n\n\n//# sourceURL=webpack:///./build/src/util/result.js?");

/***/ }),

/***/ "./build/src/util/time.js":
/*!********************************!*\
  !*** ./build/src/util/time.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar FrameTimerWithHistory = /** @class */ (function () {\n    function FrameTimerWithHistory(minUpdatesToBegin, sampleSize) {\n        this.lastTime = NaN;\n        this.iter = 0;\n        this.minUpdatesToBegin = minUpdatesToBegin;\n        this.numUpdates = 0;\n        this.sampleSize = sampleSize;\n        this.deltas = [];\n    }\n    FrameTimerWithHistory.prototype.meanDelta = function () {\n        var sum = 0;\n        for (var i = 0; i < this.deltas.length; i++) {\n            sum += this.deltas[i];\n        }\n        return sum / this.deltas.length;\n    };\n    FrameTimerWithHistory.prototype.update = function (currentTime) {\n        var delta = currentTime - this.lastTime;\n        this.lastTime = currentTime;\n        if (this.numUpdates >= this.minUpdatesToBegin) {\n            this.deltas[this.iter++] = delta;\n            this.iter %= this.sampleSize;\n        }\n        this.numUpdates++;\n    };\n    return FrameTimerWithHistory;\n}());\nexports.FrameTimerWithHistory = FrameTimerWithHistory;\nvar AudioContextStopWatch = /** @class */ (function () {\n    function AudioContextStopWatch(context) {\n        this.startTime = context.currentTime;\n        this.context = context;\n    }\n    AudioContextStopWatch.prototype.elapsed = function () {\n        return this.context.currentTime - this.startTime;\n    };\n    AudioContextStopWatch.prototype.elapsedSecs = function () {\n        return this.elapsed();\n    };\n    AudioContextStopWatch.prototype.reset = function () {\n        this.startTime = this.context.currentTime;\n    };\n    return AudioContextStopWatch;\n}());\nexports.AudioContextStopWatch = AudioContextStopWatch;\nvar Stopwatch = /** @class */ (function () {\n    function Stopwatch() {\n        this.startTime = performance.now();\n    }\n    Stopwatch.prototype.elapsed = function () {\n        return performance.now() - this.startTime;\n    };\n    Stopwatch.prototype.elapsedSecs = function () {\n        return this.elapsed() / 1e3;\n    };\n    Stopwatch.prototype.reset = function () {\n        this.startTime = performance.now();\n    };\n    return Stopwatch;\n}());\nexports.Stopwatch = Stopwatch;\nvar StatTimer = /** @class */ (function () {\n    function StatTimer() {\n        this.expectTick = true;\n        this.iter = 0;\n        this.meanTime = NaN;\n        this.minTime = NaN;\n        this.maxTime = NaN;\n        this.startTime = NaN;\n    }\n    StatTimer.prototype.currentTime = function () {\n        return performance.now();\n    };\n    StatTimer.prototype.display = function () {\n        console.log(\"N: \" + this.iter + \"; Mean: \" + this.meanTime + \"; Min: \" + this.minTime + \"; Max: \" + this.maxTime);\n    };\n    StatTimer.prototype.tock = function () {\n        if (this.expectTick) {\n            console.warn('Expected tick before tock.');\n            return;\n        }\n        this.expectTick = !this.expectTick;\n        var delta = this.currentTime() - this.startTime;\n        if (this.iter === 0) {\n            this.meanTime = delta;\n            this.minTime = delta;\n            this.maxTime = delta;\n        }\n        else {\n            this.meanTime = (this.meanTime * this.iter + delta) / (this.iter + 1);\n            if (delta < this.minTime) {\n                this.minTime = delta;\n            }\n            if (delta > this.maxTime) {\n                this.maxTime = delta;\n            }\n        }\n        this.iter++;\n    };\n    StatTimer.prototype.tick = function () {\n        if (!this.expectTick) {\n            console.warn('Expected tock after tick.');\n            this.expectTick = true;\n        }\n        this.startTime = this.currentTime();\n        this.expectTick = !this.expectTick;\n    };\n    return StatTimer;\n}());\nexports.StatTimer = StatTimer;\n\n\n//# sourceURL=webpack:///./build/src/util/time.js?");

/***/ }),

/***/ "./build/src/util/types.js":
/*!*********************************!*\
  !*** ./build/src/util/types.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\n;\n;\nfunction isBasicErr(err) {\n    return typeof err === 'object' && err.hasOwnProperty('message') && typeof err.message === 'string';\n}\nexports.isBasicErr = isBasicErr;\nfunction True() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return true;\n}\nexports.True = True;\nfunction False() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return false;\n}\nexports.False = False;\n\n\n//# sourceURL=webpack:///./build/src/util/types.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EPSILON\", function() { return EPSILON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ARRAY_TYPE\", function() { return ARRAY_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RANDOM\", function() { return RANDOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setMatrixArrayType\", function() { return setMatrixArrayType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRadian\", function() { return toRadian; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar RANDOM = Math.random;\n/**\r\n * Sets the type of array used when creating new vectors and matrices\r\n *\r\n * @param {Type} type Array type, such as Float32Array or Array\r\n */\n\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\r\n * Convert Degree To Radian\r\n *\r\n * @param {Number} a Angle in Degrees\r\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\r\n * Tests whether or not the arguments have approximately the same value, within an absolute\r\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\r\n * than or equal to 1.0, and a relative tolerance is used for larger values)\r\n *\r\n * @param {Number} a The first number to test.\r\n * @param {Number} b The second number to test.\r\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/common.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/index.js ***!
  \*********************************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"glMatrix\", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__; });\n/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ \"./node_modules/gl-matrix/esm/mat2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat2\", function() { return _mat2_js__WEBPACK_IMPORTED_MODULE_1__; });\n/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ \"./node_modules/gl-matrix/esm/mat2d.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat2d\", function() { return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });\n/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ \"./node_modules/gl-matrix/esm/mat3.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat3\", function() { return _mat3_js__WEBPACK_IMPORTED_MODULE_3__; });\n/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ \"./node_modules/gl-matrix/esm/mat4.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat4\", function() { return _mat4_js__WEBPACK_IMPORTED_MODULE_4__; });\n/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ \"./node_modules/gl-matrix/esm/quat.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"quat\", function() { return _quat_js__WEBPACK_IMPORTED_MODULE_5__; });\n/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ \"./node_modules/gl-matrix/esm/quat2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"quat2\", function() { return _quat2_js__WEBPACK_IMPORTED_MODULE_6__; });\n/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ \"./node_modules/gl-matrix/esm/vec2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec2\", function() { return _vec2_js__WEBPACK_IMPORTED_MODULE_7__; });\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ \"./node_modules/gl-matrix/esm/vec3.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec3\", function() { return _vec3_js__WEBPACK_IMPORTED_MODULE_8__; });\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ \"./node_modules/gl-matrix/esm/vec4.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec4\", function() { return _vec4_js__WEBPACK_IMPORTED_MODULE_9__; });\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/index.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LDU\", function() { return LDU; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\r\n * 2x2 Matrix\r\n * @module mat2\r\n */\n\n/**\r\n * Creates a new identity mat2\r\n *\r\n * @returns {mat2} a new 2x2 matrix\r\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat2 initialized with values from an existing matrix\r\n *\r\n * @param {mat2} a matrix to clone\r\n * @returns {mat2} a new 2x2 matrix\r\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Copy the values from one mat2 to another\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set a mat2 to the identity matrix\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @returns {mat2} out\r\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Create a new mat2 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out A new 2x2 matrix\r\n */\n\nfunction fromValues(m00, m01, m10, m11) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\r\n * Set the components of a mat2 to the given values\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out\r\n */\n\nfunction set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\r\n * Transpose the values of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    var a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nfunction invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3]; // Calculate the determinant\n\n  var det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] = a0 * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nfunction adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  var a0 = a[0];\n  out[0] = a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a0;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat2\r\n *\r\n * @param {mat2} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nfunction determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n/**\r\n * Multiplies two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\nfunction multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n/**\r\n * Rotates a mat2 by the given angle\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\n\nfunction rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n/**\r\n * Scales the mat2 by the dimensions in the given vec2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to rotate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat2} out\r\n **/\n\nfunction scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.scale(dest, dest, vec);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat2} out\r\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n/**\r\n * Returns a string representation of a mat2\r\n *\r\n * @param {mat2} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nfunction str(a) {\n  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n/**\r\n * Returns Frobenius norm of a mat2\r\n *\r\n * @param {mat2} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nfunction frob(a) {\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));\n}\n/**\r\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\r\n * @param {mat2} L the lower triangular matrix\r\n * @param {mat2} D the diagonal matrix\r\n * @param {mat2} U the upper triangular matrix\r\n * @param {mat2} a the input matrix to factorize\r\n */\n\nfunction LDU(L, D, U, a) {\n  L[2] = a[2] / a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n/**\r\n * Adds two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat2} a The first matrix.\r\n * @param {mat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat2} a The first matrix.\r\n * @param {mat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2} out\r\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2} out the receiving vector\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2} out\r\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Alias for {@link mat2.multiply}\r\n * @function\r\n */\n\nvar mul = multiply;\n/**\r\n * Alias for {@link mat2.subtract}\r\n * @function\r\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/mat2.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2d.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2d.js ***!
  \*********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\r\n * 2x3 Matrix\r\n * @module mat2d\r\n *\r\n * @description\r\n * A mat2d contains six elements defined as:\r\n * <pre>\r\n * [a, c, tx,\r\n *  b, d, ty]\r\n * </pre>\r\n * This is a short form for the 3x3 matrix:\r\n * <pre>\r\n * [a, c, tx,\r\n *  b, d, ty,\r\n *  0, 0, 1]\r\n * </pre>\r\n * The last row is ignored so the array is shorter and operations are faster.\r\n */\n\n/**\r\n * Creates a new identity mat2d\r\n *\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[4] = 0;\n    out[5] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat2d initialized with values from an existing matrix\r\n *\r\n * @param {mat2d} a matrix to clone\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\r\n * Copy the values from one mat2d to another\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\r\n * Set a mat2d to the identity matrix\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @returns {mat2d} out\r\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Create a new mat2d with the given values\r\n *\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} A new mat2d\r\n */\n\nfunction fromValues(a, b, c, d, tx, ty) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\r\n * Set the components of a mat2d to the given values\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} out\r\n */\n\nfunction set(out, a, b, c, d, tx, ty) {\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\r\n * Inverts a mat2d\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\n\nfunction invert(out, a) {\n  var aa = a[0],\n      ab = a[1],\n      ac = a[2],\n      ad = a[3];\n  var atx = a[4],\n      aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat2d\r\n *\r\n * @param {mat2d} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nfunction determinant(a) {\n  return a[0] * a[3] - a[1] * a[2];\n}\n/**\r\n * Multiplies two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\nfunction multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  out[4] = a0 * b4 + a2 * b5 + a4;\n  out[5] = a1 * b4 + a3 * b5 + a5;\n  return out;\n}\n/**\r\n * Rotates a mat2d by the given angle\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\n\nfunction rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\r\n * Scales the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to translate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat2d} out\r\n **/\n\nfunction scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\r\n * Translates the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to translate\r\n * @param {vec2} v the vec2 to translate the matrix by\r\n * @returns {mat2d} out\r\n **/\n\nfunction translate(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0;\n  out[1] = a1;\n  out[2] = a2;\n  out[3] = a3;\n  out[4] = a0 * v0 + a2 * v1 + a4;\n  out[5] = a1 * v0 + a3 * v1 + a5;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.scale(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat2d} out\r\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.translate(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {vec2} v Translation vector\r\n * @returns {mat2d} out\r\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = v[0];\n  out[5] = v[1];\n  return out;\n}\n/**\r\n * Returns a string representation of a mat2d\r\n *\r\n * @param {mat2d} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nfunction str(a) {\n  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';\n}\n/**\r\n * Returns Frobenius norm of a mat2d\r\n *\r\n * @param {mat2d} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nfunction frob(a) {\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);\n}\n/**\r\n * Adds two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2d} out\r\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  return out;\n}\n/**\r\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2d} out the receiving vector\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2d} out\r\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat2d} a The first matrix.\r\n * @param {mat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat2d} a The first matrix.\r\n * @param {mat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));\n}\n/**\r\n * Alias for {@link mat2d.multiply}\r\n * @function\r\n */\n\nvar mul = multiply;\n/**\r\n * Alias for {@link mat2d.subtract}\r\n * @function\r\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/mat2d.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat3.js ***!
  \********************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat4\", function() { return fromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat2d\", function() { return fromMat2d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat\", function() { return fromQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalFromMat4\", function() { return normalFromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"projection\", function() { return projection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\r\n * 3x3 Matrix\r\n * @module mat3\r\n */\n\n/**\r\n * Creates a new identity mat3\r\n *\r\n * @returns {mat3} a new 3x3 matrix\r\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Copies the upper-left 3x3 values into the given mat3.\r\n *\r\n * @param {mat3} out the receiving 3x3 matrix\r\n * @param {mat4} a   the source 4x4 matrix\r\n * @returns {mat3} out\r\n */\n\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\r\n * Creates a new mat3 initialized with values from an existing matrix\r\n *\r\n * @param {mat3} a matrix to clone\r\n * @returns {mat3} a new 3x3 matrix\r\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Copy the values from one mat3 to another\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Create a new mat3 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} A new mat3\r\n */\n\nfunction fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\r\n * Set the components of a mat3 to the given values\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} out\r\n */\n\nfunction set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\r\n * Set a mat3 to the identity matrix\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @returns {mat3} out\r\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat3\r\n *\r\n * @param {mat3} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\r\n * Multiplies two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\r\n * Translate a mat3 by the given vector\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to translate\r\n * @param {vec2} v vector to translate by\r\n * @returns {mat3} out\r\n */\n\nfunction translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\r\n * Rotates a mat3 by the given angle\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\n\nfunction rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n;\n/**\r\n * Scales the mat3 by the dimensions in the given vec2\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to rotate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat3} out\r\n **/\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.translate(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {vec2} v Translation vector\r\n * @returns {mat3} out\r\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.rotate(dest, dest, rad);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.scale(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat3} out\r\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Copies the values from a mat2d into a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat2d} a the matrix to copy\r\n * @returns {mat3} out\r\n **/\n\nfunction fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\r\n* Calculates a 3x3 matrix from the given quaternion\r\n*\r\n* @param {mat3} out mat3 receiving operation result\r\n* @param {quat} q Quaternion to create matrix from\r\n*\r\n* @returns {mat3} out\r\n*/\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\r\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\r\n*\r\n* @param {mat3} out mat3 receiving operation result\r\n* @param {mat4} a Mat4 to derive the normal matrix from\r\n*\r\n* @returns {mat3} out\r\n*/\n\nfunction normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\r\n * Generates a 2D projection matrix with the given bounds\r\n *\r\n * @param {mat3} out mat3 frustum matrix will be written into\r\n * @param {number} width Width of your gl context\r\n * @param {number} height Height of gl context\r\n * @returns {mat3} out\r\n */\n\nfunction projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Returns a string representation of a mat3\r\n *\r\n * @param {mat3} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nfunction str(a) {\n  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';\n}\n/**\r\n * Returns Frobenius norm of a mat3\r\n *\r\n * @param {mat3} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nfunction frob(a) {\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));\n}\n/**\r\n * Adds two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat3} out\r\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\r\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat3} out the receiving vector\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat3} out\r\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat3} a The first matrix.\r\n * @param {mat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat3} a The first matrix.\r\n * @param {mat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\r\n * Alias for {@link mat3.multiply}\r\n * @function\r\n */\n\nvar mul = multiply;\n/**\r\n * Alias for {@link mat3.subtract}\r\n * @function\r\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/mat3.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromXRotation\", function() { return fromXRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromYRotation\", function() { return fromYRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromZRotation\", function() { return fromZRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslation\", function() { return fromRotationTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat2\", function() { return fromQuat2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTranslation\", function() { return getTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScaling\", function() { return getScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRotation\", function() { return getRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationScale\", function() { return fromRotationTranslationScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationScaleOrigin\", function() { return fromRotationTranslationScaleOrigin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat\", function() { return fromQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frustum\", function() { return frustum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"perspective\", function() { return perspective; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"perspectiveFromFieldOfView\", function() { return perspectiveFromFieldOfView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ortho\", function() { return ortho; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lookAt\", function() { return lookAt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"targetTo\", function() { return targetTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\r\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\r\n * @module mat4\r\n */\n\n/**\r\n * Creates a new identity mat4\r\n *\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 initialized with values from an existing matrix\r\n *\r\n * @param {mat4} a matrix to clone\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Copy the values from one mat4 to another\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Create a new mat4 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} A new mat4\r\n */\n\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set the components of a mat4 to the given values\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} out\r\n */\n\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set a mat4 to the identity matrix\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @returns {mat4} out\r\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat4\r\n *\r\n * @param {mat4} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\r\n * Multiplies two mat4s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\r\n * Translate a mat4 by the given vector\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to translate\r\n * @param {vec3} v vector to translate by\r\n * @returns {mat4} out\r\n */\n\nfunction translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\r\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to scale\r\n * @param {vec3} v the vec3 to scale the matrix by\r\n * @returns {mat4} out\r\n **/\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Rotates a mat4 by the given angle around the given axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {vec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.sqrt(x * x + y * y + z * z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the X axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Y axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Z axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {vec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.scale(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {vec3} v Scaling vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle around a given axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotate(dest, dest, rad, axis);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {vec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.sqrt(x * x + y * y + z * z);\n  var s, c, t;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the X axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateX(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Y axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateY(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Z axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateZ(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation and vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 from a dual quat.\r\n *\r\n * @param {mat4} out Matrix\r\n * @param {quat2} a Dual Quaternion\r\n * @returns {mat4} mat4 receiving operation result\r\n */\n\nfunction fromQuat2(out, a) {\n  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\r\n * Returns the translation vector component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslation,\r\n *  the returned vector will be the same as the translation vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive translation component\r\n * @param  {mat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\r\n * Returns the scaling factor component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslationScale\r\n *  with a normalized Quaternion paramter, the returned vector will be\r\n *  the same as the scaling vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive scaling factor component\r\n * @param  {mat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\n  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\n  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\n  return out;\n}\n/**\r\n * Returns a quaternion representing the rotational component\r\n *  of a transformation matrix. If a matrix is built with\r\n *  fromRotationTranslation, the returned quaternion will be the\r\n *  same as the quaternion originally supplied.\r\n * @param {quat} out Quaternion to receive the rotation component\r\n * @param {mat4} mat Matrix to be decomposed (input)\r\n * @return {quat} out\r\n */\n\nfunction getRotation(out, mat) {\n  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n  var trace = mat[0] + mat[5] + mat[10];\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (mat[6] - mat[9]) / S;\n    out[1] = (mat[8] - mat[2]) / S;\n    out[2] = (mat[1] - mat[4]) / S;\n  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {\n    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;\n    out[3] = (mat[6] - mat[9]) / S;\n    out[0] = 0.25 * S;\n    out[1] = (mat[1] + mat[4]) / S;\n    out[2] = (mat[8] + mat[2]) / S;\n  } else if (mat[5] > mat[10]) {\n    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;\n    out[3] = (mat[8] - mat[2]) / S;\n    out[0] = (mat[1] + mat[4]) / S;\n    out[1] = 0.25 * S;\n    out[2] = (mat[6] + mat[9]) / S;\n  } else {\n    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;\n    out[3] = (mat[1] - mat[4]) / S;\n    out[0] = (mat[8] + mat[2]) / S;\n    out[1] = (mat[6] + mat[9]) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @param {vec3} s Scaling vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     mat4.translate(dest, origin);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *     mat4.translate(dest, negativeOrigin);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @param {vec3} s Scaling vector\r\n * @param {vec3} o The origin vector around which to scale and rotate\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Calculates a 4x4 matrix from the given quaternion\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat4} out\r\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a frustum matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Number} left Left bound of the frustum\r\n * @param {Number} right Right bound of the frustum\r\n * @param {Number} bottom Bottom bound of the frustum\r\n * @param {Number} top Top bound of the frustum\r\n * @param {Number} near Near bound of the frustum\r\n * @param {Number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given bounds.\r\n * Passing null/undefined/no value for far will generate infinite projection matrix.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} fovy Vertical field of view in radians\r\n * @param {number} aspect Aspect ratio. typically viewport width/height\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum, can be null or Infinity\r\n * @returns {mat4} out\r\n */\n\nfunction perspective(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given field of view.\r\n * This is primarily useful for generating projection matrices to be used\r\n * with the still experiemental WebVR API.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction ortho(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {vec3} eye Position of the viewer\r\n * @param {vec3} center Point the viewer is looking at\r\n * @param {vec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a matrix that makes something look at something else.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {vec3} eye Position of the viewer\r\n * @param {vec3} center Point the viewer is looking at\r\n * @param {vec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n;\n/**\r\n * Returns a string representation of a mat4\r\n *\r\n * @param {mat4} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nfunction str(a) {\n  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\n}\n/**\r\n * Returns Frobenius norm of a mat4\r\n *\r\n * @param {mat4} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nfunction frob(a) {\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));\n}\n/**\r\n * Adds two mat4's\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat4} out\r\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\r\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat4} out the receiving vector\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat4} out\r\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat4} a The first matrix.\r\n * @param {mat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat4} a The first matrix.\r\n * @param {mat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\r\n * Alias for {@link mat4.multiply}\r\n * @function\r\n */\n\nvar mul = multiply;\n/**\r\n * Alias for {@link mat4.subtract}\r\n * @function\r\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/mat4.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat.js ***!
  \********************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, multiply, rotateX, rotateY, rotateZ, calculateW, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setAxisAngle\", function() { return setAxisAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAxisAngle\", function() { return getAxisAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateW\", function() { return calculateW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slerp\", function() { return slerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"conjugate\", function() { return conjugate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat3\", function() { return fromMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromEuler\", function() { return fromEuler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotationTo\", function() { return rotationTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqlerp\", function() { return sqlerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setAxes\", function() { return setAxes; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ \"./node_modules/gl-matrix/esm/mat3.js\");\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ \"./node_modules/gl-matrix/esm/vec3.js\");\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ \"./node_modules/gl-matrix/esm/vec4.js\");\n\n\n\n\n/**\r\n * Quaternion\r\n * @module quat\r\n */\n\n/**\r\n * Creates a new identity quat\r\n *\r\n * @returns {quat} a new quaternion\r\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Set a quat to the identity quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Sets a quat from the given angle and rotation axis,\r\n * then returns it.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {vec3} axis the axis around which to rotate\r\n * @param {Number} rad the angle in radians\r\n * @returns {quat} out\r\n **/\n\nfunction setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\r\n * Gets the rotation axis and angle for a given\r\n *  quaternion. If a quaternion is created with\r\n *  setAxisAngle, this method will return the same\r\n *  values as providied in the original parameter list\r\n *  OR functionally equivalent values.\r\n * Example: The quaternion formed by axis [0, 0, 1] and\r\n *  angle -90 is the same as the quaternion formed by\r\n *  [0, 0, 1] and 270. This method favors the latter.\r\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\r\n * @param  {quat} q     Quaternion to be decomposed\r\n * @return {Number}     Angle, in radians, of the rotation\r\n */\n\nfunction getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\r\n * Multiplies two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n */\n\nfunction multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the X axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nfunction rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Y axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nfunction rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Z axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nfunction rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\r\n * Calculates the W component of a quat from the X, Y, and Z components.\r\n * Assumes that quaternion is 1 unit in length.\r\n * Any existing W component will be ignored.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate W component of\r\n * @returns {quat} out\r\n */\n\nfunction calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\r\n * Performs a spherical linear interpolation between two quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\r\n * Generates a random quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\nfunction random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\n  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\n  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\r\n * Calculates the inverse of a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate inverse of\r\n * @returns {quat} out\r\n */\n\nfunction invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\r\n * Calculates the conjugate of a quat\r\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate conjugate of\r\n * @returns {quat} out\r\n */\n\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a quaternion from the given 3x3 rotation matrix.\r\n *\r\n * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n * to renormalize the quaternion yourself where necessary.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {mat3} m rotation matrix\r\n * @returns {quat} out\r\n * @function\r\n */\n\nfunction fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\r\n * Creates a quaternion from the given euler angle x, y, z.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {x} Angle to rotate around X axis in degrees.\r\n * @param {y} Angle to rotate around Y axis in degrees.\r\n * @param {z} Angle to rotate around Z axis in degrees.\r\n * @returns {quat} out\r\n * @function\r\n */\n\nfunction fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\r\n * Returns a string representation of a quatenion\r\n *\r\n * @param {quat} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction str(a) {\n  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {quat} a quaternion to clone\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\n\nvar clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"clone\"];\n/**\r\n * Creates a new quat initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\n\nvar fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"fromValues\"];\n/**\r\n * Copy the values from one quat to another\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the source quaternion\r\n * @returns {quat} out\r\n * @function\r\n */\n\nvar copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"copy\"];\n/**\r\n * Set the components of a quat to the given values\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} out\r\n * @function\r\n */\n\nvar set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"set\"];\n/**\r\n * Adds two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n * @function\r\n */\n\nvar add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"add\"];\n/**\r\n * Alias for {@link quat.multiply}\r\n * @function\r\n */\n\nvar mul = multiply;\n/**\r\n * Scales a quat by a scalar number\r\n *\r\n * @param {quat} out the receiving vector\r\n * @param {quat} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {quat} out\r\n * @function\r\n */\n\nvar scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"scale\"];\n/**\r\n * Calculates the dot product of two quat's\r\n *\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\n\nvar dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"dot\"];\n/**\r\n * Performs a linear interpolation between two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n * @function\r\n */\n\nvar lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"lerp\"];\n/**\r\n * Calculates the length of a quat\r\n *\r\n * @param {quat} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nvar length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"length\"];\n/**\r\n * Alias for {@link quat.length}\r\n * @function\r\n */\n\nvar len = length;\n/**\r\n * Calculates the squared length of a quat\r\n *\r\n * @param {quat} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\n\nvar squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"squaredLength\"];\n/**\r\n * Alias for {@link quat.squaredLength}\r\n * @function\r\n */\n\nvar sqrLen = squaredLength;\n/**\r\n * Normalize a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quaternion to normalize\r\n * @returns {quat} out\r\n * @function\r\n */\n\nvar normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"normalize\"];\n/**\r\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {quat} a The first quaternion.\r\n * @param {quat} b The second quaternion.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nvar exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"exactEquals\"];\n/**\r\n * Returns whether or not the quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {quat} a The first vector.\r\n * @param {quat} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nvar equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"equals\"];\n/**\r\n * Sets a quaternion to represent the shortest rotation from one\r\n * vector to another.\r\n *\r\n * Both vectors are assumed to be unit length.\r\n *\r\n * @param {quat} out the receiving quaternion.\r\n * @param {vec3} a the initial vector\r\n * @param {vec3} b the destination vector\r\n * @returns {quat} out\r\n */\n\nvar rotationTo = function () {\n  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"create\"]();\n  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"fromValues\"](1, 0, 0);\n  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"fromValues\"](0, 1, 0);\n  return function (out, a, b) {\n    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"dot\"](a, b);\n\n    if (dot < -0.999999) {\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, xUnitVec3, a);\n      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"len\"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, yUnitVec3, a);\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"normalize\"](tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\r\n * Performs a spherical linear interpolation with two control points\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {quat} c the third operand\r\n * @param {quat} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\nvar sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\r\n * Sets the specified quaternion with values corresponding to the given\r\n * axes. Each axis is a vec3 and is expected to be unit length and\r\n * perpendicular to all other specified axes.\r\n *\r\n * @param {vec3} view  the vector representing the viewing direction\r\n * @param {vec3} right the vector representing the local \"right\" direction\r\n * @param {vec3} up    the vector representing the local \"up\" direction\r\n * @returns {quat} out\r\n */\n\nvar setAxes = function () {\n  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__[\"create\"]();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/quat.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat2.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat2.js ***!
  \*********************************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationValues\", function() { return fromRotationTranslationValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslation\", function() { return fromRotationTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat4\", function() { return fromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getReal\", function() { return getReal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDual\", function() { return getDual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setReal\", function() { return setReal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDual\", function() { return setDual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTranslation\", function() { return getTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateByQuatAppend\", function() { return rotateByQuatAppend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateByQuatPrepend\", function() { return rotateByQuatPrepend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateAroundAxis\", function() { return rotateAroundAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"conjugate\", function() { return conjugate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ \"./node_modules/gl-matrix/esm/quat.js\");\n/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ \"./node_modules/gl-matrix/esm/mat4.js\");\n\n\n\n/**\r\n * Dual Quaternion<br>\r\n * Format: [real, dual]<br>\r\n * Quaternion format: XYZW<br>\r\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\r\n * @module quat2\r\n */\n\n/**\r\n * Creates a new identity dual quat\r\n *\r\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\r\n */\n\nfunction create() {\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    dq[0] = 0;\n    dq[1] = 0;\n    dq[2] = 0;\n    dq[4] = 0;\n    dq[5] = 0;\n    dq[6] = 0;\n    dq[7] = 0;\n  }\n\n  dq[3] = 1;\n  return dq;\n}\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {quat2} a dual quaternion to clone\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\nfunction clone(a) {\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  dq[0] = a[0];\n  dq[1] = a[1];\n  dq[2] = a[2];\n  dq[3] = a[3];\n  dq[4] = a[4];\n  dq[5] = a[5];\n  dq[6] = a[6];\n  dq[7] = a[7];\n  return dq;\n}\n/**\r\n * Creates a new dual quat initialized with the given values\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\nfunction fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  dq[4] = x2;\n  dq[5] = y2;\n  dq[6] = z2;\n  dq[7] = w2;\n  return dq;\n}\n/**\r\n * Creates a new dual quat from the given values (quat and translation)\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component (translation)\r\n * @param {Number} y2 Y component (translation)\r\n * @param {Number} z2 Z component (translation)\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\nfunction fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  var ax = x2 * 0.5,\n      ay = y2 * 0.5,\n      az = z2 * 0.5;\n  dq[4] = ax * w1 + ay * z1 - az * y1;\n  dq[5] = ay * w1 + az * x1 - ax * z1;\n  dq[6] = az * w1 + ax * y1 - ay * x1;\n  dq[7] = -ax * x1 - ay * y1 - az * z1;\n  return dq;\n}\n/**\r\n * Creates a dual quat from a quaternion and a translation\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {quat} q quaternion\r\n * @param {vec3} t tranlation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\nfunction fromRotationTranslation(out, q, t) {\n  var ax = t[0] * 0.5,\n      ay = t[1] * 0.5,\n      az = t[2] * 0.5,\n      bx = q[0],\n      by = q[1],\n      bz = q[2],\n      bw = q[3];\n  out[0] = bx;\n  out[1] = by;\n  out[2] = bz;\n  out[3] = bw;\n  out[4] = ax * bw + ay * bz - az * by;\n  out[5] = ay * bw + az * bx - ax * bz;\n  out[6] = az * bw + ax * by - ay * bx;\n  out[7] = -ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Creates a dual quat from a translation\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {vec3} t translation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\nfunction fromTranslation(out, t) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = t[0] * 0.5;\n  out[5] = t[1] * 0.5;\n  out[6] = t[2] * 0.5;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Creates a dual quat from a quaternion\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {quat} q the quaternion\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\nfunction fromRotation(out, q) {\n  out[0] = q[0];\n  out[1] = q[1];\n  out[2] = q[2];\n  out[3] = q[3];\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Creates a new dual quat from a matrix (4x4)\r\n *\r\n * @param {quat2} out the dual quaternion\r\n * @param {mat4} a the matrix\r\n * @returns {quat2} dual quat receiving operation result\r\n * @function\r\n */\n\nfunction fromMat4(out, a) {\n  //TODO Optimize this\n  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"create\"]();\n  _mat4_js__WEBPACK_IMPORTED_MODULE_2__[\"getRotation\"](outer, a);\n  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  _mat4_js__WEBPACK_IMPORTED_MODULE_2__[\"getTranslation\"](t, a);\n  fromRotationTranslation(out, outer, t);\n  return out;\n}\n/**\r\n * Copy the values from one dual quat to another\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the source dual quaternion\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  return out;\n}\n/**\r\n * Set a dual quat to the identity dual quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @returns {quat2} out\r\n */\n\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Set the components of a dual quat to the given values\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nfunction set(out, x1, y1, z1, w1, x2, y2, z2, w2) {\n  out[0] = x1;\n  out[1] = y1;\n  out[2] = z1;\n  out[3] = w1;\n  out[4] = x2;\n  out[5] = y2;\n  out[6] = z2;\n  out[7] = w2;\n  return out;\n}\n/**\r\n * Gets the real part of a dual quat\r\n * @param  {quat} out real part\r\n * @param  {quat2} a Dual Quaternion\r\n * @return {quat} real part\r\n */\n\nvar getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"copy\"];\n/**\r\n * Gets the dual part of a dual quat\r\n * @param  {quat} out dual part\r\n * @param  {quat2} a Dual Quaternion\r\n * @return {quat} dual part\r\n */\n\nfunction getDual(out, a) {\n  out[0] = a[4];\n  out[1] = a[5];\n  out[2] = a[6];\n  out[3] = a[7];\n  return out;\n}\n/**\r\n * Set the real component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat} q a quaternion representing the real part\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nvar setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"copy\"];\n/**\r\n * Set the dual component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat} q a quaternion representing the dual part\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nfunction setDual(out, q) {\n  out[4] = q[0];\n  out[5] = q[1];\n  out[6] = q[2];\n  out[7] = q[3];\n  return out;\n}\n/**\r\n * Gets the translation of a normalized dual quat\r\n * @param  {vec3} out translation\r\n * @param  {quat2} a Dual Quaternion to be decomposed\r\n * @return {vec3} translation\r\n */\n\nfunction getTranslation(out, a) {\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3];\n  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  return out;\n}\n/**\r\n * Translates a dual quat by the given vector\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to translate\r\n * @param {vec3} v vector to translate by\r\n * @returns {quat2} out\r\n */\n\nfunction translate(out, a, v) {\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3],\n      bx1 = v[0] * 0.5,\n      by1 = v[1] * 0.5,\n      bz1 = v[2] * 0.5,\n      ax2 = a[4],\n      ay2 = a[5],\n      az2 = a[6],\n      aw2 = a[7];\n  out[0] = ax1;\n  out[1] = ay1;\n  out[2] = az1;\n  out[3] = aw1;\n  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\n  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\n  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\n  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the X axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\nfunction rotateX(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateX\"](out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the Y axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\nfunction rotateY(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateY\"](out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the Z axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\nfunction rotateZ(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateZ\"](out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat by a given quaternion (a * q)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {quat} q quaternion to rotate by\r\n * @returns {quat2} out\r\n */\n\nfunction rotateByQuatAppend(out, a, q) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  out[0] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[1] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[2] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[3] = aw * qw - ax * qx - ay * qy - az * qz;\n  ax = a[4];\n  ay = a[5];\n  az = a[6];\n  aw = a[7];\n  out[4] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[5] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[6] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[7] = aw * qw - ax * qx - ay * qy - az * qz;\n  return out;\n}\n/**\r\n * Rotates a dual quat by a given quaternion (q * a)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat} q quaternion to rotate by\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @returns {quat2} out\r\n */\n\nfunction rotateByQuatPrepend(out, q, a) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      bx = a[0],\n      by = a[1],\n      bz = a[2],\n      bw = a[3];\n  out[0] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[1] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[2] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[3] = qw * bw - qx * bx - qy * by - qz * bz;\n  bx = a[4];\n  by = a[5];\n  bz = a[6];\n  bw = a[7];\n  out[4] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[5] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[6] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[7] = qw * bw - qx * bx - qy * by - qz * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around a given axis. Does the normalisation automatically\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {vec3} axis the axis to rotate around\r\n * @param {Number} rad how far the rotation should be\r\n * @returns {quat2} out\r\n */\n\nfunction rotateAroundAxis(out, a, axis, rad) {\n  //Special case for rad = 0\n  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    return copy(out, a);\n  }\n\n  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  var bx = s * axis[0] / axisLength;\n  var by = s * axis[1] / axisLength;\n  var bz = s * axis[2] / axisLength;\n  var bw = Math.cos(rad);\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3];\n  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  out[4] = ax * bw + aw * bx + ay * bz - az * by;\n  out[5] = ay * bw + aw * by + az * bx - ax * bz;\n  out[6] = az * bw + aw * bz + ax * by - ay * bx;\n  out[7] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Adds two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  return out;\n}\n/**\r\n * Multiplies two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {quat2} out\r\n */\n\nfunction multiply(out, a, b) {\n  var ax0 = a[0],\n      ay0 = a[1],\n      az0 = a[2],\n      aw0 = a[3],\n      bx1 = b[4],\n      by1 = b[5],\n      bz1 = b[6],\n      bw1 = b[7],\n      ax1 = a[4],\n      ay1 = a[5],\n      az1 = a[6],\n      aw1 = a[7],\n      bx0 = b[0],\n      by0 = b[1],\n      bz0 = b[2],\n      bw0 = b[3];\n  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\n  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\n  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\n  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\n  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\n  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\n  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\n  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\n  return out;\n}\n/**\r\n * Alias for {@link quat2.multiply}\r\n * @function\r\n */\n\nvar mul = multiply;\n/**\r\n * Scales a dual quat by a scalar number\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {quat2} a the dual quat to scale\r\n * @param {Number} b amount to scale the dual quat by\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  return out;\n}\n/**\r\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\r\n *\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\n\nvar dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"dot\"];\n/**\r\n * Performs a linear interpolation between two dual quats's\r\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat2} out\r\n */\n\nfunction lerp(out, a, b, t) {\n  var mt = 1 - t;\n  if (dot(a, b) < 0) t = -t;\n  out[0] = a[0] * mt + b[0] * t;\n  out[1] = a[1] * mt + b[1] * t;\n  out[2] = a[2] * mt + b[2] * t;\n  out[3] = a[3] * mt + b[3] * t;\n  out[4] = a[4] * mt + b[4] * t;\n  out[5] = a[5] * mt + b[5] * t;\n  out[6] = a[6] * mt + b[6] * t;\n  out[7] = a[7] * mt + b[7] * t;\n  return out;\n}\n/**\r\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a dual quat to calculate inverse of\r\n * @returns {quat2} out\r\n */\n\nfunction invert(out, a) {\n  var sqlen = squaredLength(a);\n  out[0] = -a[0] / sqlen;\n  out[1] = -a[1] / sqlen;\n  out[2] = -a[2] / sqlen;\n  out[3] = a[3] / sqlen;\n  out[4] = -a[4] / sqlen;\n  out[5] = -a[5] / sqlen;\n  out[6] = -a[6] / sqlen;\n  out[7] = a[7] / sqlen;\n  return out;\n}\n/**\r\n * Calculates the conjugate of a dual quat\r\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat2} a quat to calculate conjugate of\r\n * @returns {quat2} out\r\n */\n\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  out[4] = -a[4];\n  out[5] = -a[5];\n  out[6] = -a[6];\n  out[7] = a[7];\n  return out;\n}\n/**\r\n * Calculates the length of a dual quat\r\n *\r\n * @param {quat2} a dual quat to calculate length of\r\n * @returns {Number} length of a\r\n * @function\r\n */\n\nvar length = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"length\"];\n/**\r\n * Alias for {@link quat2.length}\r\n * @function\r\n */\n\nvar len = length;\n/**\r\n * Calculates the squared length of a dual quat\r\n *\r\n * @param {quat2} a dual quat to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\n\nvar squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"squaredLength\"];\n/**\r\n * Alias for {@link quat2.squaredLength}\r\n * @function\r\n */\n\nvar sqrLen = squaredLength;\n/**\r\n * Normalize a dual quat\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a dual quaternion to normalize\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nfunction normalize(out, a) {\n  var magnitude = squaredLength(a);\n\n  if (magnitude > 0) {\n    magnitude = Math.sqrt(magnitude);\n    var a0 = a[0] / magnitude;\n    var a1 = a[1] / magnitude;\n    var a2 = a[2] / magnitude;\n    var a3 = a[3] / magnitude;\n    var b0 = a[4];\n    var b1 = a[5];\n    var b2 = a[6];\n    var b3 = a[7];\n    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n    out[4] = (b0 - a0 * a_dot_b) / magnitude;\n    out[5] = (b1 - a1 * a_dot_b) / magnitude;\n    out[6] = (b2 - a2 * a_dot_b) / magnitude;\n    out[7] = (b3 - a3 * a_dot_b) / magnitude;\n  }\n\n  return out;\n}\n/**\r\n * Returns a string representation of a dual quatenion\r\n *\r\n * @param {quat2} a dual quaternion to represent as a string\r\n * @returns {String} string representation of the dual quat\r\n */\n\nfunction str(a) {\n  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';\n}\n/**\r\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {quat2} a the first dual quaternion.\r\n * @param {quat2} b the second dual quaternion.\r\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];\n}\n/**\r\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {quat2} a the first dual quat.\r\n * @param {quat2} b the second dual quat.\r\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));\n}\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/quat2.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec2.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat2\", function() { return transformMat2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat2d\", function() { return transformMat2d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat3\", function() { return transformMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zero\", function() { return zero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\r\n * 2 Dimensional Vector\r\n * @module vec2\r\n */\n\n/**\r\n * Creates a new, empty vec2\r\n *\r\n * @returns {vec2} a new 2D vector\r\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with values from an existing vector\r\n *\r\n * @param {vec2} a vector to clone\r\n * @returns {vec2} a new 2D vector\r\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} a new 2D vector\r\n */\n\nfunction fromValues(x, y) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the source vector\r\n * @returns {vec2} out\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\n\nfunction set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Adds two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\r\n * Multiplies two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\r\n * Divides two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to ceil\r\n * @returns {vec2} out\r\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to floor\r\n * @returns {vec2} out\r\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to round\r\n * @returns {vec2} out\r\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\r\n * Adds two vec2's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec2} out\r\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.sqrt(x * x + y * y);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.sqrt(x * x + y * y);\n}\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to negate\r\n * @returns {vec2} out\r\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to invert\r\n * @returns {vec2} out\r\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\n\nfunction normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\r\n * Computes the cross product of two vec2's\r\n * Note that the cross product must by definition produce a 3D vector\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec2} out\r\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec2} out\r\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly '0'\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\r\n * Rotate a 2D vector\r\n * @param {vec2} out The receiving vec2\r\n * @param {vec2} a The vec2 point to rotate\r\n * @param {vec2} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec2} out\r\n */\n\nfunction rotate(out, a, b, c) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(c),\n      cosC = Math.cos(c); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\r\n * Get the angle between two 2D vectors\r\n * @param {vec2} a The first operand\r\n * @param {vec2} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nfunction angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1];\n  var len1 = x1 * x1 + y1 * y1;\n\n  if (len1 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len1 = 1 / Math.sqrt(len1);\n  }\n\n  var len2 = x2 * x2 + y2 * y2;\n\n  if (len2 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len2 = 1 / Math.sqrt(len2);\n  }\n\n  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;\n\n  if (cosine > 1.0) {\n    return 0;\n  } else if (cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n/**\r\n * Set the components of a vec2 to zero\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @returns {vec2} out\r\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec2} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction str(a) {\n  return 'vec2(' + a[0] + ', ' + a[1] + ')';\n}\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\r\n * Alias for {@link vec2.length}\r\n * @function\r\n */\n\nvar len = length;\n/**\r\n * Alias for {@link vec2.subtract}\r\n * @function\r\n */\n\nvar sub = subtract;\n/**\r\n * Alias for {@link vec2.multiply}\r\n * @function\r\n */\n\nvar mul = multiply;\n/**\r\n * Alias for {@link vec2.divide}\r\n * @function\r\n */\n\nvar div = divide;\n/**\r\n * Alias for {@link vec2.distance}\r\n * @function\r\n */\n\nvar dist = distance;\n/**\r\n * Alias for {@link vec2.squaredDistance}\r\n * @function\r\n */\n\nvar sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec2.squaredLength}\r\n * @function\r\n */\n\nvar sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec2s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/vec2.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hermite\", function() { return hermite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bezier\", function() { return bezier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat3\", function() { return transformMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformQuat\", function() { return transformQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zero\", function() { return zero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\n\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {vec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {vec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction fromValues(x, y, z) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the source vector\r\n * @returns {vec3} out\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\n\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Adds two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\r\n * Multiplies two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\r\n * Divides two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to floor\r\n * @returns {vec3} out\r\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to round\r\n * @returns {vec3} out\r\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\r\n * Adds two vec3's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {vec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to negate\r\n * @returns {vec3} out\r\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to invert\r\n * @returns {vec3} out\r\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\r\n * Computes the cross product of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\r\n * Performs a hermite interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {vec3} c the third operand\r\n * @param {vec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Performs a bezier interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {vec3} c the third operand\r\n * @param {vec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0 * Math.PI;\n  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {mat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {quat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\n\nfunction rotateX(out, a, b, c) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\n\nfunction rotateY(out, a, b, c) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\n\nfunction rotateZ(out, a, b, c) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {vec3} a The first operand\r\n * @param {vec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nfunction angle(a, b) {\n  var tempA = fromValues(a[0], a[1], a[2]);\n  var tempB = fromValues(b[0], b[1], b[2]);\n  normalize(tempA, tempA);\n  normalize(tempB, tempB);\n  var cosine = dot(tempA, tempB);\n\n  if (cosine > 1.0) {\n    return 0;\n  } else if (cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n/**\r\n * Set the components of a vec3 to zero\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @returns {vec3} out\r\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec3} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction str(a) {\n  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec3} a The first vector.\r\n * @param {vec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec3} a The first vector.\r\n * @param {vec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\r\n * Alias for {@link vec3.subtract}\r\n * @function\r\n */\n\nvar sub = subtract;\n/**\r\n * Alias for {@link vec3.multiply}\r\n * @function\r\n */\n\nvar mul = multiply;\n/**\r\n * Alias for {@link vec3.divide}\r\n * @function\r\n */\n\nvar div = divide;\n/**\r\n * Alias for {@link vec3.distance}\r\n * @function\r\n */\n\nvar dist = distance;\n/**\r\n * Alias for {@link vec3.squaredDistance}\r\n * @function\r\n */\n\nvar sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\n\nvar len = length;\n/**\r\n * Alias for {@link vec3.squaredLength}\r\n * @function\r\n */\n\nvar sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/vec3.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec4.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformQuat\", function() { return transformQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zero\", function() { return zero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\r\n * 4 Dimensional Vector\r\n * @module vec4\r\n */\n\n/**\r\n * Creates a new, empty vec4\r\n *\r\n * @returns {vec4} a new 4D vector\r\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with values from an existing vector\r\n *\r\n * @param {vec4} a vector to clone\r\n * @returns {vec4} a new 4D vector\r\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} a new 4D vector\r\n */\n\nfunction fromValues(x, y, z, w) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Copy the values from one vec4 to another\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the source vector\r\n * @returns {vec4} out\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to the given values\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} out\r\n */\n\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Adds two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Multiplies two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\r\n * Divides two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to ceil\r\n * @returns {vec4} out\r\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to floor\r\n * @returns {vec4} out\r\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to round\r\n * @returns {vec4} out\r\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\r\n * Scales a vec4 by a scalar number\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec4} out\r\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two vec4's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec4} out\r\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Calculates the length of a vec4\r\n *\r\n * @param {vec4} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n/**\r\n * Calculates the squared length of a vec4\r\n *\r\n * @param {vec4} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Negates the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to negate\r\n * @returns {vec4} out\r\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to invert\r\n * @returns {vec4} out\r\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\r\n * Normalize a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to normalize\r\n * @returns {vec4} out\r\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\r\n * Returns the cross-product of three vectors in a 4-dimensional space\r\n *\r\n * @param {vec4} result the receiving vector\r\n * @param {vec4} U the first vector\r\n * @param {vec4} V the second vector\r\n * @param {vec4} W the third vector\r\n * @returns {vec4} result\r\n */\n\nfunction cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n;\n/**\r\n * Performs a linear interpolation between two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec4} out\r\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec4} out\r\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a mat4.\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec4} out\r\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a quat\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to transform\r\n * @param {quat} q quaternion to transform with\r\n * @returns {vec4} out\r\n */\n\nfunction transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to zero\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @returns {vec4} out\r\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec4} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction str(a) {\n  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec4} a The first vector.\r\n * @param {vec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec4} a The first vector.\r\n * @param {vec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Alias for {@link vec4.subtract}\r\n * @function\r\n */\n\nvar sub = subtract;\n/**\r\n * Alias for {@link vec4.multiply}\r\n * @function\r\n */\n\nvar mul = multiply;\n/**\r\n * Alias for {@link vec4.divide}\r\n * @function\r\n */\n\nvar div = divide;\n/**\r\n * Alias for {@link vec4.distance}\r\n * @function\r\n */\n\nvar dist = distance;\n/**\r\n * Alias for {@link vec4.squaredDistance}\r\n * @function\r\n */\n\nvar sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec4.length}\r\n * @function\r\n */\n\nvar len = length;\n/**\r\n * Alias for {@link vec4.squaredLength}\r\n * @function\r\n */\n\nvar sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec4s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack:///./node_modules/gl-matrix/esm/vec4.js?");

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n\n\n//# sourceURL=webpack:///./node_modules/uuid/lib/bytesToUuid.js?");

/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/uuid/lib/rng-browser.js?");

/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n//# sourceURL=webpack:///./node_modules/uuid/v4.js?");

/***/ })

/******/ });